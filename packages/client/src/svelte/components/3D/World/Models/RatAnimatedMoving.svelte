<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.0 src/svelte/public/models/RatAnimated.glb
-->

<script>
  import { Group, Vector3, Quaternion, Matrix4 } from "three"
  import { Tween } from "svelte/motion"
  import { T, useTask } from "@threlte/core"
  import { useGltf, useGltfAnimations, useDraco } from "@threlte/extras"
  import { playSound } from "@svelte/modules/sound"
  import _ from "lodash"

  let handMesh = $state(null)
  let mousedown = $state(false)

  let {
    fallback,
    error,
    children,
    moving,
    getBoxState,
    ref = $bindable(),
    ...props
  } = $props()

  let { box } = getBoxState()

  ref = new Group()

  const dracoLoader = useDraco()
  const gltf = useGltf("/models/RatAnimated.glb", { dracoLoader })

  let handPositionX = new Tween(0, { duration: 100 })
  let handPositionY = new Tween(0, { duration: 100 })
  let handPositionZ = new Tween(0, { duration: 100 })
  let qx = new Tween(0, { duration: 100 })
  let qy = new Tween(0, { duration: 100 })
  let qz = new Tween(0, { duration: 100 })
  let petDown = new Tween(0, { duration: 100 })
  let handTargetWorldQuaternion = new Quaternion()
  let handCurrentWorldQuaternion = new Quaternion() // This will be slerped and applied

  export const { actions, mixer } = useGltfAnimations(gltf, ref)

  const positionHand = _.debounce(event => {
    const intersection = event.intersections[0]
    const localNormal = event.intersections[0].face.normal.clone()
    const worldNormal = localNormal.transformDirection(
      intersection.object.matrixWorld
    )

    const offsetDistance = 0.5 // Adjust as needed for your hand model size

    const worldHandPosition = new Vector3()
      .copy(intersection.point)
      .add(worldNormal.clone().multiplyScalar(offsetDistance))

    // Convert World Position to Hand's Parent Local Space
    // handMesh.position is local to its parent (T.Group name="Scene")
    const localHandPosition = handMesh.parent.worldToLocal(
      worldHandPosition.clone()
    )

    handPositionX.set(localHandPosition.x)
    handPositionY.set(localHandPosition.y)
    handPositionZ.set(localHandPosition.z)

    // Calculate Target Orientation (as a Quaternion)
    // The hand (at worldHandPosition) should orient itself relative to the surface.
    // We'll make the hand's local -Z axis point along the worldNormal (outwards from the surface)
    const tempLookAtMatrix = new Matrix4()

    // The "eye" is where the hand is.
    const eyePosition = worldHandPosition

    // The "target" is a point along the normal from the hand's position.
    const pointToLookAt = new Vector3().copy(worldHandPosition).add(worldNormal)

    // Determine a stable "up" vector for the lookAt matrix. Usually camera.up or world Y.
    let upVector = new Vector3(0, 1, 0) // World up
    upVector.copy(event.camera.up)

    tempLookAtMatrix.lookAt(eyePosition, pointToLookAt, upVector)
    handTargetWorldQuaternion.setFromRotationMatrix(tempLookAtMatrix)
  }, 50)

  $effect(() => {
    $actions["Walk.Stepped"]?.play()
  })

  $effect(() => {
    $actions?.["Walk.Stepped"]?.setEffectiveTimeScale(moving.current)
  })

  useTask(d => {
    if (handMesh && handMesh.parent) {
      // Slerp the handCurrentWorldQuaternion towards handTargetWorldQuaternion
      if (!handCurrentWorldQuaternion.equals(handTargetWorldQuaternion)) {
        handCurrentWorldQuaternion.slerp(handTargetWorldQuaternion, 0.1) // Adjust slerp factor as needed

        // Now, convert the slerped WORLD quaternion (handCurrentWorldQuaternion)
        // into the LOCAL quaternion required by handMesh.quaternion
        const parentWorldQuaternion = new Quaternion()
        handMesh.parent.getWorldQuaternion(parentWorldQuaternion) // Get parent's current world rotation

        const localTargetQuaternion = handCurrentWorldQuaternion.clone()
        localTargetQuaternion.premultiply(parentWorldQuaternion.invert()) // parentInverse * world = local

        handMesh.quaternion.copy(localTargetQuaternion)
      }
    }
  })
</script>

<svelte:window
  onmousedown={() => {
    petDown.set(0.4)
  }}
  onmouseup={() => {
    petDown.set(0)
  }}
/>

<T is={ref} dispose={false} {...props}>
  {#await gltf}
    {@render fallback?.()}
  {:then gltf}
    <T.Group rotation.y={Math.PI / 2} name="Scene">
      <T.Mesh
        visible={false}
        onpointerdown={() => {
          box?.pause()
          // console.log(box.target.current)
          playSound("tcm", Math.random < 0.2 ? "ratsUp" : "ratsDown")
          setTimeout(box.resume, 200 + Math.random() * 3000)
        }}
        onpointerover={positionHand}
        onpointermove={positionHand}
        position.y={0.5}
        rotation.x={Math.PI / 2}
      >
        <T.CapsuleGeometry args={[0.5, 0.5, 2, 16]} />
        <T.MeshNormalMaterial />
      </T.Mesh>
      <T.Group
        bind:ref={handMesh}
        position.x={handPositionX.current}
        position.y={handPositionY.current}
        position.z={handPositionZ.current}
        visible={false}
      >
        <T.Mesh position.z={petDown.current}>
          <T.BoxGeometry args={[1, 1, 0.2]} />
          <T.MeshNormalMaterial />
        </T.Mesh>
      </T.Group>

      <T.Group name="RIG-Rat_Rigify_Stepped">
        <T is={gltf.nodes.root} />
        <T is={gltf.nodes["MCH-torsoparent"]} />
        <T is={gltf.nodes["MCH-Shoulder_ikparentL001"]} />
        <T is={gltf.nodes["MCH-Shoulder_ik_targetparentL"]} />
        <T is={gltf.nodes["MCH-Shoulder_ikparentR001"]} />
        <T is={gltf.nodes["MCH-Shoulder_ik_targetparentR"]} />
        <T is={gltf.nodes["MCH-Shin_ikparentL"]} />
        <T is={gltf.nodes["MCH-Hip_ik_targetparentL"]} />
        <T is={gltf.nodes["MCH-Shin_ikparentR"]} />
        <T is={gltf.nodes["MCH-Hip_ik_targetparentR"]} />
        <T.SkinnedMesh
          castShadow
          name="Small_Up_NONMIRRORED001"
          geometry={gltf.nodes.Small_Up_NONMIRRORED001.geometry}
          material={gltf.materials.Rat}
          skeleton={gltf.nodes.Small_Up_NONMIRRORED001.skeleton}
        />
      </T.Group>
    </T.Group>
  {:catch err}
    {@render error?.({ error: err })}
  {/await}

  {@render children?.({ ref })}
</T>
