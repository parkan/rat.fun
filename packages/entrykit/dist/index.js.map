{"version":3,"sources":["../src/session/storage.ts","../src/session/getSessionSigner.ts","../src/session/getSessionAccount.ts","../src/core/types.ts","../src/bundler/getPaymaster.ts","../src/bundler/createBundlerClient.ts","../src/bundler/getBundlerTransport.ts","../src/session/getSessionClient.ts","../src/delegation/checkDelegation.ts","../src/utils/signCall.ts","../src/utils/callWithSignature.ts","../src/utils/defineCall.ts","../src/delegation/setupSession.ts","../src/EntryKit.ts"],"names":["viem_createBundlerClient","getRecord","getAction","viem_writeContract","worldSystemsConfig"],"mappings":"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","file":"index.js","sourcesContent":["import { Address, Hex } from \"viem\"\n\ntype SessionStore = {\n  signers: Record<string, string> // lowercase address → private key\n}\n\n/**\n * Session key storage using localStorage\n *\n * Manages persistent session private keys for each user address.\n * Keys are stored in localStorage and survive page refreshes.\n *\n * Storage format: { signers: { \"0xabc...\": \"0x123...\" } }\n * Storage key: \"entrykit:session-signers\"\n */\nexport class SessionStorage {\n  private cache: SessionStore\n  private readonly STORAGE_KEY = \"entrykit:session-signers\"\n\n  constructor() {\n    this.cache = this.load()\n  }\n\n  /**\n   * Load session store from localStorage\n   */\n  private load(): SessionStore {\n    if (typeof localStorage === \"undefined\") {\n      return { signers: {} }\n    }\n\n    const stored = localStorage.getItem(this.STORAGE_KEY)\n    if (!stored) {\n      return { signers: {} }\n    }\n\n    try {\n      return JSON.parse(stored)\n    } catch {\n      return { signers: {} }\n    }\n  }\n\n  /**\n   * Save session store to localStorage\n   */\n  private save(): void {\n    if (typeof localStorage === \"undefined\") return\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.cache))\n  }\n\n  /**\n   * Get session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @returns Private key if exists, undefined otherwise\n   */\n  getSigner(address: Address): Hex | undefined {\n    const key = address.toLowerCase()\n    return this.cache.signers[key] as Hex | undefined\n  }\n\n  /**\n   * Store session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @param privateKey Session private key to store\n   */\n  setSigner(address: Address, privateKey: Hex): void {\n    const key = address.toLowerCase()\n    this.cache.signers[key] = privateKey\n    this.save()\n  }\n\n  /**\n   * Remove session signer for a user address\n   *\n   * @param address User's wallet address\n   */\n  removeSigner(address: Address): void {\n    const key = address.toLowerCase()\n    delete this.cache.signers[key]\n    this.save()\n  }\n\n  /**\n   * Clear all session signers\n   */\n  clear(): void {\n    this.cache = { signers: {} }\n    this.save()\n  }\n}\n\n/**\n * Singleton session storage instance\n */\nexport const sessionStorage = new SessionStorage()\n","import { Address, Hex, isHex } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sessionStorage } from \"./storage\";\n\n/**\n * Get or create session signer for a user address\n *\n * Session signers are persistent private keys stored in localStorage.\n * They're used as the owner of the session smart account.\n *\n * If no signer exists for this user:\n * - Attempts to migrate from old MUD AccountKit storage format\n * - Otherwise generates a fresh random private key\n * - Stores the key for future use\n *\n * @param userAddress User's wallet address\n * @returns LocalAccount (viem account from private key)\n */\nexport function getSessionSigner(userAddress: Address) {\n  let privateKey = sessionStorage.getSigner(userAddress);\n\n  if (!privateKey) {\n    // Attempt to migrate from legacy MUD AccountKit storage format\n    // This allows existing users to keep their session accounts\n    const deprecatedKey =\n      typeof localStorage !== \"undefined\"\n        ? localStorage\n            .getItem(`mud:appSigner:privateKey:${userAddress.toLowerCase()}`)\n            ?.replace(/^\"(.*)\"$/, \"$1\") // Remove JSON quotes if present\n        : null;\n\n    // Use migrated key if valid, otherwise generate new random key\n    privateKey = (isHex(deprecatedKey) ? deprecatedKey : generatePrivateKey()) as Hex;\n    sessionStorage.setSigner(userAddress, privateKey);\n  }\n\n  return privateKeyToAccount(privateKey);\n}\n","import { Address, Chain, Client, LocalAccount, Transport } from \"viem\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { toSimpleSmartAccount } from \"permissionless/accounts\"\nimport { getSessionSigner } from \"./getSessionSigner\"\n\nexport type GetSessionAccountReturnType = {\n  readonly account: SmartAccount\n  readonly signer: LocalAccount\n}\n\nexport async function getSessionAccount<chain extends Chain>({\n  client,\n  userAddress\n}: {\n  client: Client<Transport, chain>\n  userAddress: Address\n}): Promise<GetSessionAccountReturnType> {\n  const signer = getSessionSigner(userAddress)\n  const account = await toSimpleSmartAccount({ client, owner: signer })\n  return { account, signer }\n}\n","import { resourceToHex } from \"@latticexyz/common\";\nimport { Client, Chain, Transport, Account, parseAbi, ClientConfig, Address, LocalAccount } from \"viem\";\nimport worldConfig from \"@latticexyz/world/mud.config\";\nimport { SmartAccount } from \"viem/account-abstraction\";\n\n/**\n * A viem client with an account (connected wallet)\n */\nexport type ConnectedClient<chain extends Chain = Chain> = Client<Transport, chain, Account>;\n\n/**\n * Session client - ERC-4337 smart account extended with MUD World functionality\n *\n * This is a standard viem client with:\n * - SmartAccount (ERC-4337 account abstraction)\n * - MUD World extensions (callFrom, sendUserOperationFrom)\n * - Context properties (userAddress, worldAddress, internal_signer)\n *\n * Use this to call World systems on behalf of the user via delegation.\n */\nexport type SessionClient<chain extends Chain = Chain> = Client<Transport, chain, SmartAccount> & {\n  /** Original user's wallet address (the delegator) */\n  readonly userAddress: Address;\n  /** MUD World contract address - all calls are routed through this */\n  readonly worldAddress: Address;\n  /** Session private key - used for signing messages on behalf of session account */\n  readonly internal_signer: LocalAccount;\n};\n\n/**\n * Default viem client configuration\n * Polling interval for watching blockchain state\n */\nexport const defaultClientConfig = {\n  pollingInterval: 250,\n} as const satisfies Pick<ClientConfig, \"pollingInterval\">;\n\n/**\n * MUD delegation control ID for \"unlimited\" delegation\n *\n * This is a resource ID that identifies the unlimited delegation control system.\n * When a user delegates to a session account with this ID, the session account\n * can call any system in the World on behalf of the user.\n *\n * Format: system resource with namespace=\"\" and name=\"unlimited\"\n */\nexport const unlimitedDelegationControlId = resourceToHex({\n  type: \"system\",\n  namespace: \"\",\n  name: \"unlimited\",\n});\n\n/**\n * MUD World table definitions from world config\n * Used to query World state (e.g., UserDelegationControl table)\n */\nexport const worldTables = worldConfig.namespaces.world.tables;\n\n/**\n * Minimal World ABI for delegation registration\n * Full ABI is large, we only need this one function\n */\nexport const worldAbi = parseAbi([\n  \"function registerDelegation(address delegatee, bytes32 delegationControlId, bytes initCallData)\",\n]);\n","import { Chain, Hex } from \"viem\";\nimport type { BundlerClientConfig, PaymasterClient } from \"viem/account-abstraction\";\n\n/**\n * Paymaster configuration\n *\n * Paymasters sponsor gas for user operations (ERC-4337).\n * Two types supported:\n *\n * - **simple**: Basic paymaster with just an address\n *   Returns paymaster address with empty data\n *\n * - **custom**: Advanced paymaster with client\n *   Uses provided PaymasterClient for dynamic sponsorship logic\n *   (e.g., Coinbase Paymaster, Pimlico, etc.)\n */\nexport type Paymaster =\n  | {\n      readonly type: \"simple\";\n      readonly address: Hex;\n    }\n  | {\n      readonly type: \"custom\";\n      readonly address?: Hex;\n      readonly paymasterClient: BundlerClientConfig[\"paymaster\"];\n    };\n\n/**\n * Get paymaster configuration for a chain\n *\n * Priority:\n * 1. Use paymasterOverride if provided (custom paymaster client)\n * 2. Check chain.contracts.paymaster for simple paymaster address\n * 3. Return undefined if no paymaster configured (user pays own gas)\n *\n * @param chain Chain configuration\n * @param paymasterOverride Optional custom paymaster client\n * @returns Paymaster config or undefined\n */\nexport function getPaymaster(chain: Chain, paymasterOverride?: PaymasterClient): Paymaster | undefined {\n  const contracts = chain.contracts ?? {};\n\n  // Use custom paymaster if provided (e.g., Coinbase Paymaster)\n  if (paymasterOverride) {\n    return {\n      type: \"custom\",\n      paymasterClient: paymasterOverride,\n    };\n  }\n\n  // Check for simple paymaster in chain config\n  if (\"paymaster\" in contracts && contracts.paymaster != null) {\n    if (\"address\" in contracts.paymaster) {\n      return {\n        type: \"simple\",\n        address: contracts.paymaster.address,\n      };\n    }\n  }\n\n  // No paymaster configured - user pays own gas\n  return undefined;\n}\n","import { Transport, Chain, Client, RpcSchema, EstimateFeesPerGasReturnType } from \"viem\";\nimport {\n  BundlerClient,\n  BundlerClientConfig,\n  SmartAccount,\n  createBundlerClient as viem_createBundlerClient,\n} from \"viem/account-abstraction\";\nimport { defaultClientConfig } from \"../core/types\";\nimport { getPaymaster } from \"./getPaymaster\";\n\n/**\n * Create a bundler client for submitting ERC-4337 user operations\n *\n * A bundler client is a specialized viem client that:\n * - Submits user operations to the bundler RPC\n * - Handles gas estimation for user operations\n * - Integrates paymaster for gas sponsorship\n * - Manages smart account interactions\n *\n * This function wraps viem's createBundlerClient with:\n * - Automatic paymaster configuration from chain or override\n * - Custom fee estimation for Anvil (local dev)\n * - Default polling interval\n *\n * @param config Bundler client configuration\n * @returns Configured bundler client\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain = Chain,\n  account extends SmartAccount = SmartAccount,\n  client extends Client = Client,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  config: BundlerClientConfig<transport, chain, account, client, rpcSchema>,\n): BundlerClient<transport, chain, account, client, rpcSchema> {\n  const client = config.client;\n  if (!client) throw new Error(\"No `client` provided to `createBundlerClient`.\");\n\n  const chain = config.chain ?? client.chain;\n  const paymaster = chain ? getPaymaster(chain, config.paymaster) : undefined;\n\n  return viem_createBundlerClient({\n    ...defaultClientConfig,\n    // Configure paymaster for gas sponsorship\n    paymaster: paymaster\n      ? paymaster.type === \"custom\"\n        ? paymaster.paymasterClient // Use custom paymaster client (e.g., Coinbase)\n        : {\n            // Simple paymaster - just return address with empty data\n            getPaymasterData: async () => ({\n              paymaster: paymaster.address,\n              paymasterData: \"0x\",\n            }),\n          }\n      : undefined,\n    // Custom fee estimation for certain chains\n    userOperation: {\n      estimateFeesPerGas: createFeeEstimator(client),\n    },\n    ...config,\n  });\n}\n\n/**\n * Create custom fee estimator for specific chains\n *\n * Some chains need special handling for fee estimation:\n *\n * - **Anvil (31337)**: Hardcoded fees because Anvil's eth_maxPriorityFeePerGas\n *   returns a fixed value that doesn't match real chains\n *\n * - **Other chains**: Use viem's default fee estimation (works well)\n *\n * @param client Viem client\n * @returns Fee estimator function or undefined for default behavior\n */\nfunction createFeeEstimator(client: Client): undefined | (() => Promise<EstimateFeesPerGasReturnType<\"eip1559\">>) {\n  if (!client.chain) return;\n\n  // Anvil (local development) - use fixed fees\n  // See: https://github.com/foundry-rs/foundry/pull/8081#issuecomment-2402002485\n  if (client.chain.id === 31337) {\n    return async () => ({ maxFeePerGas: 100_000n, maxPriorityFeePerGas: 0n });\n  }\n\n  // All other chains - use viem's default fee estimation\n  return undefined;\n}\n","import { Chain, http } from \"viem\";\n\n/**\n * Get bundler RPC transport for a chain\n *\n * Bundlers are special RPC endpoints that handle ERC-4337 user operations.\n * They submit user operations to the EntryPoint contract and handle gas sponsorship.\n *\n * The bundler URL must be configured in the chain's rpcUrls.bundler.http array.\n *\n * @param chain Chain configuration with bundler RPC URL\n * @returns HTTP transport for the bundler\n * @throws If chain doesn't have a bundler RPC URL configured\n */\nexport function getBundlerTransport(chain: Chain) {\n  const bundlerHttpUrl = chain.rpcUrls.bundler?.http[0];\n\n  if (bundlerHttpUrl) {\n    return http(bundlerHttpUrl);\n  }\n\n  throw new Error(`Chain ${chain.id} config did not include a bundler RPC URL.`);\n}\n","import { Account, Address, Chain, Client, LocalAccount, RpcSchema, Transport } from \"viem\";\nimport { smartAccountActions } from \"permissionless\";\nimport { callFrom, sendUserOperationFrom } from \"@latticexyz/world/internal\";\nimport type { PaymasterClient } from \"viem/account-abstraction\";\nimport { createBundlerClient } from \"../bundler/createBundlerClient\";\nimport { SessionClient } from \"../core/types\";\nimport { SmartAccount } from \"viem/account-abstraction\";\nimport { getBundlerTransport } from \"../bundler/getBundlerTransport\";\n\n/**\n * Create session client with MUD World extensions\n *\n * Takes a standard ERC-4337 smart account and extends it with MUD-specific functionality:\n *\n * 1. **smartAccountActions** - Standard AA operations (sendUserOperation, etc.)\n * 2. **callFrom** - Routes writeContract calls through World.callFrom()\n *    - Automatically adds delegator context\n *    - World validates delegation before executing\n * 3. **sendUserOperationFrom** - Routes user operations through World\n * 4. **Context properties** - Adds userAddress, worldAddress, internal_signer\n *\n * The resulting SessionClient can call World systems on behalf of the user,\n * as long as delegation is registered.\n *\n * @param params Session client parameters\n * @returns SessionClient with MUD World extensions\n */\nexport async function getSessionClient({\n  userAddress,\n  sessionAccount,\n  sessionSigner,\n  worldAddress,\n  paymasterOverride,\n}: {\n  userAddress: Address;\n  sessionAccount: SmartAccount;\n  sessionSigner: LocalAccount;\n  worldAddress: Address;\n  paymasterOverride?: PaymasterClient;\n}): Promise<SessionClient> {\n  const client = sessionAccount.client;\n  if (!clientHasChain(client)) {\n    throw new Error(\"Session account client had no associated chain.\");\n  }\n\n  // Create bundler client for submitting user operations\n  const bundlerClient = createBundlerClient({\n    transport: getBundlerTransport(client.chain),\n    client,\n    account: sessionAccount,\n    paymaster: paymasterOverride,\n  });\n\n  // Extend with standard ERC-4337 smart account actions\n  const sessionClient = bundlerClient\n    .extend(smartAccountActions)\n    // Extend with MUD World delegation routing\n    // This intercepts writeContract calls and routes them through World.callFrom()\n    .extend(\n      callFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client,\n      }),\n    )\n    // Extend with MUD World user operation routing\n    .extend(\n      sendUserOperationFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client,\n      }),\n    )\n    // Add context properties for reference\n    .extend(() => ({ userAddress, worldAddress, internal_signer: sessionSigner }));\n\n  return sessionClient;\n}\n\n/**\n * Type guard to ensure client has a chain\n */\nfunction clientHasChain<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  client: Client<transport, chain, account, rpcSchema>,\n): client is Client<transport, Exclude<chain, undefined>, account, rpcSchema> {\n  return client.chain != null;\n}\n","import { Address, Client } from \"viem\";\nimport { getRecord } from \"@latticexyz/store/internal\";\nimport { unlimitedDelegationControlId, worldTables } from \"../core/types\";\n\nexport type CheckDelegationParams = {\n  client: Client;\n  worldAddress: Address;\n  userAddress: Address;\n  sessionAddress: Address;\n  blockTag?: \"pending\" | \"latest\";\n};\n\n/**\n * Check if delegation exists in MUD World contract\n *\n * MUD World stores delegations in the UserDelegationControl table.\n * A delegation allows the session account (delegatee) to call World systems\n * on behalf of the user account (delegator).\n *\n * This function queries that table and checks if \"unlimited\" delegation exists,\n * which grants the session account full access to all systems.\n *\n * @param params Delegation check parameters\n * @returns true if unlimited delegation is registered, false otherwise\n */\nexport async function checkDelegation({\n  client,\n  worldAddress,\n  userAddress,\n  sessionAddress,\n  blockTag = \"pending\",\n}: CheckDelegationParams): Promise<boolean> {\n  // Query MUD Store table: UserDelegationControl[delegator][delegatee]\n  const record = await getRecord(client, {\n    address: worldAddress,\n    table: worldTables.UserDelegationControl,\n    key: { delegator: userAddress, delegatee: sessionAddress },\n    blockTag,\n  });\n\n  // Check if the delegation type is \"unlimited\" (full system access)\n  return record.delegationControlId === unlimitedDelegationControlId;\n}\n","import { Address, Chain, Client, Hex, OneOf, Transport, toHex } from \"viem\";\nimport { signTypedData } from \"viem/actions\";\nimport { callWithSignatureTypes } from \"@latticexyz/world-module-callwithsignature/internal\";\nimport { getRecord } from \"@latticexyz/store/internal\";\nimport moduleConfig from \"@latticexyz/world-module-callwithsignature/mud.config\";\nimport { hexToResource } from \"@latticexyz/common\";\nimport { getAction } from \"viem/utils\";\nimport { ConnectedClient } from \"../core/types\";\n\nexport type SignCallOptions<chain extends Chain = Chain> = {\n  userClient: ConnectedClient<chain>;\n  worldAddress: Address;\n  systemId: Hex;\n  callData: Hex;\n} & OneOf<{ nonce: bigint } | { client: Client<Transport, chain> }>;\n\n/**\n * Sign a World system call using EIP-712 (for CallWithSignature pattern)\n *\n * This creates a signature that can be submitted by the session account to execute\n * a call on behalf of the user (EOA).\n *\n * Flow:\n * 1. **Fetch or use nonce** - Each user has a nonce in CallWithSignatureNonces table\n *    Prevents replay attacks\n *\n * 2. **Parse systemId** - MUD system IDs are resource IDs with namespace + name\n *    e.g., \"world:PlayerSystem\" → { namespace: \"world\", name: \"PlayerSystem\" }\n *\n * 3. **Sign EIP-712 message** - User signs typed data with:\n *    - Domain: World contract + chain ID\n *    - Message: signer, system, callData, nonce\n *\n * The resulting signature can be submitted to World.callWithSignature()\n * by the session account, which will validate and execute as the user.\n *\n * **Why this pattern?**\n * - EOAs can't pay gas via paymaster directly (not smart accounts)\n * - User signs message (free, no gas)\n * - Session account submits + pays gas via paymaster\n * - User gets gasless experience!\n *\n * @param options Sign options including user client and call details\n * @returns EIP-712 signature\n */\nexport async function signCall<chain extends Chain = Chain>({\n  userClient,\n  worldAddress,\n  systemId,\n  callData,\n  nonce: initialNonce,\n  client,\n}: SignCallOptions<chain>) {\n  // Get nonce for replay protection\n  // Either use provided nonce or fetch from World contract\n  const nonce =\n    initialNonce ??\n    (client\n      ? (\n          await getRecord(client, {\n            address: worldAddress,\n            table: moduleConfig.tables.CallWithSignatureNonces,\n            key: { signer: userClient.account.address },\n            blockTag: \"pending\",\n          })\n        ).nonce\n      : 0n);\n\n  // Parse MUD system ID into namespace and name components\n  const { namespace: systemNamespace, name: systemName } = hexToResource(systemId);\n\n  // Sign EIP-712 typed data\n  // User signs this message, session account will submit it\n  return await getAction(userClient, signTypedData, \"signTypedData\")({\n    account: userClient.account,\n    // EIP-712 domain bound to World contract and chain\n    domain: {\n      verifyingContract: worldAddress,\n      salt: toHex(userClient.chain.id, { size: 32 }),\n    },\n    // MUD's CallWithSignature type definitions\n    types: callWithSignatureTypes,\n    primaryType: \"Call\",\n    // Message contains all call details + nonce\n    message: {\n      signer: userClient.account.address,\n      systemNamespace,\n      systemName,\n      callData,\n      nonce,\n    },\n  });\n}\n","import { Chain, parseErc6492Signature } from \"viem\";\nimport { writeContract as viem_writeContract } from \"viem/actions\";\nimport { getAction } from \"viem/utils\";\nimport { SignCallOptions, signCall } from \"./signCall\";\nimport CallWithSignatureAbi from \"@latticexyz/world-module-callwithsignature/out/CallWithSignatureSystem.sol/CallWithSignatureSystem.abi.json\";\nimport { ConnectedClient } from \"../core/types\";\n\nexport type CallWithSignatureOptions<chain extends Chain = Chain> = SignCallOptions<chain> & {\n  sessionClient: ConnectedClient;\n};\n\n/**\n * Call a World system using signature-based execution (for EOAs)\n *\n * MUD's CallWithSignature pattern allows EOAs to execute gasless transactions:\n *\n * 1. User signs an EIP-712 message (free, off-chain)\n * 2. Session account submits the signature + call to World\n * 3. World's CallWithSignatureSystem validates the signature\n * 4. If valid, executes the call as the user (with user's identity)\n *\n * This enables gasless transactions for EOAs - the session account pays gas\n * via paymaster, but the call executes with the user's permissions/identity.\n *\n * Flow:\n *   User (EOA) → signs message → Session Account → submits to World\n *   → World validates signature → executes as User\n *\n * @param options Call parameters including user client and session client\n * @returns Transaction hash\n * @throws If ERC-6492 signature detected (not yet supported)\n */\nexport async function callWithSignature<chain extends Chain = Chain>({\n  sessionClient,\n  ...opts\n}: CallWithSignatureOptions<chain>) {\n  // Get user's signature on the call\n  const rawSignature = await signCall(opts);\n\n  // Check for ERC-6492 wrapped signatures (e.g., from Coinbase Smart Wallet)\n  // These aren't yet supported by CallWithSignature module\n  const { address, signature } = parseErc6492Signature(rawSignature);\n  if (address != null) {\n    throw new Error(\n      \"ERC-6492 signatures, like from Coinbase Smart Wallet, are not yet supported. Try using a different wallet?\",\n    );\n  }\n\n  // Session account submits the signature + call to World\n  return getAction(sessionClient, viem_writeContract, \"writeContract\")({\n    address: opts.worldAddress,\n    abi: CallWithSignatureAbi,\n    functionName: \"callWithSignature\",\n    args: [opts.userClient.account.address, opts.systemId, opts.callData, signature],\n  } as never);\n}\n","import { Address, ContractFunctionParameters, Abi } from \"viem\"\n\nexport function defineCall<abi extends Abi | readonly unknown[]>(\n  call: Omit<ContractFunctionParameters<abi>, \"address\"> & {\n    to: Address\n    value?: bigint | undefined\n  }\n) {\n  return call\n}\n","import { Hex, encodeFunctionData, zeroAddress, Client } from \"viem\";\nimport { sendUserOperation, waitForUserOperationReceipt } from \"viem/account-abstraction\";\nimport { waitForTransactionReceipt } from \"viem/actions\";\nimport { getAction } from \"viem/utils\";\nimport IBaseWorldAbi from \"@latticexyz/world/out/IBaseWorld.sol/IBaseWorld.abi.json\";\nimport { systemsConfig as worldSystemsConfig } from \"@latticexyz/world/mud.config\";\nimport { unlimitedDelegationControlId, worldAbi, SessionClient } from \"../core/types\";\nimport { callWithSignature } from \"../utils/callWithSignature\";\nimport { defineCall } from \"../utils/defineCall\";\n\nexport type SetupSessionParams = {\n  client: any;\n  userClient: any;\n  sessionClient: SessionClient;\n  worldAddress: Hex;\n  registerDelegation?: boolean;\n};\n\n/**\n * Setup session by registering delegation and deploying session account\n *\n * Flow differs based on wallet type:\n *\n * **Smart Account Wallet:**\n * - Sends user operation to register delegation\n * - User's smart account submits the operation\n *\n * **EOA (Externally Owned Account):**\n * - Uses CallWithSignature pattern (gasless for user)\n * - User signs a message (EIP-712)\n * - Session account submits the signature + call\n * - World validates signature and executes as user\n *\n * **Finally:**\n * - Deploys session account if not yet deployed (via empty user operation)\n *\n * @param params Setup parameters\n */\nexport async function setupSession({\n  client,\n  userClient,\n  sessionClient,\n  worldAddress,\n  registerDelegation = true,\n}: SetupSessionParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address;\n\n  console.log(\"setting up session\", userClient);\n\n  if (userClient.account.type === \"smart\") {\n    // ===== Smart Account Flow =====\n    // User's wallet is already a smart account (e.g., Safe, Biconomy)\n    // Can submit user operations directly\n\n    const calls = [];\n\n    if (registerDelegation) {\n      console.log(\"registering delegation\");\n      calls.push(\n        defineCall({\n          to: worldAddress,\n          abi: worldAbi,\n          functionName: \"registerDelegation\",\n          args: [sessionAddress, unlimitedDelegationControlId, \"0x\"],\n        }),\n      );\n    }\n\n    if (!calls.length) return;\n\n    console.log(\"setting up account with\", calls, userClient);\n    const hash = await getAction(userClient, sendUserOperation, \"sendUserOperation\")({ calls });\n    console.log(\"got user op hash\", hash);\n\n    const receipt = await getAction(\n      userClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\",\n    )({ hash });\n    console.log(\"got user op receipt\", receipt);\n\n    if (!receipt.success) {\n      console.error(\"not successful?\", receipt);\n    }\n  } else {\n    // ===== EOA Flow (CallWithSignature) =====\n    // User's wallet is a regular EOA (MetaMask, etc.)\n    // Uses MUD's CallWithSignature pattern for gasless execution:\n    //   1. User signs message (free, no gas)\n    //   2. Session account submits signature + call (pays gas via paymaster)\n    //   3. World validates signature and executes as user\n\n    const txs: Hex[] = [];\n\n    if (registerDelegation) {\n      console.log(\"registering delegation\");\n      const tx = await callWithSignature({\n        client,\n        userClient,\n        sessionClient,\n        worldAddress,\n        systemId: worldSystemsConfig.systems.RegistrationSystem.systemId,\n        callData: encodeFunctionData({\n          abi: IBaseWorldAbi,\n          functionName: \"registerDelegation\",\n          args: [sessionAddress, unlimitedDelegationControlId, \"0x\"],\n        }),\n      });\n      console.log(\"got delegation tx\", tx);\n      txs.push(tx);\n    }\n\n    if (!txs.length) return;\n\n    console.log(\"waiting for\", txs.length, \"receipts\");\n    for (const hash of txs) {\n      const receipt = await getAction(client, waitForTransactionReceipt, \"waitForTransactionReceipt\")({ hash });\n      console.log(\"got tx receipt\", receipt);\n      if (receipt.status === \"reverted\") {\n        console.error(\"tx reverted?\", receipt);\n      }\n    }\n  }\n\n  // ===== Deploy Session Account =====\n  // Session account needs to be deployed before it can be used.\n  // We deploy it eagerly here (rather than lazily on first use) so downstream\n  // code can assume the account exists and has a deterministic address.\n\n  if (!(await sessionClient.account.isDeployed?.())) {\n    console.log(\"creating session account by sending empty user op\");\n\n    // Send empty user operation to trigger account deployment\n    // The bundler/EntryPoint will deploy the account as part of executing this operation\n    const hash = await getAction(\n      sessionClient,\n      sendUserOperation,\n      \"sendUserOperation\",\n    )({\n      calls: [{ to: zeroAddress }],\n    });\n\n    const receipt = await getAction(\n      sessionClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\",\n    )({ hash });\n    console.log(\"got user op receipt\", receipt);\n  }\n}\n","import { Address, Client } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { SessionClient } from \"./core/types\"\nimport { getSessionSigner } from \"./session/getSessionSigner\"\nimport { getSessionAccount } from \"./session/getSessionAccount\"\nimport { getSessionClient } from \"./session/getSessionClient\"\nimport { checkDelegation } from \"./delegation/checkDelegation\"\nimport { setupSession } from \"./delegation/setupSession\"\nimport { sessionStorage } from \"./session/storage\"\n\n/**\n * Configuration for EntryKit instance\n */\nexport type EntryKitConfig = {\n  /** Chain ID to operate on */\n  chainId: number\n  /** MUD World contract address */\n  worldAddress: Address\n  /** Optional paymaster client for sponsored transactions */\n  paymasterClient?: PaymasterClient\n}\n\n/**\n * Current state of the EntryKit instance\n * Updated reactively and broadcast to subscribers\n */\nexport type EntryKitState = {\n  /** Session client with MUD World extensions, null if not connected */\n  sessionClient: SessionClient | null\n  /** Original user's wallet address, null if not connected */\n  userAddress: Address | null\n  /** Session smart account address, null if not connected */\n  sessionAddress: Address | null\n  /** Whether session has delegation registered and is ready to use */\n  isReady: boolean\n}\n\n/**\n * Result of checking session prerequisites\n */\nexport type PrerequisiteStatus = {\n  /** Whether delegation is registered in World contract */\n  hasDelegation: boolean\n  /** Whether session is fully ready (same as hasDelegation) */\n  isReady: boolean\n}\n\ntype StateListener = (state: EntryKitState) => void\ntype Unsubscribe = () => void\n\n/**\n * EntryKit - Framework-agnostic session account management for MUD applications\n *\n * Provides:\n * - ERC-4337 session account creation\n * - MUD World delegation registration\n * - Reactive state management (framework-agnostic)\n * - Gasless transaction support via paymaster\n *\n * Usage:\n * ```typescript\n * const entrykit = new EntryKit({\n *   chainId: 8453,\n *   worldAddress: \"0x...\",\n *   paymasterClient: myPaymaster\n * });\n *\n * // Subscribe to state changes\n * entrykit.subscribe((state) => {\n *   console.log(\"Session:\", state.sessionClient);\n * });\n *\n * // Connect wallet\n * await entrykit.connect(walletClient);\n *\n * // Setup delegation if needed\n * if (!entrykit.isReady) {\n *   await entrykit.setupSession(walletClient);\n * }\n * ```\n */\nexport class EntryKit {\n  private config: EntryKitConfig\n  private state: EntryKitState\n  private listeners = new Set<StateListener>()\n\n  constructor(config: EntryKitConfig) {\n    this.config = config\n    this.state = {\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false\n    }\n  }\n\n  // ===== Reactive State Management =====\n\n  /**\n   * Subscribe to state changes\n   *\n   * The listener will be called immediately with the current state,\n   * and again whenever the state changes.\n   *\n   * @param listener Function to call on state changes\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = entrykit.subscribe((state) => {\n   *   if (state.sessionClient) {\n   *     console.log(\"Session ready:\", state.sessionClient.account.address);\n   *   }\n   * });\n   *\n   * // Later, stop listening\n   * unsubscribe();\n   * ```\n   */\n  subscribe(listener: StateListener): Unsubscribe {\n    this.listeners.add(listener)\n    listener(this.state) // Immediate callback with current state\n    return () => this.listeners.delete(listener)\n  }\n\n  /**\n   * Get current state (non-reactive snapshot)\n   *\n   * For reactive updates, use subscribe() instead.\n   */\n  getState(): EntryKitState {\n    return { ...this.state }\n  }\n\n  private updateState(updates: Partial<EntryKitState>): void {\n    this.state = { ...this.state, ...updates }\n    this.notify()\n  }\n\n  private notify(): void {\n    this.listeners.forEach(listener => listener(this.state))\n  }\n\n  // ===== Core API =====\n\n  /**\n   * Connect with user's wallet and create session account\n   *\n   * This will:\n   * 1. Generate or retrieve session keypair from localStorage\n   * 2. Create a SimpleAccount smart account with session keypair as owner\n   * 3. Create a SessionClient with MUD World extensions\n   * 4. Check if delegation already exists\n   *\n   * After this, check `isReady` to see if delegation needs to be set up.\n   *\n   * @param userClient User's wallet client (from wagmi/viem)\n   * @throws If wallet client is missing account or chain\n   */\n  async connect(userClient: Client): Promise<void> {\n    if (!userClient.account) {\n      throw new Error(\"Wallet client must have an account.\")\n    }\n    if (!userClient.chain) {\n      throw new Error(\"Wallet client must have a chain.\")\n    }\n\n    const userAddress = userClient.account.address\n\n    // Get or create persistent session signer from localStorage\n    const signer = getSessionSigner(userAddress)\n\n    // Create ERC-4337 SimpleAccount smart wallet\n    const { account } = await getSessionAccount({\n      client: userClient as any,\n      userAddress\n    })\n\n    // Create session client with MUD World callFrom/sendUserOperationFrom extensions\n    const sessionClient = await getSessionClient({\n      userAddress,\n      sessionAccount: account,\n      sessionSigner: signer,\n      worldAddress: this.config.worldAddress,\n      paymasterOverride: this.config.paymasterClient\n    })\n\n    this.updateState({\n      sessionClient,\n      userAddress,\n      sessionAddress: account.address\n    })\n\n    // Check if delegation already exists in World contract\n    await this.checkPrerequisites()\n  }\n\n  /**\n   * Check if session is ready to use\n   *\n   * Queries the MUD World contract to check if delegation is registered\n   * between the user's account and the session account.\n   *\n   * @returns Delegation status\n   */\n  async checkPrerequisites(): Promise<PrerequisiteStatus> {\n    if (!this.state.sessionClient) {\n      return { hasDelegation: false, isReady: false }\n    }\n\n    const hasDelegation = await checkDelegation({\n      client: this.state.sessionClient,\n      worldAddress: this.config.worldAddress,\n      userAddress: this.state.userAddress!,\n      sessionAddress: this.state.sessionAddress!\n    })\n\n    this.updateState({ isReady: hasDelegation })\n\n    return { hasDelegation, isReady: hasDelegation }\n  }\n\n  /**\n   * Setup session by registering delegation and deploying account\n   *\n   * This will:\n   * 1. Register delegation in MUD World contract (user delegates to session)\n   * 2. Deploy session smart account if not already deployed\n   *\n   * User will need to sign a transaction (EOA) or user operation (smart account).\n   *\n   * @param userClient User's wallet client for signing the delegation\n   * @throws If not connected (call connect() first)\n   */\n  async setupSession(userClient: Client): Promise<void> {\n    if (!this.state.sessionClient) {\n      throw new Error(\"Not connected. Call connect() first.\")\n    }\n\n    await setupSession({\n      client: userClient,\n      userClient,\n      sessionClient: this.state.sessionClient,\n      worldAddress: this.config.worldAddress\n    })\n\n    this.updateState({ isReady: true })\n  }\n\n  /**\n   * Disconnect and clear session state\n   *\n   * Note: This does NOT clear stored session keys.\n   * Use clearStorage() to permanently remove session keys.\n   */\n  disconnect(): void {\n    this.updateState({\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false\n    })\n  }\n\n  /**\n   * Clear stored session keys from localStorage\n   *\n   * This permanently removes the session private key for the current user.\n   * Next time connect() is called, a new session account will be created.\n   */\n  clearStorage(): void {\n    if (this.state.userAddress) {\n      sessionStorage.removeSigner(this.state.userAddress)\n    }\n  }\n\n  // ===== Convenience Getters =====\n\n  /** Get current session client (null if not connected) */\n  get sessionClient(): SessionClient | null {\n    return this.state.sessionClient\n  }\n\n  /** Get current user address (null if not connected) */\n  get userAddress(): Address | null {\n    return this.state.userAddress\n  }\n\n  /** Get current session account address (null if not connected) */\n  get sessionAddress(): Address | null {\n    return this.state.sessionAddress\n  }\n\n  /** Check if session is ready (has delegation) */\n  get isReady(): boolean {\n    return this.state.isReady\n  }\n}\n"]}