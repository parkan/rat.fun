{"language":"Solidity","sources":{"src/external/ItemNFT.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { Base64 } from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\nimport { IBaseWorld } from \"@latticexyz/world/src/codegen/interfaces/IBaseWorld.sol\";\nimport { ResourceAccess } from \"@latticexyz/world/src/codegen/tables/ResourceAccess.sol\";\nimport { WorldResourceIdLib } from \"@latticexyz/world/src/WorldResourceId.sol\";\n\n/**\n * @title ItemNFT\n * @dev ERC721 contract for exporting in-game items as NFTs.\n * Stores the item's entity ID (for re-importing) and name/value (for external display).\n * Only the ratfun namespace systems can mint/burn tokens.\n * Extends ERC721Enumerable to allow querying owned tokens.\n */\ncontract ItemNFT is ERC721Enumerable {\n  /// @notice Counter for generating unique token IDs\n  uint256 private _nextTokenId;\n\n  /// @notice Maps token ID to the item's MUD entity ID\n  mapping(uint256 => bytes32) public itemIds;\n\n  /// @notice On-chain storage for item names (for external display)\n  mapping(uint256 => string) public itemNames;\n\n  /// @notice On-chain storage for item values (for external display)\n  mapping(uint256 => uint256) public itemValues;\n\n  /// @notice Emitted when an item is exported to NFT\n  event ItemExported(\n    uint256 indexed tokenId,\n    address indexed owner,\n    bytes32 indexed itemId,\n    string name,\n    uint256 value\n  );\n\n  /// @notice Emitted when an NFT is imported back to the game\n  event ItemImported(uint256 indexed tokenId, address indexed owner, bytes32 indexed itemId);\n\n  constructor(IBaseWorld _world) ERC721(\"RAT.FUN PSYCHO OBJECT\", \"PSYOBJ\") {\n    StoreSwitch.setStoreAddress(address(_world));\n  }\n\n  modifier onlyNamespace(bytes14 namespace) {\n    require(ResourceAccess.get(WorldResourceIdLib.encodeNamespace(namespace), msg.sender), \"no namespace access\");\n    _;\n  }\n\n  /**\n   * @notice Mint a new item NFT\n   * @dev Only callable by systems with ratfun namespace access\n   * @param to Address to mint to\n   * @param itemId The item's MUD entity ID\n   * @param name Item name (for external display)\n   * @param value Item value (for external display)\n   * @return tokenId The minted token ID\n   */\n  function mint(\n    address to,\n    bytes32 itemId,\n    string calldata name,\n    uint256 value\n  ) external onlyNamespace(\"ratfun\") returns (uint256 tokenId) {\n    tokenId = _nextTokenId++;\n    _mint(to, tokenId);\n    itemIds[tokenId] = itemId;\n    itemNames[tokenId] = name;\n    itemValues[tokenId] = value;\n    emit ItemExported(tokenId, to, itemId, name, value);\n  }\n\n  /**\n   * @notice Burn an NFT (for import back to game)\n   * @dev Only callable by systems with ratfun namespace access\n   * @param tokenId Token ID to burn\n   * @return itemId The item's MUD entity ID\n   */\n  function burn(uint256 tokenId) external onlyNamespace(\"ratfun\") returns (bytes32 itemId) {\n    address owner = ownerOf(tokenId);\n    itemId = itemIds[tokenId];\n\n    _burn(tokenId);\n\n    // Clear storage\n    delete itemIds[tokenId];\n    delete itemNames[tokenId];\n    delete itemValues[tokenId];\n\n    emit ItemImported(tokenId, owner, itemId);\n  }\n\n  /**\n   * @notice Get the item entity ID for a token\n   * @param tokenId Token ID\n   * @return itemId The item's MUD entity ID\n   */\n  function getItemId(uint256 tokenId) external view returns (bytes32 itemId) {\n    require(ownerOf(tokenId) != address(0), \"token does not exist\");\n    return itemIds[tokenId];\n  }\n\n  /**\n   * @notice Get item data for a token (for external display)\n   * @param tokenId Token ID\n   * @return name Item name\n   * @return value Item value\n   */\n  function getItemData(uint256 tokenId) external view returns (string memory name, uint256 value) {\n    require(ownerOf(tokenId) != address(0), \"token does not exist\");\n    return (itemNames[tokenId], itemValues[tokenId]);\n  }\n\n  /**\n   * @notice Returns the on-chain contract-level metadata (ERC-7572)\n   * @return URI with base64-encoded JSON metadata\n   */\n  function contractURI() external pure returns (string memory) {\n    string\n      memory json = '{\"name\":\"RAT.FUN PSYCHO OBJECTS\",\"description\":\"Psycho Objects from RAT.FUN. These items can be imported back into the game at rat.fun\",\"external_link\":\"https://rat.fun\"}';\n    return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(json))));\n  }\n\n  /**\n   * @notice Returns the on-chain metadata URI for a token\n   * @param tokenId Token ID\n   * @return URI with base64-encoded JSON metadata\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\n    require(ownerOf(tokenId) != address(0), \"token does not exist\");\n\n    string memory name = itemNames[tokenId];\n    uint256 value = itemValues[tokenId];\n\n    // Generate SVG image\n    string memory svg = _generateSVG(name);\n    string memory svgBase64 = Base64.encode(bytes(svg));\n\n    // Build JSON metadata\n    string memory json = string(\n      abi.encodePacked(\n        '{\"name\":\"',\n        name,\n        '\",\"description\":\"A Psycho Object from RAT.FUN - import back to the game at rat.fun\",\"image\":\"data:image/svg+xml;base64,',\n        svgBase64,\n        '\",\"external_url\":\"https://rat.fun\",\"attributes\":[{\"trait_type\":\"Value\",\"value\":',\n        Strings.toString(value),\n        \"}]}\"\n      )\n    );\n\n    return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(json))));\n  }\n\n  /**\n   * @notice Generates an SVG image for the item\n   * @param name Item name\n   * @return SVG string\n   */\n  function _generateSVG(string memory name) internal pure returns (string memory) {\n    return\n      string(\n        abi.encodePacked(\n          '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\">',\n          '<rect width=\"400\" height=\"400\" fill=\"#000\"/>',\n          '<text x=\"200\" y=\"200\" text-anchor=\"middle\" dominant-baseline=\"middle\" fill=\"#fff\" font-family=\"serif\" font-size=\"24\">',\n          name,\n          \"</text>\",\n          \"</svg>\"\n        )\n      );\n  }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {ERC721Utils} from \"./utils/ERC721Utils.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if:\n     * - `spender` does not have approval from `owner` for `tokenId`.\n     * - `spender` does not have approval to manage all of `owner`'s assets.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {IERC721Enumerable} from \"./IERC721Enumerable.sol\";\nimport {IERC165} from \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the ERC that adds enumerability\n * of all the token ids in the contract as well as all token ids owned by each account.\n *\n * CAUTION: {ERC721} extensions that implement custom `balanceOf` logic, such as {ERC721Consecutive},\n * interfere with enumerability and should not be used together with {ERC721Enumerable}.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;\n    mapping(uint256 tokenId => uint256) private _ownedTokensIndex;\n\n    uint256[] private _allTokens;\n    mapping(uint256 tokenId => uint256) private _allTokensIndex;\n\n    /**\n     * @dev An `owner`'s token query was out of bounds for `index`.\n     *\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\n     */\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n\n    /**\n     * @dev Batch mint is not allowed.\n     */\n    error ERC721EnumerableForbiddenBatchMint();\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC721Enumerable\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return _ownedTokens[owner][index];\n    }\n\n    /// @inheritdoc IERC721Enumerable\n    function totalSupply() public view virtual returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /// @inheritdoc IERC721Enumerable\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return _allTokens[index];\n    }\n\n    /// @inheritdoc ERC721\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        return previousOwner;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = balanceOf(to) - 1;\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        mapping(uint256 index => uint256) storage _ownedTokensByOwner = _ownedTokens[from];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokensByOwner[lastTokenIndex];\n\n            _ownedTokensByOwner[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokensByOwner[lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\n     */\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/Base64.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Base64.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     * See sections 4 and 5 of https://datatracker.ietf.org/doc/html/rfc4648\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    string internal constant _TABLE_URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE, true);\n    }\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64Url `string` representation.\n     * Output is not padded with `=` as specified in https://www.rfc-editor.org/rfc/rfc4648[rfc4648].\n     */\n    function encodeURL(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE_URL, false);\n    }\n\n    /**\n     * @dev Internal table-agnostic conversion\n     */\n    function _encode(bytes memory data, string memory table, bool withPadding) private pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // If padding is enabled, the final length should be `bytes` data length divided by 3 rounded up and then\n        // multiplied by 4 so that it leaves room for padding the last chunk\n        // - `data.length + 2`  -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // - `4 *`              -> 4 characters for each chunk\n        // This is equivalent to: 4 * Math.ceil(data.length / 3)\n        //\n        // If padding is disabled, the final length should be `bytes` data length multiplied by 4/3 rounded up as\n        // opposed to when padding is required to fill the last chunk.\n        // - `4 * data.length`  -> 4 characters for each chunk\n        // - ` + 2`             -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // This is equivalent to: Math.ceil((4 * data.length) / 3)\n        uint256 resultLength = withPadding ? 4 * ((data.length + 2) / 3) : (4 * data.length + 2) / 3;\n\n        string memory result = new string(resultLength);\n\n        assembly (\"memory-safe\") {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {} {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            if withPadding {\n                // When data `bytes` is not exactly 3 bytes long\n                // it is padded with `=` characters at the end\n                switch mod(mload(data), 3)\n                case 1 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                    mstore8(sub(resultPtr, 2), 0x3d)\n                }\n                case 2 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"},"node_modules/@latticexyz/store/src/StoreSwitch.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { IStore } from \"./IStore.sol\";\nimport { EncodedLengths } from \"../src/EncodedLengths.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { StoreCore } from \"./StoreCore.sol\";\nimport { Schema } from \"./Schema.sol\";\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { EncodedLengths } from \"./EncodedLengths.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n/**\n * @title StoreSwitch Library\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This library serves as an interface switch to interact with the store,\n *         either by directing calls to itself or to a designated external store.\n * @dev The primary purpose is to abstract the storage details, such that the\n *      calling function doesn't need to know if it's interacting with its own\n *      storage or with an external contract's storage.\n */\nlibrary StoreSwitch {\n  /// @dev Internal constant representing the storage slot used by the library.\n  bytes32 private constant STORAGE_SLOT = keccak256(\"mud.store.storage.StoreSwitch\");\n\n  /**\n   * @dev Represents the layout of the storage slot (currently just the address)\n   */\n  struct StorageSlotLayout {\n    address storeAddress; // Address of the external store (or self).\n  }\n\n  /**\n   * @notice Gets the storage layout.\n   * @return layout The current storage layout.\n   */\n  function _layout() private pure returns (StorageSlotLayout storage layout) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly {\n      layout.slot := slot\n    }\n  }\n\n  /**\n   * @notice Fetch the store address to be used for data operations.\n   * If _storeAddress is zero, it means that it's uninitialized and\n   * therefore it's the default (msg.sender).\n   * @return Address of the store, or `msg.sender` if uninitialized.\n   */\n  function getStoreAddress() internal view returns (address) {\n    address _storeAddress = _layout().storeAddress;\n    if (_storeAddress == address(0)) {\n      return msg.sender;\n    } else {\n      return _storeAddress;\n    }\n  }\n\n  /**\n   * @notice Set the store address for subsequent operations.\n   * @dev If it stays uninitialized, StoreSwitch falls back to calling store methods on msg.sender.\n   * @param _storeAddress The address of the external store contract.\n   */\n  function setStoreAddress(address _storeAddress) internal {\n    _layout().storeAddress = _storeAddress;\n  }\n\n  /**\n   * @notice Register a store hook for a particular table.\n   * @param tableId Unique identifier of the table.\n   * @param hookAddress Address of the hook contract.\n   * @param enabledHooksBitmap Bitmap representing the hooks which this contract overrides.\n   */\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.registerStoreHook(tableId, hookAddress, enabledHooksBitmap);\n    } else {\n      IStore(_storeAddress).registerStoreHook(tableId, hookAddress, enabledHooksBitmap);\n    }\n  }\n\n  /**\n   * @notice Unregister a previously registered store hook.\n   * @param tableId Unique identifier of the table.\n   * @param hookAddress Address of the hook contract to be unregistered.\n   */\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.unregisterStoreHook(tableId, hookAddress);\n    } else {\n      IStore(_storeAddress).unregisterStoreHook(tableId, hookAddress);\n    }\n  }\n\n  /**\n   * @dev Fetches the field layout for a specified table.\n   * @param tableId The ID of the table for which to retrieve the field layout.\n   * @return fieldLayout The layout of the fields in the specified table.\n   */\n  function getFieldLayout(ResourceId tableId) internal view returns (FieldLayout fieldLayout) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      fieldLayout = StoreCore.getFieldLayout(tableId);\n    } else {\n      fieldLayout = IStore(_storeAddress).getFieldLayout(tableId);\n    }\n  }\n\n  /**\n   * @dev Retrieves the value schema for a specified table.\n   * @param tableId The ID of the table for which to retrieve the value schema.\n   * @return valueSchema The schema for values in the specified table.\n   */\n  function getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      valueSchema = StoreCore.getValueSchema(tableId);\n    } else {\n      valueSchema = IStore(_storeAddress).getValueSchema(tableId);\n    }\n  }\n\n  /**\n   * @dev Retrieves the key schema for a specified table.\n   * @param tableId The ID of the table for which to retrieve the key schema.\n   * @return keySchema The schema for keys in the specified table.\n   */\n  function getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      keySchema = StoreCore.getKeySchema(tableId);\n    } else {\n      keySchema = IStore(_storeAddress).getKeySchema(tableId);\n    }\n  }\n\n  /**\n   * @dev Registers a table with specified configurations.\n   * @param tableId The ID of the table to register.\n   * @param fieldLayout The layout of the fields for the table.\n   * @param keySchema The schema for keys in the table.\n   * @param valueSchema The schema for values in the table.\n   * @param keyNames Names of keys in the table.\n   * @param fieldNames Names of fields in the table.\n   */\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] memory keyNames,\n    string[] memory fieldNames\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.registerTable(tableId, fieldLayout, keySchema, valueSchema, keyNames, fieldNames);\n    } else {\n      IStore(_storeAddress).registerTable(tableId, fieldLayout, keySchema, valueSchema, keyNames, fieldNames);\n    }\n  }\n\n  /**\n   * @dev Sets a record in the store.\n   * @param tableId The table's ID.\n   * @param keyTuple Array of key values.\n   * @param staticData Fixed-length fields data.\n   * @param encodedLengths Encoded lengths for dynamic data.\n   * @param dynamicData Dynamic-length fields data.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    EncodedLengths encodedLengths,\n    bytes memory dynamicData\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n    } else {\n      IStore(_storeAddress).setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n    }\n  }\n\n  /**\n   * @dev Splices the static (fixed length) data for a given table ID and key tuple, starting at a specific point.\n   * @param tableId The ID of the resource table.\n   * @param keyTuple An array of bytes32 keys identifying the data record.\n   * @param start The position to begin splicing.\n   * @param data The data to splice into the record.\n   */\n  function spliceStaticData(ResourceId tableId, bytes32[] memory keyTuple, uint48 start, bytes memory data) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.spliceStaticData(tableId, keyTuple, start, data);\n    } else {\n      IStore(_storeAddress).spliceStaticData(tableId, keyTuple, start, data);\n    }\n  }\n\n  /**\n   * @dev Splices the dynamic data for a given table ID, key tuple, and dynamic field index.\n   * @param tableId The ID of the resource table.\n   * @param keyTuple An array of bytes32 keys identifying the data record.\n   * @param dynamicFieldIndex The index of the dynamic field to splice.\n   * @param startWithinField The position within the dynamic field to start splicing.\n   * @param deleteCount The number of bytes to delete starting from the splice point.\n   * @param data The data to splice into the dynamic field.\n   */\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes memory data\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.spliceDynamicData(tableId, keyTuple, dynamicFieldIndex, startWithinField, deleteCount, data);\n    } else {\n      IStore(_storeAddress).spliceDynamicData(\n        tableId,\n        keyTuple,\n        dynamicFieldIndex,\n        startWithinField,\n        deleteCount,\n        data\n      );\n    }\n  }\n\n  /**\n   * @dev Sets the data for a specific field in a record identified by table ID and key tuple.\n   * @param tableId The ID of the resource table.\n   * @param keyTuple An array of bytes32 keys identifying the data record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the field.\n   */\n  function setField(ResourceId tableId, bytes32[] memory keyTuple, uint8 fieldIndex, bytes memory data) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setField(tableId, keyTuple, fieldIndex, data);\n    } else {\n      IStore(_storeAddress).setField(tableId, keyTuple, fieldIndex, data);\n    }\n  }\n\n  /**\n   * @dev Sets the data for a specific field in a record, considering a specific field layout.\n   * @param tableId The ID of the resource table.\n   * @param keyTuple An array of bytes32 keys identifying the data record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the field.\n   * @param fieldLayout The layout structure of the field.\n   */\n  function setField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    } else {\n      IStore(_storeAddress).setField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    }\n  }\n\n  /**\n   * @dev Sets the data for a specific static (fixed length) field in a record, considering a specific field layout.\n   * @param tableId The ID of the resource table.\n   * @param keyTuple An array of bytes32 keys identifying the data record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the field.\n   * @param fieldLayout The layout structure of the field.\n   */\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    } else {\n      IStore(_storeAddress).setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    }\n  }\n\n  /**\n   * @dev Sets the value of a specific dynamic (variable-length) field in a record.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to set.\n   * @param data The data to set for the field.\n   */\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory data\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setDynamicField(tableId, keyTuple, dynamicFieldIndex, data);\n    } else {\n      IStore(_storeAddress).setDynamicField(tableId, keyTuple, dynamicFieldIndex, data);\n    }\n  }\n\n  /**\n   * @dev Appends data to a specific dynamic (variable length) field of a record.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field.\n   * @param dataToPush The data to append to the field.\n   */\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory dataToPush\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.pushToDynamicField(tableId, keyTuple, dynamicFieldIndex, dataToPush);\n    } else {\n      IStore(_storeAddress).pushToDynamicField(tableId, keyTuple, dynamicFieldIndex, dataToPush);\n    }\n  }\n\n  /**\n   * @dev Removes data from the end of a specific dynamic (variable length) field of a record.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field.\n   * @param byteLengthToPop The number of bytes to remove from the end of the field.\n   */\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.popFromDynamicField(tableId, keyTuple, dynamicFieldIndex, byteLengthToPop);\n    } else {\n      IStore(_storeAddress).popFromDynamicField(tableId, keyTuple, dynamicFieldIndex, byteLengthToPop);\n    }\n  }\n\n  /**\n   * @dev Deletes a record from a table.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.deleteRecord(tableId, keyTuple);\n    } else {\n      IStore(_storeAddress).deleteRecord(tableId, keyTuple);\n    }\n  }\n\n  /**\n   * @dev Retrieves a record from a table.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @return staticData The static data of the record.\n   * @return encodedLengths Encoded lengths of dynamic data.\n   * @return dynamicData The dynamic data of the record.\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple\n  ) internal view returns (bytes memory, EncodedLengths, bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getRecord(tableId, keyTuple);\n    } else {\n      return IStore(_storeAddress).getRecord(tableId, keyTuple);\n    }\n  }\n\n  /**\n   * @dev Retrieves a record from a table with a specific layout.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldLayout The layout of the fields in the record.\n   * @return staticData The static data of the record.\n   * @return encodedLengths Encoded lengths of dynamic data.\n   * @return dynamicData The dynamic data of the record.\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory, EncodedLengths, bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getRecord(tableId, keyTuple, fieldLayout);\n    } else {\n      return IStore(_storeAddress).getRecord(tableId, keyTuple, fieldLayout);\n    }\n  }\n\n  /**\n   * @dev Retrieves a specific field from a record.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field to retrieve.\n   * @return Returns the data of the specified field.\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) internal view returns (bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getField(tableId, keyTuple, fieldIndex);\n    } else {\n      return IStore(_storeAddress).getField(tableId, keyTuple, fieldIndex);\n    }\n  }\n\n  /**\n   * @dev Retrieves a specific field from a record with a given layout.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field to retrieve.\n   * @param fieldLayout The layout of the field being retrieved.\n   * @return Returns the data of the specified field.\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getField(tableId, keyTuple, fieldIndex, fieldLayout);\n    } else {\n      return IStore(_storeAddress).getField(tableId, keyTuple, fieldIndex, fieldLayout);\n    }\n  }\n\n  /**\n   * @dev Retrieves a specific static (fixed length) field from a record with a given layout.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the static field to retrieve.\n   * @param fieldLayout The layout of the static field being retrieved.\n   * @return Returns the data of the specified static field.\n   */\n  function getStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes32) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getStaticField(tableId, keyTuple, fieldIndex, fieldLayout);\n    } else {\n      return IStore(_storeAddress).getStaticField(tableId, keyTuple, fieldIndex, fieldLayout);\n    }\n  }\n\n  /**\n   * @dev Retrieves a specific dynamic (variable length) field from a record.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to retrieve.\n   * @return Returns the data of the specified dynamic field.\n   */\n  function getDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal view returns (bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getDynamicField(tableId, keyTuple, dynamicFieldIndex);\n    } else {\n      return IStore(_storeAddress).getDynamicField(tableId, keyTuple, dynamicFieldIndex);\n    }\n  }\n\n  /**\n   * @dev Retrieves the length of a specific field in a record.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field whose length is to be retrieved.\n   * @return Returns the length of the specified field.\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) internal view returns (uint256) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getFieldLength(tableId, keyTuple, fieldIndex);\n    } else {\n      return IStore(_storeAddress).getFieldLength(tableId, keyTuple, fieldIndex);\n    }\n  }\n\n  /**\n   * @dev Retrieves the length of a specific field in a record with a given layout.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field whose length is to be retrieved.\n   * @param fieldLayout The layout of the field whose length is to be retrieved.\n   * @return Returns the length of the specified field.\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (uint256) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getFieldLength(tableId, keyTuple, fieldIndex, fieldLayout);\n    } else {\n      return IStore(_storeAddress).getFieldLength(tableId, keyTuple, fieldIndex, fieldLayout);\n    }\n  }\n\n  /**\n   * @dev Retrieves the length of a specific dynamic (variable length) field in a record.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field whose length is to be retrieved.\n   * @return Returns the length of the specified dynamic field.\n   */\n  function getDynamicFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal view returns (uint256) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getDynamicFieldLength(tableId, keyTuple, dynamicFieldIndex);\n    } else {\n      return IStore(_storeAddress).getDynamicFieldLength(tableId, keyTuple, dynamicFieldIndex);\n    }\n  }\n\n  /**\n   * @dev Retrieves a slice of a dynamic (variable length) field from a record.\n   * @param tableId The ID of the table to which the record belongs.\n   * @param keyTuple An array representing the key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field from which to get the slice.\n   * @param start The starting index of the slice.\n   * @param end The ending index of the slice.\n   * @return Returns the sliced data from the specified dynamic field.\n   */\n  function getDynamicFieldSlice(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 start,\n    uint256 end\n  ) internal view returns (bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getDynamicFieldSlice(tableId, keyTuple, dynamicFieldIndex, start, end);\n    } else {\n      return IStore(_storeAddress).getDynamicFieldSlice(tableId, keyTuple, dynamicFieldIndex, start, end);\n    }\n  }\n}\n"},"node_modules/@latticexyz/world/src/codegen/interfaces/IBaseWorld.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\nimport { IStore } from \"@latticexyz/store/src/IStore.sol\";\nimport { IWorldKernel } from \"../../IWorldKernel.sol\";\nimport { IRegistrationSystem } from \"./IRegistrationSystem.sol\";\nimport { IAccessManagementSystem } from \"./IAccessManagementSystem.sol\";\nimport { IBalanceTransferSystem } from \"./IBalanceTransferSystem.sol\";\nimport { IBatchCallSystem } from \"./IBatchCallSystem.sol\";\nimport { IModuleInstallationSystem } from \"./IModuleInstallationSystem.sol\";\nimport { IWorldRegistrationSystem } from \"./IWorldRegistrationSystem.sol\";\n\n/**\n * @title IBaseWorld\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This interface integrates all systems and associated function selectors\n * that are dynamically registered in the World during deployment.\n * @dev This is an autogenerated file; do not edit manually.\n */\ninterface IBaseWorld is\n  IStore,\n  IWorldKernel,\n  IRegistrationSystem,\n  IAccessManagementSystem,\n  IBalanceTransferSystem,\n  IBatchCallSystem,\n  IModuleInstallationSystem,\n  IWorldRegistrationSystem\n{}\n"},"node_modules/@latticexyz/world/src/codegen/tables/ResourceAccess.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\n// Import store internals\nimport { IStore } from \"@latticexyz/store/src/IStore.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\nimport { StoreCore } from \"@latticexyz/store/src/StoreCore.sol\";\nimport { Bytes } from \"@latticexyz/store/src/Bytes.sol\";\nimport { Memory } from \"@latticexyz/store/src/Memory.sol\";\nimport { SliceLib } from \"@latticexyz/store/src/Slice.sol\";\nimport { EncodeArray } from \"@latticexyz/store/src/tightcoder/EncodeArray.sol\";\nimport { FieldLayout } from \"@latticexyz/store/src/FieldLayout.sol\";\nimport { Schema } from \"@latticexyz/store/src/Schema.sol\";\nimport { EncodedLengths, EncodedLengthsLib } from \"@latticexyz/store/src/EncodedLengths.sol\";\nimport { ResourceId } from \"@latticexyz/store/src/ResourceId.sol\";\n\n// Import user types\nimport { ResourceId } from \"@latticexyz/store/src/ResourceId.sol\";\n\nlibrary ResourceAccess {\n  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: \"world\", name: \"ResourceAccess\", typeId: RESOURCE_TABLE });`\n  ResourceId constant _tableId = ResourceId.wrap(0x7462776f726c640000000000000000005265736f757263654163636573730000);\n\n  FieldLayout constant _fieldLayout =\n    FieldLayout.wrap(0x0001010001000000000000000000000000000000000000000000000000000000);\n\n  // Hex-encoded key schema of (bytes32, address)\n  Schema constant _keySchema = Schema.wrap(0x003402005f610000000000000000000000000000000000000000000000000000);\n  // Hex-encoded value schema of (bool)\n  Schema constant _valueSchema = Schema.wrap(0x0001010060000000000000000000000000000000000000000000000000000000);\n\n  /**\n   * @notice Get the table's key field names.\n   * @return keyNames An array of strings with the names of key fields.\n   */\n  function getKeyNames() internal pure returns (string[] memory keyNames) {\n    keyNames = new string[](2);\n    keyNames[0] = \"resourceId\";\n    keyNames[1] = \"caller\";\n  }\n\n  /**\n   * @notice Get the table's value field names.\n   * @return fieldNames An array of strings with the names of value fields.\n   */\n  function getFieldNames() internal pure returns (string[] memory fieldNames) {\n    fieldNames = new string[](1);\n    fieldNames[0] = \"access\";\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function register() internal {\n    StoreSwitch.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function _register() internal {\n    StoreCore.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Get access.\n   */\n  function getAccess(ResourceId resourceId, address caller) internal view returns (bool access) {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /**\n   * @notice Get access.\n   */\n  function _getAccess(ResourceId resourceId, address caller) internal view returns (bool access) {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /**\n   * @notice Get access.\n   */\n  function get(ResourceId resourceId, address caller) internal view returns (bool access) {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /**\n   * @notice Get access.\n   */\n  function _get(ResourceId resourceId, address caller) internal view returns (bool access) {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /**\n   * @notice Set access.\n   */\n  function setAccess(ResourceId resourceId, address caller, bool access) internal {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((access)), _fieldLayout);\n  }\n\n  /**\n   * @notice Set access.\n   */\n  function _setAccess(ResourceId resourceId, address caller, bool access) internal {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((access)), _fieldLayout);\n  }\n\n  /**\n   * @notice Set access.\n   */\n  function set(ResourceId resourceId, address caller, bool access) internal {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((access)), _fieldLayout);\n  }\n\n  /**\n   * @notice Set access.\n   */\n  function _set(ResourceId resourceId, address caller, bool access) internal {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((access)), _fieldLayout);\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function deleteRecord(ResourceId resourceId, address caller) internal {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    StoreSwitch.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function _deleteRecord(ResourceId resourceId, address caller) internal {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);\n  }\n\n  /**\n   * @notice Tightly pack static (fixed length) data using this table's schema.\n   * @return The static data, encoded into a sequence of bytes.\n   */\n  function encodeStatic(bool access) internal pure returns (bytes memory) {\n    return abi.encodePacked(access);\n  }\n\n  /**\n   * @notice Encode all of a record's fields.\n   * @return The static (fixed length) data, encoded into a sequence of bytes.\n   * @return The lengths of the dynamic fields (packed into a single bytes32 value).\n   * @return The dynamic (variable length) data, encoded into a sequence of bytes.\n   */\n  function encode(bool access) internal pure returns (bytes memory, EncodedLengths, bytes memory) {\n    bytes memory _staticData = encodeStatic(access);\n\n    EncodedLengths _encodedLengths;\n    bytes memory _dynamicData;\n\n    return (_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Encode keys as a bytes32 array using this table's field layout.\n   */\n  function encodeKeyTuple(ResourceId resourceId, address caller) internal pure returns (bytes32[] memory) {\n    bytes32[] memory _keyTuple = new bytes32[](2);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n    _keyTuple[1] = bytes32(uint256(uint160(caller)));\n\n    return _keyTuple;\n  }\n}\n\n/**\n * @notice Cast a value to a bool.\n * @dev Boolean values are encoded as uint8 (1 = true, 0 = false), but Solidity doesn't allow casting between uint8 and bool.\n * @param value The uint8 value to convert.\n * @return result The boolean value.\n */\nfunction _toBool(uint8 value) pure returns (bool result) {\n  assembly {\n    result := value\n  }\n}\n"},"node_modules/@latticexyz/world/src/WorldResourceId.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { Bytes } from \"@latticexyz/store/src/Bytes.sol\";\nimport { ResourceId, ResourceIdInstance, TYPE_BITS } from \"@latticexyz/store/src/ResourceId.sol\";\n\nimport { ROOT_NAMESPACE, ROOT_NAME } from \"./constants.sol\";\nimport { RESOURCE_NAMESPACE, MASK_RESOURCE_NAMESPACE } from \"./worldResourceTypes.sol\";\n\nuint256 constant NAMESPACE_BYTES = 14;\nuint256 constant NAMESPACE_BITS = 14 * 8; // 14 bytes * 8 bits per byte\nuint256 constant NAME_BITS = 16 * 8; // 16 bytes * 8 bits per byte\n\nbytes32 constant NAMESPACE_MASK = bytes32(~bytes14(\"\")) >> (TYPE_BITS);\n\n/**\n * @title WorldResourceIdLib\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice A library for handling World Resource ID encoding and decoding.\n */\nlibrary WorldResourceIdLib {\n  /**\n   * @notice Encode a resource ID.\n   * @param typeId The resource type ID.\n   * @param namespace The namespace of the resource.\n   * @param name The name of the resource.\n   * @return A 32-byte resource ID.\n   */\n  function encode(bytes2 typeId, bytes14 namespace, bytes16 name) internal pure returns (ResourceId) {\n    return\n      ResourceId.wrap(\n        bytes32(typeId) | (bytes32(namespace) >> TYPE_BITS) | (bytes32(name) >> (TYPE_BITS + NAMESPACE_BITS))\n      );\n  }\n\n  /**\n   * @notice Encode a namespace to resource ID.\n   * @param namespace The namespace to be encoded.\n   * @return A 32-byte resource ID with the namespace encoded.\n   */\n  function encodeNamespace(bytes14 namespace) internal pure returns (ResourceId) {\n    return ResourceId.wrap(bytes32(RESOURCE_NAMESPACE) | (bytes32(namespace) >> (TYPE_BITS)));\n  }\n\n  /**\n   * @notice Convert a padded string to a trimmed string.\n   * @param paddedString The input string with potential padding.\n   * @return A string without trailing null ASCII characters.\n   */\n  function toTrimmedString(bytes16 paddedString) internal pure returns (string memory) {\n    uint256 length;\n    for (; length < 16; length++) if (Bytes.getBytes1(paddedString, length) == 0) break;\n    bytes memory packedSelector = abi.encodePacked(paddedString);\n    return string(Bytes.setLength(packedSelector, length));\n  }\n}\n\n/**\n * @title WorldResourceIdInstance\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice A library for handling instances of World Resource IDs.\n */\nlibrary WorldResourceIdInstance {\n  /**\n   * @notice Get the namespace from a resource ID.\n   * @param resourceId The resource ID.\n   * @return A 14-byte namespace.\n   */\n  function getNamespace(ResourceId resourceId) internal pure returns (bytes14) {\n    return bytes14(ResourceId.unwrap(resourceId) << (TYPE_BITS));\n  }\n\n  /**\n   * @notice Get the namespace ID from a resource ID.\n   * @param resourceId The resource ID.\n   * @return A 32-byte namespace resource ID.\n   */\n  function getNamespaceId(ResourceId resourceId) internal pure returns (ResourceId) {\n    return ResourceId.wrap((ResourceId.unwrap(resourceId) & NAMESPACE_MASK) | MASK_RESOURCE_NAMESPACE);\n  }\n\n  /**\n   * @notice Get the name from a resource ID.\n   * @param resourceId The resource ID.\n   * @return A 16-byte name.\n   */\n  function getName(ResourceId resourceId) internal pure returns (bytes16) {\n    return bytes16(ResourceId.unwrap(resourceId) << (TYPE_BITS + NAMESPACE_BITS));\n  }\n\n  /**\n   * @notice Convert a resource ID to a string.\n   * @param resourceId The resource ID.\n   * @return A string representation of the resource ID.\n   */\n  function toString(ResourceId resourceId) internal pure returns (string memory) {\n    bytes2 resourceType = ResourceIdInstance.getType(resourceId);\n    bytes14 resourceNamespace = getNamespace(resourceId);\n    bytes16 resourceName = getName(resourceId);\n    return\n      string(\n        abi.encodePacked(\n          resourceType,\n          \":\",\n          resourceNamespace == ROOT_NAMESPACE ? \"<root>\" : WorldResourceIdLib.toTrimmedString(resourceNamespace),\n          \":\",\n          resourceName == ROOT_NAME ? \"<root>\" : WorldResourceIdLib.toTrimmedString(resourceName)\n        )\n      );\n  }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/utils/ERC721Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../IERC721Receiver.sol\";\nimport {IERC721Errors} from \"../../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Library that provide common ERC-721 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-721[ERC-721].\n *\n * _Available since v5.1._\n */\nlibrary ERC721Utils {\n    /**\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC721Receiver-onERC721Received}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC721Receiver-onERC721Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(operator, from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    // Token rejected\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC721Receiver implementer\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(reason, 0x20), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"},"node_modules/@openzeppelin/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2 + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2 + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"},"node_modules/@latticexyz/store/src/IStore.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { IStoreKernel } from \"./IStoreKernel.sol\";\nimport { IStoreRegistration } from \"./IStoreRegistration.sol\";\n\n/**\n * @title IStore\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n */\ninterface IStore is IStoreKernel, IStoreRegistration {}\n"},"node_modules/@latticexyz/store/src/EncodedLengths.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { BYTE_TO_BITS } from \"./constants.sol\";\nimport { IEncodedLengthsErrors } from \"./IEncodedLengthsErrors.sol\";\n\n/**\n * @title EncodedLengths Type Definition\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Describes how the encoded lengths is structured.\n * - 0x00-0x06 The least significant 7 bytes (uint56) represent the total byte length of dynamic (variable length) data.\n * - 0x07-0xB The next five bytes (uint40) represent the length of the first dynamic field.\n * - 0x0C-0x10 Followed by the length of the second dynamic field\n * - 0x11-0x15 Length of the third dynamic field\n * - 0x16-0x1A Length of fourth dynamic field\n * - 0x1B-0x1F Length of fifth dynamic field\n */\ntype EncodedLengths is bytes32;\n\nusing EncodedLengthsInstance for EncodedLengths global;\n\n// Constants for encoded lengths handling:\n\n// Number of bits for the 7-byte accumulator\nuint256 constant ACC_BITS = 7 * BYTE_TO_BITS;\n// Number of bits for the 5-byte sections\nuint256 constant VAL_BITS = 5 * BYTE_TO_BITS;\n// Maximum value of a 5-byte section\nuint256 constant MAX_VAL = type(uint40).max;\n\n/**\n * @title EncodedLengths Library\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Static functions for handling EncodedLengths type.\n * @dev Provides utility functions to pack values into EncodedLengths.\n * The caller must ensure that the value arguments are <= MAX_VAL.\n */\nlibrary EncodedLengthsLib {\n  /**\n   * @notice Packs a single value into EncodedLengths.\n   * @dev Encodes the given value 'a' into the structure of EncodedLengths. The encoded lengths's accumulator\n   * will be set to 'a', and the first value slot of the EncodedLengths will also be set to 'a'.\n   * @param a The length of the first dynamic field's data.\n   * @return The resulting EncodedLengths containing the encoded value.\n   */\n  function pack(uint256 a) internal pure returns (EncodedLengths) {\n    uint256 encodedLengths;\n    unchecked {\n      encodedLengths = a;\n      encodedLengths |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n    }\n    return EncodedLengths.wrap(bytes32(encodedLengths));\n  }\n\n  /**\n   * @notice Packs two values into EncodedLengths.\n   * @dev Encodes the given values 'a'-'b' into the structure of EncodedLengths.\n   * @param a The length of the first dynamic field's data.\n   * @param b The length of the second dynamic field's data.\n   * @return The resulting EncodedLengths containing the encoded values.\n   */\n  function pack(uint256 a, uint256 b) internal pure returns (EncodedLengths) {\n    uint256 encodedLengths;\n    unchecked {\n      encodedLengths = a + b;\n      encodedLengths |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      encodedLengths |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n    }\n    return EncodedLengths.wrap(bytes32(encodedLengths));\n  }\n\n  /**\n   * @notice Packs three values into EncodedLengths.\n   * @dev Encodes the given values 'a'-'c' into the structure of EncodedLengths.\n   * @param a The length of the first dynamic field's data.\n   * @param b The length of the second dynamic field's data.\n   * @param c The length of the third dynamic field's data.\n   * @return The resulting EncodedLengths containing the encoded values.\n   */\n  function pack(uint256 a, uint256 b, uint256 c) internal pure returns (EncodedLengths) {\n    uint256 encodedLengths;\n    unchecked {\n      encodedLengths = a + b + c;\n      encodedLengths |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      encodedLengths |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      encodedLengths |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n    }\n    return EncodedLengths.wrap(bytes32(encodedLengths));\n  }\n\n  /**\n   * @notice Packs four values into EncodedLengths.\n   * @dev Encodes the given values 'a'-'d' into the structure of EncodedLengths.\n   * @param a The length of the first dynamic field's data.\n   * @param b The length of the second dynamic field's data.\n   * @param c The length of the third dynamic field's data.\n   * @param d The length of the fourth dynamic field's data.\n   * @return The resulting EncodedLengths containing the encoded values.\n   */\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (EncodedLengths) {\n    uint256 encodedLengths;\n    unchecked {\n      encodedLengths = a + b + c + d;\n      encodedLengths |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      encodedLengths |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      encodedLengths |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      encodedLengths |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n    }\n    return EncodedLengths.wrap(bytes32(encodedLengths));\n  }\n\n  /**\n   * @notice Packs five values into EncodedLengths.\n   * @dev Encodes the given values 'a'-'e' into the structure of EncodedLengths.\n   * @param a The length of the first dynamic field's data.\n   * @param b The length of the second dynamic field's data.\n   * @param c The length of the third dynamic field's data.\n   * @param d The length of the fourth dynamic field's data.\n   * @param e The length of the fifth dynamic field's data.\n   * @return The resulting EncodedLengths containing the encoded values.\n   */\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e) internal pure returns (EncodedLengths) {\n    uint256 encodedLengths;\n    unchecked {\n      encodedLengths = a + b + c + d + e;\n      encodedLengths |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      encodedLengths |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      encodedLengths |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      encodedLengths |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n      encodedLengths |= (uint256(e) << (ACC_BITS + VAL_BITS * 4));\n    }\n    return EncodedLengths.wrap(bytes32(encodedLengths));\n  }\n}\n\n/**\n * @title EncodedLengths Instance Library\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Instance functions for handling EncodedLengths.\n * @dev Offers decoding, extracting, and setting functionalities for EncodedLengths.\n */\nlibrary EncodedLengthsInstance {\n  /**\n   * @notice Decode the accumulated counter from EncodedLengths.\n   * @dev Extracts the right-most 7 bytes of EncodedLengths.\n   * @param encodedLengths The encoded lengths to decode.\n   * @return The accumulated value from the EncodedLengths.\n   */\n  function total(EncodedLengths encodedLengths) internal pure returns (uint256) {\n    return uint56(uint256(EncodedLengths.unwrap(encodedLengths)));\n  }\n\n  /**\n   * @notice Decode the dynamic field size at a specific index from EncodedLengths.\n   * @dev Extracts value right-to-left, with 5 bytes per dynamic field after the right-most 7 bytes.\n   * @param encodedLengths The encoded lengths to decode.\n   * @param index The index to retrieve.\n   * @return The value at the given index from the EncodedLengths.\n   */\n  function atIndex(EncodedLengths encodedLengths, uint8 index) internal pure returns (uint256) {\n    unchecked {\n      return uint40(uint256(EncodedLengths.unwrap(encodedLengths) >> (ACC_BITS + VAL_BITS * index)));\n    }\n  }\n\n  /**\n   * @notice Set a counter at a specific index in EncodedLengths.\n   * @dev Updates a value at a specific index and updates the accumulator field.\n   * @param encodedLengths The encoded lengths to modify.\n   * @param index The index to set.\n   * @param newValueAtIndex The new value to set at the given index.\n   * @return The modified EncodedLengths.\n   */\n  function setAtIndex(\n    EncodedLengths encodedLengths,\n    uint8 index,\n    uint256 newValueAtIndex\n  ) internal pure returns (EncodedLengths) {\n    if (newValueAtIndex > MAX_VAL) {\n      revert IEncodedLengthsErrors.EncodedLengths_InvalidLength(newValueAtIndex);\n    }\n\n    uint256 rawEncodedLengths = uint256(EncodedLengths.unwrap(encodedLengths));\n\n    // Get current lengths (total and at index)\n    uint256 accumulator = total(encodedLengths);\n    uint256 currentValueAtIndex = atIndex(encodedLengths, index);\n\n    // Compute the difference and update the total value\n    unchecked {\n      if (newValueAtIndex >= currentValueAtIndex) {\n        accumulator += newValueAtIndex - currentValueAtIndex;\n      } else {\n        accumulator -= currentValueAtIndex - newValueAtIndex;\n      }\n    }\n\n    // Set the new accumulated value and value at index\n    // (7 bytes total length, 5 bytes per dynamic field)\n    uint256 offset;\n    unchecked {\n      offset = ACC_BITS + VAL_BITS * index;\n    }\n    // Bitmask with 1s at the 5 bytes that form the value slot at the given index\n    uint256 mask = uint256(type(uint40).max) << offset;\n\n    // First set the last 7 bytes to 0, then set them to the new length\n    rawEncodedLengths = (rawEncodedLengths & ~uint256(type(uint56).max)) | accumulator;\n\n    // Zero out the value slot at the given index, then set the new value\n    rawEncodedLengths = (rawEncodedLengths & ~mask) | ((newValueAtIndex << offset) & mask);\n\n    return EncodedLengths.wrap(bytes32(rawEncodedLengths));\n  }\n\n  /**\n   * @notice Unwrap EncodedLengths to its raw bytes32 representation.\n   * @param encodedLengths The encoded lengths to unwrap.\n   * @return The raw bytes32 value of the EncodedLengths.\n   */\n  function unwrap(EncodedLengths encodedLengths) internal pure returns (bytes32) {\n    return EncodedLengths.unwrap(encodedLengths);\n  }\n}\n"},"node_modules/@latticexyz/store/src/IStoreHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { IERC165 } from \"./IERC165.sol\";\nimport { EncodedLengths } from \"./EncodedLengths.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n/**\n * @title IStoreHook\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n */\ninterface IStoreHook is IERC165 {\n  /// @notice Error emitted when a function is not implemented.\n  error StoreHook_NotImplemented();\n\n  /**\n   * @notice Called before setting a record in the store.\n   * @param tableId The ID of the table where the record is to be set.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   * @param fieldLayout The layout of the field, see FieldLayout.sol.\n   */\n  function onBeforeSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    EncodedLengths encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  /**\n   * @notice Called after setting a record in the store.\n   * @param tableId The ID of the table where the record was set.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   * @param fieldLayout The layout of the field, see FieldLayout.sol.\n   */\n  function onAfterSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    EncodedLengths encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  /**\n   * @notice Called before splicing static data in the store.\n   * @dev Splice operations in static data always overwrite data starting at the start position,\n   * so the total length of the data remains the same and no data is shifted.\n   * @param tableId The ID of the table where the data is to be spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start byte position for splicing.\n   * @param data The data to be written to the static data of the record at the start byte.\n   */\n  function onBeforeSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  /**\n   * @notice Called after splicing static data in the store.\n   * @dev Splice operations in static data always overwrite data starting at the start position,\n   * so the total length of the data remains the same and no data is shifted.\n   * @param tableId The ID of the table where the data was spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start byte position for splicing.\n   * @param data The data written to the static data of the record at the start byte.\n   */\n  function onAfterSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  /**\n   * @notice Called before splicing dynamic data in the store.\n   * @dev Splice operations in dynamic data always reach the end of the dynamic data\n   * to avoid shifting data after the inserted or deleted data.\n   * @param tableId The ID of the table where the data is to be spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field.\n   * @param startWithinField The start byte position within the field for splicing.\n   * @param deleteCount The number of bytes to delete in the dynamic data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param data The data to be inserted into the dynamic data of the record at the start byte.\n   */\n  function onBeforeSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    EncodedLengths encodedLengths,\n    bytes memory data\n  ) external;\n\n  /**\n   * @notice Called after splicing dynamic data in the store.\n   * @dev Splice operations in dynamic data always reach the end of the dynamic data\n   * to avoid shifting data after the inserted or deleted data.\n   * @param tableId The ID of the table where the data was spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field.\n   * @param startWithinField The start byte position within the field for splicing.\n   * @param deleteCount The number of bytes deleted in the dynamic data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param data The data inserted into the dynamic data of the record at the start byte.\n   */\n  function onAfterSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    EncodedLengths encodedLengths,\n    bytes memory data\n  ) external;\n\n  /**\n   * @notice Called before deleting a record from the store.\n   * @param tableId The ID of the table where the record is to be deleted.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldLayout The layout of the field, see FieldLayout.sol.\n   */\n  function onBeforeDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n\n  /**\n   * @notice Called after deleting a record from the store.\n   * @param tableId The ID of the table where the record was deleted.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldLayout The layout of the field, see FieldLayout.sol.\n   */\n  function onAfterDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n}\n"},"node_modules/@latticexyz/store/src/StoreCore.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { STORE_VERSION } from \"./version.sol\";\nimport { Bytes } from \"./Bytes.sol\";\nimport { Storage } from \"./Storage.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { FieldLayout, FieldLayoutLib } from \"./FieldLayout.sol\";\nimport { Schema, SchemaLib } from \"./Schema.sol\";\nimport { EncodedLengths } from \"./EncodedLengths.sol\";\nimport { Slice, SliceLib } from \"./Slice.sol\";\nimport { Tables, ResourceIds, StoreHooks } from \"./codegen/index.sol\";\nimport { IStoreErrors } from \"./IStoreErrors.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { StoreSwitch } from \"./StoreSwitch.sol\";\nimport { Hook, HookLib } from \"./Hook.sol\";\nimport { BEFORE_SET_RECORD, AFTER_SET_RECORD, BEFORE_SPLICE_STATIC_DATA, AFTER_SPLICE_STATIC_DATA, BEFORE_SPLICE_DYNAMIC_DATA, AFTER_SPLICE_DYNAMIC_DATA, BEFORE_DELETE_RECORD, AFTER_DELETE_RECORD } from \"./storeHookTypes.sol\";\nimport { ResourceId, ResourceIdLib } from \"./ResourceId.sol\";\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\nimport { IStoreEvents } from \"./IStoreEvents.sol\";\n\n/**\n * @title StoreCore Library\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This library includes implementations for all IStore methods and events related to the store actions.\n */\nlibrary StoreCore {\n  /**\n   * @notice Initialize the store address in StoreSwitch.\n   * @dev Consumers must call this function in their constructor.\n   * StoreSwitch uses the storeAddress to decide where to write data to.\n   * If StoreSwitch is called in the context of a Store contract (storeAddress == address(this)),\n   * StoreSwitch uses internal methods to write data instead of external calls.\n   */\n  function initialize() internal {\n    StoreSwitch.setStoreAddress(address(this));\n  }\n\n  /**\n   * @notice Register Store protocol's internal tables in the store.\n   * @dev Consumers must call this function in their constructor before setting\n   * any table data to allow indexers to decode table events.\n   */\n  function registerInternalTables() internal {\n    // Because `registerTable` writes to both `Tables` and `ResourceIds`, we can't use it\n    // directly here without creating a race condition, where we'd write to one or the other\n    // before they exist (depending on the order of registration).\n    //\n    // Instead, we'll register them manually, writing everything to the `Tables` table first,\n    // then the `ResourceIds` table. The logic here ought to be kept in sync with the internals\n    // of the `registerTable` function below.\n    if (ResourceIds._getExists(Tables._tableId)) {\n      revert IStoreErrors.Store_TableAlreadyExists(Tables._tableId, string(abi.encodePacked(Tables._tableId)));\n    }\n    if (ResourceIds._getExists(ResourceIds._tableId)) {\n      revert IStoreErrors.Store_TableAlreadyExists(\n        ResourceIds._tableId,\n        string(abi.encodePacked(ResourceIds._tableId))\n      );\n    }\n    Tables._set(\n      Tables._tableId,\n      Tables._fieldLayout,\n      Tables._keySchema,\n      Tables._valueSchema,\n      abi.encode(Tables.getKeyNames()),\n      abi.encode(Tables.getFieldNames())\n    );\n    Tables._set(\n      ResourceIds._tableId,\n      ResourceIds._fieldLayout,\n      ResourceIds._keySchema,\n      ResourceIds._valueSchema,\n      abi.encode(ResourceIds.getKeyNames()),\n      abi.encode(ResourceIds.getFieldNames())\n    );\n    ResourceIds._setExists(Tables._tableId, true);\n    ResourceIds._setExists(ResourceIds._tableId, true);\n\n    // Now we can register the rest of the core tables as regular tables.\n    StoreHooks.register();\n  }\n\n  /************************************************************************\n   *\n   *    SCHEMA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Get the field layout for the given table ID.\n   * @param tableId The ID of the table for which to get the field layout.\n   * @return The field layout for the given table ID.\n   */\n  function getFieldLayout(ResourceId tableId) internal view returns (FieldLayout) {\n    // Explicit check for the Tables table to solve the bootstraping issue\n    // of the Tables table not having a field layout before it is registered\n    // since the field layout is stored in the Tables table.\n    if (ResourceId.unwrap(tableId) == ResourceId.unwrap(Tables._tableId)) {\n      return Tables._fieldLayout;\n    }\n    return\n      FieldLayout.wrap(\n        Storage.loadField({\n          storagePointer: StoreCoreInternal._getStaticDataLocation(Tables._tableId, ResourceId.unwrap(tableId)),\n          length: 32,\n          offset: 0\n        })\n      );\n  }\n\n  /**\n   * @notice Get the key schema for the given table ID.\n   * @dev Reverts if the table ID is not registered.\n   * @param tableId The ID of the table for which to get the key schema.\n   * @return keySchema The key schema for the given table ID.\n   */\n  function getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    keySchema = Tables._getKeySchema(tableId);\n    // key schemas can be empty for singleton tables, so we can't depend on key schema for table check\n    if (!ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * @notice Get the value schema for the given table ID.\n   * @dev Reverts if the table ID is not registered.\n   * @param tableId The ID of the table for which to get the value schema.\n   * @return valueSchema The value schema for the given table ID.\n   */\n  function getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    valueSchema = Tables._getValueSchema(tableId);\n    if (valueSchema.isEmpty()) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * @notice Register a new table with the given configuration.\n   * @dev This method reverts if\n   * - The table ID is not of type RESOURCE_TABLE or RESOURCE_OFFCHAIN_TABLE.\n   * - The field layout is invalid.\n   * - The key schema is invalid.\n   * - The value schema is invalid.\n   * - The number of key names does not match the number of key schema types.\n   * - The number of field names does not match the number of field layout fields.\n   * @param tableId The ID of the table to register.\n   * @param fieldLayout The field layout of the table.\n   * @param keySchema The key schema of the table.\n   * @param valueSchema The value schema of the table.\n   * @param keyNames The names of the keys in the table.\n   * @param fieldNames The names of the fields in the table.\n   */\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] memory keyNames,\n    string[] memory fieldNames\n  ) internal {\n    // Verify the table ID is of type RESOURCE_TABLE or RESOURCE_OFFCHAIN_TABLE\n    if (tableId.getType() != RESOURCE_TABLE && tableId.getType() != RESOURCE_OFFCHAIN_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Verify the field layout is valid\n    fieldLayout.validate();\n\n    // Verify the schema is valid\n    keySchema.validate({ allowEmpty: true });\n    valueSchema.validate({ allowEmpty: false });\n\n    // Verify the number of key names matches the number of key schema types\n    if (keyNames.length != keySchema.numFields()) {\n      revert IStoreErrors.Store_InvalidKeyNamesLength(keySchema.numFields(), keyNames.length);\n    }\n\n    // Verify the number of value names\n    if (fieldNames.length != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidFieldNamesLength(fieldLayout.numFields(), fieldNames.length);\n    }\n\n    // Verify the number of value schema types\n    if (valueSchema.numFields() != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidValueSchemaLength(fieldLayout.numFields(), valueSchema.numFields());\n    }\n    if (valueSchema.numStaticFields() != fieldLayout.numStaticFields()) {\n      revert IStoreErrors.Store_InvalidValueSchemaStaticLength(\n        fieldLayout.numStaticFields(),\n        valueSchema.numStaticFields()\n      );\n    }\n    if (valueSchema.numDynamicFields() != fieldLayout.numDynamicFields()) {\n      revert IStoreErrors.Store_InvalidValueSchemaDynamicLength(\n        fieldLayout.numDynamicFields(),\n        valueSchema.numDynamicFields()\n      );\n    }\n\n    // Verify that static field lengths are consistent between Schema and FieldLayout\n    for (uint256 i; i < fieldLayout.numStaticFields(); i++) {\n      if (fieldLayout.atIndex(i) != valueSchema.atIndex(i).getStaticByteLength()) {\n        revert IStoreErrors.Store_InvalidStaticDataLength(\n          fieldLayout.atIndex(i),\n          valueSchema.atIndex(i).getStaticByteLength()\n        );\n      }\n    }\n\n    // Verify that there is no table or offchain table with the same name\n    ResourceId onchainTableId = ResourceIdLib.encode(RESOURCE_TABLE, tableId.getResourceName());\n    ResourceId offchainTableId = ResourceIdLib.encode(RESOURCE_OFFCHAIN_TABLE, tableId.getResourceName());\n    if (ResourceIds._getExists(onchainTableId) || ResourceIds._getExists(offchainTableId)) {\n      revert IStoreErrors.Store_TableAlreadyExists(tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Register the table metadata\n    Tables._set(tableId, fieldLayout, keySchema, valueSchema, abi.encode(keyNames), abi.encode(fieldNames));\n\n    // Register the table ID\n    ResourceIds._setExists(tableId, true);\n  }\n\n  /************************************************************************\n   *\n   *    REGISTER HOOKS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Register hooks to be called when a record or field is set or deleted.\n   * @dev This method reverts for all resource IDs other than tables.\n   * Hooks are not supported for offchain tables.\n   * @param tableId The ID of the table to register the hook for.\n   * @param hookAddress The address of the hook contract to register.\n   * @param enabledHooksBitmap The bitmap of enabled hooks.\n   */\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) internal {\n    // Hooks are only supported for tables, not for offchain tables\n    if (tableId.getType() != RESOURCE_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Require the table to exist\n    if (!ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n\n    StoreHooks._push(tableId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregister a hook from the given table ID.\n   * @param tableId The ID of the table to unregister the hook from.\n   * @param hookAddress The address of the hook to unregister.\n   */\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) internal {\n    HookLib.filterListByAddress(StoreHooks._tableId, tableId, address(hookAddress));\n  }\n\n  /************************************************************************\n   *\n   *    SET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Set a full record for the given table ID and key tuple.\n   * @dev Calling this method emits a Store_SetRecord event.\n   * This method internally calls another overload of setRecord by fetching the field layout for the given table ID.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * @param tableId The ID of the table to set the record for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    EncodedLengths encodedLengths,\n    bytes memory dynamicData\n  ) internal {\n    setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Set a full data record for the given table ID, key tuple, and field layout.\n   * @dev For onchain tables, the method emits a `Store_SetRecord` event, updates the data in storage,\n   * calls `onBeforeSetRecord` hooks before actually modifying the state, and calls `onAfterSetRecord`\n   * hooks after modifying the state. For offchain tables, the method returns early after emitting the\n   * event without calling hooks or modifying the state.\n   * @param tableId The ID of the table to set the record for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    EncodedLengths encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) internal {\n    // Early return if the table is an offchain table\n    if (tableId.getType() == RESOURCE_OFFCHAIN_TABLE) {\n      // Emit event to notify indexers\n      emit IStoreEvents.Store_SetRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n      return;\n    }\n\n    // Call onBeforeSetRecord hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SET_RECORD)) {\n        IStoreHook(hook.getAddress()).onBeforeSetRecord(\n          tableId,\n          keyTuple,\n          staticData,\n          encodedLengths,\n          dynamicData,\n          fieldLayout\n        );\n      }\n    }\n\n    // Emit event to notify indexers\n    emit IStoreEvents.Store_SetRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n\n    // Store the static data at the static data location\n    uint256 staticDataLocation = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n    uint256 memoryPointer = Memory.dataPointer(staticData);\n    Storage.store({\n      storagePointer: staticDataLocation,\n      offset: 0,\n      length: staticData.length,\n      memoryPointer: memoryPointer\n    });\n\n    // Set the dynamic data if there are dynamic fields\n    if (fieldLayout.numDynamicFields() > 0) {\n      // Store the dynamic data length at the dynamic data length location\n      uint256 dynamicDataLengthLocation = StoreCoreInternal._getDynamicDataLengthLocation(tableId, keyTuple);\n      Storage.store({ storagePointer: dynamicDataLengthLocation, data: encodedLengths.unwrap() });\n\n      // Move the memory pointer to the start of the dynamic data\n      memoryPointer = Memory.dataPointer(dynamicData);\n\n      // For every dynamic element, slice off the dynamic data and store it at the dynamic location\n      uint256 dynamicDataLocation;\n      uint256 dynamicDataLength;\n      for (uint8 i; i < fieldLayout.numDynamicFields(); ) {\n        dynamicDataLocation = StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, i);\n        dynamicDataLength = encodedLengths.atIndex(i);\n        Storage.store({\n          storagePointer: dynamicDataLocation,\n          offset: 0,\n          length: dynamicDataLength,\n          memoryPointer: memoryPointer\n        });\n        memoryPointer += dynamicDataLength; // move the memory pointer to the start of the next dynamic data\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    // Call onAfterSetRecord hooks (after modifying the state)\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SET_RECORD)) {\n        IStoreHook(hook.getAddress()).onAfterSetRecord(\n          tableId,\n          keyTuple,\n          staticData,\n          encodedLengths,\n          dynamicData,\n          fieldLayout\n        );\n      }\n    }\n  }\n\n  /**\n   * @notice Splice the static data for the given table ID and key tuple.\n   * @dev This method emits a `Store_SpliceStaticData` event, updates the data in storage, and calls\n   * `onBeforeSpliceStaticData` and `onAfterSpliceStaticData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to splice the static data for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param data The data to write to the static data of the record at the start byte.\n   */\n  function spliceStaticData(ResourceId tableId, bytes32[] memory keyTuple, uint48 start, bytes memory data) internal {\n    // Early return if the table is an offchain table\n    if (tableId.getType() == RESOURCE_OFFCHAIN_TABLE) {\n      // Emit event to notify offchain indexers\n      emit IStoreEvents.Store_SpliceStaticData({ tableId: tableId, keyTuple: keyTuple, start: start, data: data });\n      return;\n    }\n\n    uint256 location = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n\n    // Call onBeforeSpliceStaticData hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SPLICE_STATIC_DATA)) {\n        IStoreHook(hook.getAddress()).onBeforeSpliceStaticData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          start: start,\n          data: data\n        });\n      }\n    }\n\n    // Emit event to notify offchain indexers\n    emit IStoreEvents.Store_SpliceStaticData({ tableId: tableId, keyTuple: keyTuple, start: start, data: data });\n\n    // Store the provided value in storage\n    Storage.store({ storagePointer: location, offset: start, data: data });\n\n    // Call onAfterSpliceStaticData hooks\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SPLICE_STATIC_DATA)) {\n        IStoreHook(hook.getAddress()).onAfterSpliceStaticData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          start: start,\n          data: data\n        });\n      }\n    }\n  }\n\n  /**\n   * @notice Splice the dynamic data for the given table ID, key tuple, and dynamic field index.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage, and calls\n   * `onBeforeSpliceDynamicData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to splice the dynamic data for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to splice. (Dynamic field index = field index - number of static fields)\n   * @param startWithinField The start position within the field for the splice operation.\n   * @param deleteCount The number of bytes to delete in the splice operation.\n   * @param data The data to insert into the dynamic data of the record at the start byte.\n   */\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes memory data\n  ) internal {\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: startWithinField,\n      deleteCount: deleteCount,\n      data: data,\n      previousEncodedLengths: StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple)\n    });\n  }\n\n  /**\n   * @notice Set data for a field at the given index in a table with the given tableId, key tuple, and value field layout.\n   * @dev This method internally calls another overload of setField by fetching the field layout for the given table ID.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * This function emits a `Store_SpliceStaticData` or `Store_SpliceDynamicData` event and calls the corresponding hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the field for.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the field.\n   */\n  function setField(ResourceId tableId, bytes32[] memory keyTuple, uint8 fieldIndex, bytes memory data) internal {\n    setField(tableId, keyTuple, fieldIndex, data, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Set data for a field at the given index in a table with the given tableId, key tuple, and value field layout.\n   * @dev This method internally calls to `setStaticField` or `setDynamicField` based on the field index and layout.\n   * Calling `setStaticField` or `setDynamicField` directly is recommended if the caller is aware of the field layout.\n   * This function emits a `Store_SpliceStaticData` or `Store_SpliceDynamicData` event, updates the data in storage,\n   * and calls the corresponding hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the field for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the field.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    if (fieldIndex < fieldLayout.numStaticFields()) {\n      setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    } else {\n      setDynamicField(tableId, keyTuple, fieldIndex - uint8(fieldLayout.numStaticFields()), data);\n    }\n  }\n\n  /**\n   * @notice Set a static field for the given table ID, key tuple, field index, and field layout.\n   * @dev This method emits a `Store_SpliceStaticData` event, updates the data in storage and calls the\n   * `onBeforeSpliceStaticData` and `onAfterSpliceStaticData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the static field for.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the static field.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    spliceStaticData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      start: uint48(StoreCoreInternal._getStaticDataOffset(fieldLayout, fieldIndex)),\n      data: data\n    });\n  }\n\n  /**\n   * @notice Set a dynamic field for the given table ID, key tuple, and dynamic field index.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage and calls the\n   * `onBeforeSpliceDynamicaData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the dynamic field for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to set. (Dynamic field index = field index - number of static fields).\n   * @param data The data to set for the dynamic field.\n   */\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory data\n  ) internal {\n    // Load the previous length of the field to set from storage to compute how much data to delete\n    EncodedLengths previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: 0,\n      deleteCount: previousFieldLength,\n      data: data,\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /**\n   * @notice Delete a record for the given table ID and key tuple.\n   * @dev This method internally calls another overload of deleteRecord by fetching the field layout for the given table ID.\n   * This method deletes static data and sets the dynamic data length to 0, but does not\n   * actually modify the dynamic data. It emits a `Store_DeleteRecord` event and emits the\n   * `onBeforeDeleteRecord` and `onAfterDeleteRecord` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to delete the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple) internal {\n    deleteRecord(tableId, keyTuple, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Delete a record for the given table ID and key tuple.\n   * @dev This method deletes static data and sets the dynamic data length to 0, but does not\n   * actually modify the dynamic data. It emits a `Store_DeleteRecord` event and emits the\n   * `onBeforeDeleteRecord` and `onAfterDeleteRecord` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to delete the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldLayout The field layout for the record.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) internal {\n    // Early return if the table is an offchain table\n    if (tableId.getType() == RESOURCE_OFFCHAIN_TABLE) {\n      // Emit event to notify indexers\n      emit IStoreEvents.Store_DeleteRecord(tableId, keyTuple);\n      return;\n    }\n\n    // Call onBeforeDeleteRecord hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_DELETE_RECORD)) {\n        IStoreHook(hook.getAddress()).onBeforeDeleteRecord(tableId, keyTuple, fieldLayout);\n      }\n    }\n\n    // Emit event to notify indexers\n    emit IStoreEvents.Store_DeleteRecord(tableId, keyTuple);\n\n    // Delete static data\n    uint256 staticDataLocation = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n    Storage.store({ storagePointer: staticDataLocation, offset: 0, data: new bytes(fieldLayout.staticDataLength()) });\n\n    // If there are dynamic fields, set the dynamic data length to 0.\n    // We don't need to delete the dynamic data because it will be overwritten when a new record is set.\n    if (fieldLayout.numDynamicFields() > 0) {\n      uint256 dynamicDataLengthLocation = StoreCoreInternal._getDynamicDataLengthLocation(tableId, keyTuple);\n      Storage.zero({ storagePointer: dynamicDataLengthLocation, length: 32 });\n    }\n\n    // Call onAfterDeleteRecord hooks\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_DELETE_RECORD)) {\n        IStoreHook(hook.getAddress()).onAfterDeleteRecord(tableId, keyTuple, fieldLayout);\n      }\n    }\n  }\n\n  /**\n   * @notice Push data to a field at the dynamic field index in a table with the given table ID and key tuple.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage and calls the\n   * `onBeforeSpliceDynamicData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to push data to the dynamic field.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to push data to.\n   * @param dataToPush The data to push to the dynamic field.\n   */\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory dataToPush\n  ) internal {\n    // Load the previous length of the field to set from storage to compute where to start to push\n    EncodedLengths previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    // Splice the dynamic data\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: uint40(previousFieldLength),\n      deleteCount: 0,\n      data: dataToPush,\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /**\n   * @notice Pop data from a field at the dynamic field index in a table with the given table ID and key tuple.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage and calls the\n   * `onBeforeSpliceDynamicData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to pop data from the dynamic field.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to pop data from.\n   * @param byteLengthToPop The byte length to pop from the dynamic field.\n   */\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) internal {\n    // Load the previous length of the field to set from storage to compute where to start to push\n    EncodedLengths previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    // Splice the dynamic data\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: uint40(previousFieldLength - byteLengthToPop),\n      deleteCount: uint40(byteLengthToPop),\n      data: new bytes(0),\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /************************************************************************\n   *\n   *    GET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Get the full record (all fields, static and dynamic data) for the given table ID and key tuple.\n   * @dev This function internally calls another overload of `getRecord`, loading the field layout from storage.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * @param tableId The ID of the table to get the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @return staticData The static data of the record.\n   * @return encodedLengths The encoded lengths of the dynamic data of the record.\n   * @return dynamicData The dynamic data of the record.\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple\n  ) internal view returns (bytes memory staticData, EncodedLengths encodedLengths, bytes memory dynamicData) {\n    return getRecord(tableId, keyTuple, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Get the full record (all fields, static and dynamic data) for the given table ID and key tuple, with the given field layout.\n   * @param tableId The ID of the table to get the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldLayout The field layout for the record.\n   * @return staticData The static data of the record.\n   * @return encodedLengths The encoded lengths of the dynamic data of the record.\n   * @return dynamicData The dynamic data of the record.\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory staticData, EncodedLengths encodedLengths, bytes memory dynamicData) {\n    // Get the static data length\n    uint256 staticLength = fieldLayout.staticDataLength();\n\n    // Load the static data from storage\n    staticData = StoreCoreInternal._getStaticData(tableId, keyTuple, staticLength);\n\n    // Load the dynamic data if there are dynamic fields\n    uint256 numDynamicFields = fieldLayout.numDynamicFields();\n    if (numDynamicFields > 0) {\n      // Load the encoded dynamic data length\n      encodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n\n      // Append dynamic data\n      dynamicData = new bytes(encodedLengths.total());\n      uint256 memoryPointer = Memory.dataPointer(dynamicData);\n\n      for (uint8 i; i < numDynamicFields; i++) {\n        uint256 dynamicDataLocation = StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, i);\n        uint256 length = encodedLengths.atIndex(i);\n        Storage.load({ storagePointer: dynamicDataLocation, offset: 0, length: length, memoryPointer: memoryPointer });\n        // Advance memoryPointer by the length of this dynamic field\n        memoryPointer += length;\n      }\n    }\n  }\n\n  /**\n   * @notice Get a single field from the given table ID and key tuple.\n   * @dev This function internally calls another overload of `getField`, loading the field layout from storage.\n   * @param tableId The ID of the table to get the field from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldIndex The index of the field to get.\n   * @return The data of the field.\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) internal view returns (bytes memory) {\n    return getField(tableId, keyTuple, fieldIndex, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Get a single field from the given table ID and key tuple, with the given field layout.\n   * @param tableId The ID of the table to get the field from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldIndex The index of the field to get.\n   * @param fieldLayout The field layout for the record.\n   * @return The data of the field.\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory) {\n    if (fieldIndex < fieldLayout.numStaticFields()) {\n      return StoreCoreInternal._getStaticFieldBytes(tableId, keyTuple, fieldIndex, fieldLayout);\n    } else {\n      return getDynamicField(tableId, keyTuple, fieldIndex - uint8(fieldLayout.numStaticFields()));\n    }\n  }\n\n  /**\n   * @notice Get a single static field from the given table ID and key tuple, with the given value field layout.\n   * @dev The field value is left-aligned in the returned bytes32, the rest of the word is not zeroed out.\n   * Consumers are expected to truncate the returned value as needed.\n   * @param tableId The ID of the table to get the static field from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldIndex The index of the field to get.\n   * @param fieldLayout The field layout for the record.\n   * @return The data of the static field.\n   */\n  function getStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes32) {\n    // Get the length, storage location and offset of the static field\n    // and load the data from storage\n    return\n      Storage.loadField({\n        storagePointer: StoreCoreInternal._getStaticDataLocation(tableId, keyTuple),\n        length: fieldLayout.atIndex(fieldIndex),\n        offset: StoreCoreInternal._getStaticDataOffset(fieldLayout, fieldIndex)\n      });\n  }\n\n  /**\n   * @notice Get a single dynamic field from the given table ID and key tuple.\n   * @param tableId The ID of the table to get the dynamic field from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to get, relative to the start of the dynamic fields.\n   * (Dynamic field index = field index - number of static fields)\n   * @return The data of the dynamic field.\n   */\n  function getDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal view returns (bytes memory) {\n    // Get the storage location of the dynamic field\n    // and load the data from storage\n    return\n      Storage.load({\n        storagePointer: StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, dynamicFieldIndex),\n        offset: 0,\n        length: StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple).atIndex(dynamicFieldIndex)\n      });\n  }\n\n  /**\n   * @notice Get the byte length of a single field from the given table ID and key tuple.\n   * @dev This function internally calls another overload of `getFieldLength`, loading the field layout from storage.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * @param tableId The ID of the table to get the field length from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldIndex The index of the field to get the length for.\n   * @return The byte length of the field.\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) internal view returns (uint256) {\n    return getFieldLength(tableId, keyTuple, fieldIndex, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Get the byte length of a single field from the given table ID and key tuple.\n   * @param tableId The ID of the table to get the field length from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldIndex The index of the field to get the length for.\n   * @param fieldLayout The field layout for the record.\n   * @return The byte length of the field.\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (uint256) {\n    uint8 numStaticFields = uint8(fieldLayout.numStaticFields());\n    if (fieldIndex < numStaticFields) {\n      return fieldLayout.atIndex(fieldIndex);\n    } else {\n      return getDynamicFieldLength(tableId, keyTuple, fieldIndex - numStaticFields);\n    }\n  }\n\n  /**\n   * @notice Get the byte length of a single dynamic field from the given table ID and key tuple.\n   * @param tableId The ID of the table to get the dynamic field length from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to get the length for, relative to the start of the dynamic fields.\n   * (Dynamic field index = field index - number of static fields)\n   * @return The byte length of the dynamic field.\n   */\n  function getDynamicFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal view returns (uint256) {\n    return StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple).atIndex(dynamicFieldIndex);\n  }\n\n  /**\n   * @notice Get a byte slice (including start, excluding end) of a single dynamic field from the given table ID and key tuple.\n   * @param tableId The ID of the table to get the dynamic field slice from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to get the slice from, relative to the start of the dynamic fields.\n   * (Dynamic field index = field index - number of static fields)\n   * @param start The start index within the dynamic field for the slice operation (inclusive).\n   * @param end The end index within the dynamic field for the slice operation (exclusive).\n   * @return The byte slice of the dynamic field.\n   */\n  function getDynamicFieldSlice(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 start,\n    uint256 end\n  ) internal view returns (bytes memory) {\n    // Verify the slice bounds are valid\n    if (start > end) {\n      revert IStoreErrors.Store_InvalidBounds(start, end);\n    }\n    // Verify the accessed data is within the bounds of the dynamic field.\n    // This is necessary because we don't delete the dynamic data when a record is deleted,\n    // but only decrease its length.\n    EncodedLengths encodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint256 fieldLength = encodedLengths.atIndex(dynamicFieldIndex);\n    if (start >= fieldLength || end > fieldLength) {\n      revert IStoreErrors.Store_IndexOutOfBounds(fieldLength, start >= fieldLength ? start : end - 1);\n    }\n\n    // Get the length and storage location of the dynamic field\n    uint256 location = StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, dynamicFieldIndex);\n\n    unchecked {\n      return Storage.load({ storagePointer: location, offset: start, length: end - start });\n    }\n  }\n}\n\n/**\n * @title StoreCoreInternal\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This library contains internal functions used by StoreCore.\n * They are not intended to be used directly by consumers of StoreCore.\n */\nlibrary StoreCoreInternal {\n  bytes32 internal constant SLOT = keccak256(\"mud.store\");\n  bytes32 internal constant DYNAMIC_DATA_SLOT = keccak256(\"mud.store.dynamicData\");\n  bytes32 internal constant DYNAMIC_DATA_LENGTH_SLOT = keccak256(\"mud.store.dynamicDataLength\");\n\n  /************************************************************************\n   *\n   *    SET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Splice dynamic data in the store.\n   * @dev This function checks various conditions to ensure the operation is valid.\n   * It emits a `Store_SpliceDynamicData` event, calls `onBeforeSpliceDynamicData` hooks before actually modifying the storage,\n   * and calls `onAfterSpliceDynamicData` hooks after modifying the storage.\n   * It reverts with `Store_InvalidResourceType` if the table ID is not a table.\n   * (Splicing dynamic data is not supported for offchain tables, as it requires reading the previous encoded lengths from storage.)\n   * It reverts with `Store_InvalidSplice` if the splice total length of the field is changed but the splice is not at the end of the field.\n   * It reverts with `Store_IndexOutOfBounds` if the start index is larger than the previous length of the field.\n   * @param tableId The ID of the table to splice dynamic data.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to splice data, relative to the start of the dynamic fields.\n   * (Dynamic field index = field index - number of static fields)\n   * @param startWithinField The start index within the field for the splice operation.\n   * @param deleteCount The number of bytes to delete in the splice operation.\n   * @param data The data to insert into the dynamic data of the record at the start byte.\n   * @param previousEncodedLengths The previous encoded lengths of the dynamic data of the record.\n   */\n  function _spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes memory data,\n    EncodedLengths previousEncodedLengths\n  ) internal {\n    // Splicing dynamic data is not supported for offchain tables, because it\n    // requires reading the previous encoded lengths from storage\n    if (tableId.getType() != RESOURCE_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    uint256 previousFieldLength = previousEncodedLengths.atIndex(dynamicFieldIndex);\n    uint256 updatedFieldLength = previousFieldLength - deleteCount + data.length;\n\n    // If the total length of the field is changed, the data has to be appended/removed at the end of the field.\n    // Otherwise offchain indexers would shift the data after inserted data, while onchain the data is truncated at the end.\n    if (previousFieldLength != updatedFieldLength && startWithinField + deleteCount != previousFieldLength) {\n      revert IStoreErrors.Store_InvalidSplice(startWithinField, deleteCount, uint40(previousFieldLength));\n    }\n\n    // The start index can't be larger than the previous length of the field\n    if (startWithinField > previousFieldLength) {\n      revert IStoreErrors.Store_IndexOutOfBounds(previousFieldLength, startWithinField);\n    }\n\n    // Update the encoded length\n    EncodedLengths updatedEncodedLengths = previousEncodedLengths.setAtIndex(dynamicFieldIndex, updatedFieldLength);\n\n    // Call onBeforeSpliceDynamicData hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SPLICE_DYNAMIC_DATA)) {\n        IStoreHook(hook.getAddress()).onBeforeSpliceDynamicData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          dynamicFieldIndex: dynamicFieldIndex,\n          startWithinField: startWithinField,\n          deleteCount: deleteCount,\n          encodedLengths: previousEncodedLengths,\n          data: data\n        });\n      }\n    }\n\n    {\n      // Compute start index for the splice\n      uint256 start = startWithinField;\n      unchecked {\n        // (safe because it's a few uint40 values, which can't overflow uint48)\n        for (uint8 i; i < dynamicFieldIndex; i++) {\n          start += previousEncodedLengths.atIndex(i);\n        }\n      }\n\n      // Emit event to notify offchain indexers\n      emit IStoreEvents.Store_SpliceDynamicData({\n        tableId: tableId,\n        keyTuple: keyTuple,\n        dynamicFieldIndex: dynamicFieldIndex,\n        start: uint48(start),\n        deleteCount: deleteCount,\n        encodedLengths: updatedEncodedLengths,\n        data: data\n      });\n    }\n\n    // Store the updated encoded lengths in storage\n    if (previousFieldLength != updatedFieldLength) {\n      uint256 dynamicSchemaLengthSlot = _getDynamicDataLengthLocation(tableId, keyTuple);\n      Storage.store({ storagePointer: dynamicSchemaLengthSlot, data: updatedEncodedLengths.unwrap() });\n    }\n\n    // Store the provided value in storage\n    {\n      uint256 dynamicDataLocation = _getDynamicDataLocation(tableId, keyTuple, dynamicFieldIndex);\n      Storage.store({ storagePointer: dynamicDataLocation, offset: startWithinField, data: data });\n    }\n\n    // Call onAfterSpliceDynamicData hooks\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SPLICE_DYNAMIC_DATA)) {\n        IStoreHook(hook.getAddress()).onAfterSpliceDynamicData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          dynamicFieldIndex: dynamicFieldIndex,\n          startWithinField: startWithinField,\n          deleteCount: deleteCount,\n          encodedLengths: updatedEncodedLengths,\n          data: data\n        });\n      }\n    }\n  }\n\n  /************************************************************************\n   *\n   *    GET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Get full static data for the given table ID and key tuple, with the given length in bytes.\n   * @param tableId The ID of the table to get the static data from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param length The length of the static data to retrieve.\n   * @return The full static data of the specified length.\n   */\n  function _getStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint256 length\n  ) internal view returns (bytes memory) {\n    if (length == 0) return \"\";\n\n    // Load the data from storage\n    uint256 location = _getStaticDataLocation(tableId, keyTuple);\n    return Storage.load({ storagePointer: location, offset: 0, length: length });\n  }\n\n  /**\n   * @notice Get a single static field from the given table ID and key tuple, with the given value field layout.\n   * @param tableId The ID of the table to get the static field from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldIndex The index of the field to get.\n   * @param fieldLayout The field layout for the record.\n   * @return The static field data as dynamic bytes in the size of the field.\n   */\n  function _getStaticFieldBytes(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory) {\n    // Get the length, storage location and offset of the static field\n    // and load the data from storage\n    return\n      Storage.load({\n        storagePointer: _getStaticDataLocation(tableId, keyTuple),\n        offset: _getStaticDataOffset(fieldLayout, fieldIndex),\n        length: fieldLayout.atIndex(fieldIndex)\n      });\n  }\n\n  /************************************************************************\n   *\n   *    HELPER FUNCTIONS\n   *\n   ************************************************************************/\n\n  /////////////////////////////////////////////////////////////////////////\n  //    STATIC DATA\n  /////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Compute the storage location based on table ID and key tuple.\n   * @param tableId The ID of the table.\n   * @param keyTuple An array representing the composite key for the record.\n   * @return The computed storage location based on table ID and key tuple.\n   */\n  function _getStaticDataLocation(ResourceId tableId, bytes32[] memory keyTuple) internal pure returns (uint256) {\n    return uint256(SLOT ^ keccak256(abi.encodePacked(tableId, keyTuple)));\n  }\n\n  /**\n   * @notice Compute the storage location based on table ID and a single key.\n   * @param tableId The ID of the table.\n   * @param key The single key for the record.\n   * @return The computed storage location based on table ID and key.\n   */\n  function _getStaticDataLocation(ResourceId tableId, bytes32 key) internal pure returns (uint256) {\n    // keccak256(abi.encodePacked(tableId, key)) is equivalent to keccak256(abi.encodePacked(tableId, [key]))\n    return uint256(SLOT ^ keccak256(abi.encodePacked(tableId, key)));\n  }\n\n  /**\n   * @notice Get storage offset for the given value field layout and index.\n   * @param fieldLayout The field layout for the record.\n   * @param fieldIndex The index of the field to get the offset for.\n   * @return The storage offset for the specified field layout and index.\n   */\n  function _getStaticDataOffset(FieldLayout fieldLayout, uint8 fieldIndex) internal pure returns (uint256) {\n    uint256 offset = 0;\n    for (uint256 i; i < fieldIndex; i++) {\n      offset += fieldLayout.atIndex(i);\n    }\n    return offset;\n  }\n\n  /////////////////////////////////////////////////////////////////////////\n  //    DYNAMIC DATA\n  /////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Compute the storage location based on table ID, key tuple, and dynamic field index.\n   * @param tableId The ID of the table.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field, relative to the start of the dynamic fields.\n   * (Dynamic field index = field index - number of static fields)\n   * @return The computed storage location based on table ID, key tuple, and dynamic field index.\n   */\n  function _getDynamicDataLocation(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal pure returns (uint256) {\n    return uint256(DYNAMIC_DATA_SLOT ^ bytes1(dynamicFieldIndex) ^ keccak256(abi.encodePacked(tableId, keyTuple)));\n  }\n\n  /**\n   * @notice Compute the storage location for the length of the dynamic data based on table ID and key tuple.\n   * @param tableId The ID of the table.\n   * @param keyTuple An array representing the composite key for the record.\n   * @return The computed storage location for the length of the dynamic data based on table ID and key tuple.\n   */\n  function _getDynamicDataLengthLocation(\n    ResourceId tableId,\n    bytes32[] memory keyTuple\n  ) internal pure returns (uint256) {\n    return uint256(DYNAMIC_DATA_LENGTH_SLOT ^ keccak256(abi.encodePacked(tableId, keyTuple)));\n  }\n\n  /**\n   * @notice Load the encoded dynamic data length from storage for the given table ID and key tuple.\n   * @param tableId The ID of the table.\n   * @param keyTuple An array representing the composite key for the record.\n   * @return The loaded encoded dynamic data length from storage for the given table ID and key tuple.\n   */\n  function _loadEncodedDynamicDataLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple\n  ) internal view returns (EncodedLengths) {\n    // Load dynamic data length from storage\n    return EncodedLengths.wrap(Storage.load({ storagePointer: _getDynamicDataLengthLocation(tableId, keyTuple) }));\n  }\n}\n"},"node_modules/@latticexyz/store/src/Schema.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { SchemaType } from \"@latticexyz/schema-type/src/solidity/SchemaType.sol\";\n\nimport { WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS, LayoutOffsets } from \"./constants.sol\";\nimport { ISchemaErrors } from \"./ISchemaErrors.sol\";\n\n/**\n * @title Schema handling in Lattice\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Defines and handles the encoding/decoding of Schemas which describe the layout of data structures.\n * 2 bytes length of all the static (in size) fields in the schema\n * 1 byte for number of static size fields\n * 1 byte for number of dynamic size fields\n * 28 bytes for 28 schema types (MAX_DYNAMIC_FIELDS allows us to pack the lengths into 1 word)\n */\ntype Schema is bytes32;\n\nusing SchemaInstance for Schema global;\n\n/**\n * @title SchemaLib\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Static utility functions for handling Schemas.\n */\nlibrary SchemaLib {\n  /**\n   * @notice Encodes a given schema into a single bytes32.\n   * @param schemas The list of SchemaTypes that constitute the schema.\n   * @return The encoded Schema.\n   */\n  function encode(SchemaType[] memory schemas) internal pure returns (Schema) {\n    if (schemas.length > MAX_TOTAL_FIELDS) revert ISchemaErrors.Schema_InvalidLength(schemas.length);\n    uint256 schema;\n    uint256 totalLength;\n    uint256 dynamicFields;\n\n    // Compute the length of the schema and the number of static fields\n    // and store the schema types in the encoded schema\n    for (uint256 i = 0; i < schemas.length; ) {\n      uint256 staticByteLength = schemas[i].getStaticByteLength();\n\n      if (staticByteLength == 0) {\n        // Increase the dynamic field count if the field is dynamic\n        // (safe because of the initial _schema.length check)\n        unchecked {\n          dynamicFields++;\n        }\n      } else if (dynamicFields > 0) {\n        // Revert if we have seen a dynamic field before, but now we see a static field\n        revert ISchemaErrors.Schema_StaticTypeAfterDynamicType();\n      }\n\n      unchecked {\n        // (safe because 28 (max _schema.length) * 32 (max static length) < 2**16)\n        totalLength += staticByteLength;\n        // Sequentially store schema types after the first 4 bytes (which are reserved for length and field numbers)\n        // (safe because of the initial _schema.length check)\n        schema |= uint256(schemas[i]) << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n        i++;\n      }\n    }\n\n    // Require MAX_DYNAMIC_FIELDS\n    if (dynamicFields > MAX_DYNAMIC_FIELDS) revert ISchemaErrors.Schema_InvalidLength(dynamicFields);\n\n    // Get the static field count\n    uint256 staticFields;\n    unchecked {\n      staticFields = schemas.length - dynamicFields;\n    }\n\n    // Store total static length in the first 2 bytes,\n    // number of static fields in the 3rd byte,\n    // number of dynamic fields in the 4th byte\n    // (optimizer can handle this, no need for unchecked or single-line assignment)\n    schema |= totalLength << LayoutOffsets.TOTAL_LENGTH;\n    schema |= staticFields << LayoutOffsets.NUM_STATIC_FIELDS;\n    schema |= dynamicFields << LayoutOffsets.NUM_DYNAMIC_FIELDS;\n\n    return Schema.wrap(bytes32(schema));\n  }\n}\n\n/**\n * @title SchemaInstance\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Instance utility functions for handling a Schema instance.\n */\nlibrary SchemaInstance {\n  /**\n   * @notice Get the length of static data for the given schema.\n   * @param schema The schema to inspect.\n   * @return The static data length.\n   */\n  function staticDataLength(Schema schema) internal pure returns (uint256) {\n    return uint256(Schema.unwrap(schema)) >> LayoutOffsets.TOTAL_LENGTH;\n  }\n\n  /**\n   * @notice Get the SchemaType at a given index in the schema.\n   * @param schema The schema to inspect.\n   * @param index The index of the SchemaType to retrieve.\n   * @return The SchemaType at the given index.\n   */\n  function atIndex(Schema schema, uint256 index) internal pure returns (SchemaType) {\n    unchecked {\n      return SchemaType(uint8(uint256(schema.unwrap()) >> ((WORD_LAST_INDEX - 4 - index) * 8)));\n    }\n  }\n\n  /**\n   * @notice Get the number of static (fixed length) fields in the schema.\n   * @param schema The schema to inspect.\n   * @return The number of static fields.\n   */\n  function numStaticFields(Schema schema) internal pure returns (uint256) {\n    return uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS);\n  }\n\n  /**\n   * @notice Get the number of dynamic length fields in the schema.\n   * @param schema The schema to inspect.\n   * @return The number of dynamic length fields.\n   */\n  function numDynamicFields(Schema schema) internal pure returns (uint256) {\n    return uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n  }\n\n  /**\n   * @notice Get the total number of fields in the schema.\n   * @param schema The schema to inspect.\n   * @return The total number of fields.\n   */\n  function numFields(Schema schema) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS) +\n        uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n    }\n  }\n\n  /**\n   * @notice Checks if the provided schema is empty.\n   * @param schema The schema to check.\n   * @return true if the schema is empty, false otherwise.\n   */\n  function isEmpty(Schema schema) internal pure returns (bool) {\n    return Schema.unwrap(schema) == bytes32(0);\n  }\n\n  /**\n   * @notice Validates the given schema.\n   * @param schema The schema to validate.\n   * @param allowEmpty Determines if an empty schema is valid or not.\n   */\n  function validate(Schema schema, bool allowEmpty) internal pure {\n    // Schema must not be empty\n    if (!allowEmpty && schema.isEmpty()) revert ISchemaErrors.Schema_InvalidLength(0);\n\n    // Schema must have no more than MAX_DYNAMIC_FIELDS\n    uint256 _numDynamicFields = schema.numDynamicFields();\n    if (_numDynamicFields > MAX_DYNAMIC_FIELDS) revert ISchemaErrors.Schema_InvalidLength(_numDynamicFields);\n\n    uint256 _numStaticFields = schema.numStaticFields();\n    // Schema must not have more than MAX_TOTAL_FIELDS in total\n    uint256 _numTotalFields = _numStaticFields + _numDynamicFields;\n    if (_numTotalFields > MAX_TOTAL_FIELDS) revert ISchemaErrors.Schema_InvalidLength(_numTotalFields);\n\n    // No dynamic field can be before a dynamic field\n    uint256 _staticDataLength;\n    for (uint256 i; i < _numStaticFields; ) {\n      uint256 staticByteLength = schema.atIndex(i).getStaticByteLength();\n      if (staticByteLength == 0) {\n        revert ISchemaErrors.Schema_StaticTypeAfterDynamicType();\n      }\n      _staticDataLength += staticByteLength;\n      unchecked {\n        i++;\n      }\n    }\n\n    // Static length sums must match\n    if (_staticDataLength != schema.staticDataLength()) {\n      revert ISchemaErrors.Schema_InvalidLength(schema.staticDataLength());\n    }\n\n    // No static field can be after a dynamic field\n    for (uint256 i = _numStaticFields; i < _numTotalFields; ) {\n      uint256 staticByteLength = schema.atIndex(i).getStaticByteLength();\n      if (staticByteLength > 0) {\n        revert ISchemaErrors.Schema_StaticTypeAfterDynamicType();\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * @notice Unwraps the schema to its underlying bytes32 representation.\n   * @param schema The schema to unwrap.\n   * @return The bytes32 representation of the schema.\n   */\n  function unwrap(Schema schema) internal pure returns (bytes32) {\n    return Schema.unwrap(schema);\n  }\n}\n"},"node_modules/@latticexyz/store/src/FieldLayout.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { WORD_SIZE, WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS, LayoutOffsets } from \"./constants.sol\";\nimport { IFieldLayoutErrors } from \"./IFieldLayoutErrors.sol\";\n\n/**\n * @title FieldLayout\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Represents a field layout encoded into a single bytes32.\n * From left to right, the bytes are laid out as follows:\n * - 2 bytes for total length of all static fields\n * - 1 byte for number of static size fields\n * - 1 byte for number of dynamic size fields\n * - 28 bytes for 28 static field lengths\n * (MAX_DYNAMIC_FIELDS allows EncodedLengths to pack the dynamic lengths into 1 word)\n */\ntype FieldLayout is bytes32;\n\n// When importing FieldLayout, attach FieldLayoutInstance to it\nusing FieldLayoutInstance for FieldLayout global;\n\n/**\n * @title FieldLayoutLib\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev A library for handling field layout encoding into a single bytes32.\n * It provides a function to encode static and dynamic fields and ensure\n * various constraints regarding the length and size of the fields.\n */\nlibrary FieldLayoutLib {\n  /**\n   * @notice Encodes the given field layout into a single bytes32.\n   * @dev Ensures various constraints on the length and size of the fields.\n   * Reverts if total fields, static field length, or static byte length exceed allowed limits.\n   * @param _staticFieldLengths An array of static field lengths.\n   * @param numDynamicFields The number of dynamic fields.\n   * @return A FieldLayout structure containing the encoded field layout.\n   */\n  function encode(uint256[] memory _staticFieldLengths, uint256 numDynamicFields) internal pure returns (FieldLayout) {\n    uint256 fieldLayout;\n    uint256 totalLength;\n    uint256 totalFields = _staticFieldLengths.length + numDynamicFields;\n    if (totalFields > MAX_TOTAL_FIELDS)\n      revert IFieldLayoutErrors.FieldLayout_TooManyFields(totalFields, MAX_TOTAL_FIELDS);\n    if (numDynamicFields > MAX_DYNAMIC_FIELDS)\n      revert IFieldLayoutErrors.FieldLayout_TooManyDynamicFields(numDynamicFields, MAX_DYNAMIC_FIELDS);\n\n    // Compute the total static length and store the field lengths in the encoded fieldLayout\n    for (uint256 i; i < _staticFieldLengths.length; ) {\n      uint256 staticByteLength = _staticFieldLengths[i];\n      if (staticByteLength == 0) {\n        revert IFieldLayoutErrors.FieldLayout_StaticLengthIsZero(i);\n      } else if (staticByteLength > WORD_SIZE) {\n        revert IFieldLayoutErrors.FieldLayout_StaticLengthDoesNotFitInAWord(i);\n      }\n\n      unchecked {\n        // (safe because 28 (max _staticFieldLengths.length) * 32 (max static length) < 2**16)\n        totalLength += staticByteLength;\n        // Sequentially store lengths after the first 4 bytes (which are reserved for total length and field numbers)\n        // (safe because of the initial _staticFieldLengths.length check)\n        fieldLayout |= uint256(_staticFieldLengths[i]) << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n        i++;\n      }\n    }\n\n    // Store total static length in the first 2 bytes,\n    // number of static fields in the 3rd byte,\n    // number of dynamic fields in the 4th byte\n    // (optimizer can handle this, no need for unchecked or single-line assignment)\n    fieldLayout |= totalLength << LayoutOffsets.TOTAL_LENGTH;\n    fieldLayout |= _staticFieldLengths.length << LayoutOffsets.NUM_STATIC_FIELDS;\n    fieldLayout |= numDynamicFields << LayoutOffsets.NUM_DYNAMIC_FIELDS;\n\n    return FieldLayout.wrap(bytes32(fieldLayout));\n  }\n}\n\n/**\n * @title FieldLayoutInstance\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Provides instance functions for obtaining information from an encoded FieldLayout.\n */\nlibrary FieldLayoutInstance {\n  /**\n   * @notice Get the static byte length at the given index from the field layout.\n   * @param fieldLayout The FieldLayout to extract the byte length from.\n   * @param index The field index to get the static byte length from.\n   * @return The static byte length at the specified index.\n   */\n  function atIndex(FieldLayout fieldLayout, uint256 index) internal pure returns (uint256) {\n    unchecked {\n      return uint8(uint256(fieldLayout.unwrap()) >> ((WORD_LAST_INDEX - 4 - index) * BYTE_TO_BITS));\n    }\n  }\n\n  /**\n   * @notice Get the total static byte length for the given field layout.\n   * @param fieldLayout The FieldLayout to extract the total static byte length from.\n   * @return The total static byte length.\n   */\n  function staticDataLength(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint256(FieldLayout.unwrap(fieldLayout)) >> LayoutOffsets.TOTAL_LENGTH;\n  }\n\n  /**\n   * @notice Get the number of static fields for the field layout.\n   * @param fieldLayout The FieldLayout to extract the number of static fields from.\n   * @return The number of static fields.\n   */\n  function numStaticFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS);\n  }\n\n  /**\n   * @notice Get the number of dynamic length fields for the field layout.\n   * @param fieldLayout The FieldLayout to extract the number of dynamic fields from.\n   * @return The number of dynamic length fields.\n   */\n  function numDynamicFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n  }\n\n  /**\n   * @notice Get the total number of fields for the field layout.\n   * @param fieldLayout The FieldLayout to extract the total number of fields from.\n   * @return The total number of fields.\n   */\n  function numFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS) +\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n    }\n  }\n\n  /**\n   * @notice Check if the field layout is empty.\n   * @param fieldLayout The FieldLayout to check.\n   * @return True if the field layout is empty, false otherwise.\n   */\n  function isEmpty(FieldLayout fieldLayout) internal pure returns (bool) {\n    return FieldLayout.unwrap(fieldLayout) == bytes32(0);\n  }\n\n  /**\n   * @notice Validate the field layout with various checks on the length and size of the fields.\n   * @dev Reverts if total fields, static field length, or static byte length exceed allowed limits.\n   * @param fieldLayout The FieldLayout to validate.\n   */\n  function validate(FieldLayout fieldLayout) internal pure {\n    if (fieldLayout.isEmpty()) {\n      revert IFieldLayoutErrors.FieldLayout_Empty();\n    }\n\n    uint256 _numDynamicFields = fieldLayout.numDynamicFields();\n    if (_numDynamicFields > MAX_DYNAMIC_FIELDS) {\n      revert IFieldLayoutErrors.FieldLayout_TooManyDynamicFields(_numDynamicFields, MAX_DYNAMIC_FIELDS);\n    }\n\n    uint256 _numStaticFields = fieldLayout.numStaticFields();\n    uint256 _numTotalFields = _numStaticFields + _numDynamicFields;\n    if (_numTotalFields > MAX_TOTAL_FIELDS) {\n      revert IFieldLayoutErrors.FieldLayout_TooManyFields(_numTotalFields, MAX_TOTAL_FIELDS);\n    }\n\n    // Static lengths must be valid\n    uint256 _staticDataLength;\n    for (uint256 i; i < _numStaticFields; ) {\n      uint256 staticByteLength = fieldLayout.atIndex(i);\n      if (staticByteLength == 0) {\n        revert IFieldLayoutErrors.FieldLayout_StaticLengthIsZero(i);\n      } else if (staticByteLength > WORD_SIZE) {\n        revert IFieldLayoutErrors.FieldLayout_StaticLengthDoesNotFitInAWord(i);\n      }\n      _staticDataLength += staticByteLength;\n      unchecked {\n        i++;\n      }\n    }\n    // Static length sums must match\n    if (_staticDataLength != fieldLayout.staticDataLength()) {\n      revert IFieldLayoutErrors.FieldLayout_InvalidStaticDataLength(fieldLayout.staticDataLength(), _staticDataLength);\n    }\n    // Unused fields must be zero\n    for (uint256 i = _numStaticFields; i < MAX_TOTAL_FIELDS; i++) {\n      uint256 staticByteLength = fieldLayout.atIndex(i);\n      if (staticByteLength != 0) {\n        revert IFieldLayoutErrors.FieldLayout_StaticLengthIsNotZero(i);\n      }\n    }\n  }\n\n  /**\n   * @notice Unwrap the field layout to obtain the raw bytes32 representation.\n   * @param fieldLayout The FieldLayout to unwrap.\n   * @return The unwrapped bytes32 representation of the FieldLayout.\n   */\n  function unwrap(FieldLayout fieldLayout) internal pure returns (bytes32) {\n    return FieldLayout.unwrap(fieldLayout);\n  }\n}\n"},"node_modules/@latticexyz/store/src/ResourceId.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title ResourceId type definition and related utilities\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev A ResourceId is a bytes32 data structure that consists of a\n * type and a name\n */\ntype ResourceId is bytes32;\n\nusing ResourceIdInstance for ResourceId global;\n\n/// @dev Number of bits reserved for the type in the ResourceId.\nuint256 constant TYPE_BITS = 2 * 8; // 2 bytes * 8 bits per byte\n\n/**\n * @title ResourceIdLib Library\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Provides functions to encode data into the ResourceId\n */\nlibrary ResourceIdLib {\n  /**\n   * @notice Encodes given typeId and name into a ResourceId.\n   * @param typeId The type identifier to be encoded. Must be 2 bytes.\n   * @param name The name to be encoded. Must be 30 bytes.\n   * @return A ResourceId containing the encoded typeId and name.\n   */\n  function encode(bytes2 typeId, bytes30 name) internal pure returns (ResourceId) {\n    return ResourceId.wrap(bytes32(typeId) | (bytes32(name) >> TYPE_BITS));\n  }\n}\n\n/**\n * @title ResourceIdInstance Library\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Provides functions to extract data from a ResourceId.\n */\nlibrary ResourceIdInstance {\n  /**\n   * @notice Extracts the type identifier from a given ResourceId.\n   * @param resourceId The ResourceId from which the type identifier should be extracted.\n   * @return The extracted 2-byte type identifier.\n   */\n  function getType(ResourceId resourceId) internal pure returns (bytes2) {\n    return bytes2(ResourceId.unwrap(resourceId));\n  }\n\n  /**\n   * @notice Get the name from a resource ID.\n   * @param resourceId The resource ID.\n   * @return A 30-byte name.\n   */\n  function getResourceName(ResourceId resourceId) internal pure returns (bytes30) {\n    return bytes30(ResourceId.unwrap(resourceId) << (TYPE_BITS));\n  }\n\n  /**\n   * @notice Unwrap a resource ID into a bytes32.\n   * @param resourceId The resource ID.\n   * @return The underlying bytes32.\n   */\n  function unwrap(ResourceId resourceId) internal pure returns (bytes32) {\n    return ResourceId.unwrap(resourceId);\n  }\n}\n"},"node_modules/@latticexyz/world/src/IWorldKernel.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { IWorldErrors } from \"./IWorldErrors.sol\";\nimport { IModule } from \"./IModule.sol\";\nimport { ResourceId } from \"./WorldResourceId.sol\";\nimport { IModuleErrors } from \"./IModuleErrors.sol\";\nimport { IWorldEvents } from \"./IWorldEvents.sol\";\n\n/**\n * @title World Module Installation Interface\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface defines the contract responsible for managing root modules installation.\n */\ninterface IWorldModuleInstallation {\n  /**\n   * @notice Install the given root module in the World.\n   * @dev Requires the caller to own the root namespace. The module is delegatecalled and installed in the root namespace.\n   * @param module The module to be installed.\n   * @param encodedArgs The ABI encoded arguments for the module installation.\n   */\n  function installRootModule(IModule module, bytes memory encodedArgs) external;\n}\n\n/**\n * @title World Call Interface\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface defines the contract for executing calls on the World's systems.\n */\ninterface IWorldCall {\n  /**\n   * @notice Call the system at the given system ID.\n   * @dev If the system is not public, the caller must have access to the namespace or name (encoded in the system ID).\n   * @param systemId The ID of the system to be called.\n   * @param callData The data to pass with the call,\n   * function selector (4 bytes) followed by the ABI encoded parameters.\n   * @return The abi encoded return data from the called system.\n   */\n  function call(ResourceId systemId, bytes memory callData) external payable returns (bytes memory);\n\n  /**\n   * @notice Call the system at the given system ID on behalf of the given delegator.\n   * @dev If the system is not public, the delegator must have access to the namespace or name (encoded in the system ID).\n   * @param delegator The address on whose behalf the call is made.\n   * @param systemId The ID of the system to be called.\n   * @param callData The data to pass with the call,\n   * function selector (4 bytes) followed by the ABI encoded parameters.\n   * @return The abi encoded return data from the called system.\n   */\n  function callFrom(\n    address delegator,\n    ResourceId systemId,\n    bytes memory callData\n  ) external payable returns (bytes memory);\n}\n\n/**\n * @title World Kernel Interface\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice The IWorldKernel interface includes all methods that are part of the World contract's\n * internal bytecode. Consumers should use the `IBaseWorld` interface instead, which includes dynamically\n * registered functions selectors from the `InitModule`.\n * @dev The IWorldKernel interface inherits IModuleErrors because the world can be delegatecalled with module code,\n * so it's ABI should include these errors.\n */\ninterface IWorldKernel is IWorldModuleInstallation, IWorldCall, IWorldErrors, IWorldEvents, IModuleErrors {\n  /**\n   * @notice Retrieve the protocol version of the World.\n   * @return The protocol version of the World.\n   */\n  function worldVersion() external view returns (bytes32);\n\n  /**\n   * @notice Retrieve the immutable original deployer of the World.\n   * @return The address of the World's creator.\n   */\n  function creator() external view returns (address);\n\n  /**\n   * @notice Initializes the World.\n   * @dev Can only be called once by the creator.\n   * @param initModule The InitModule to be installed during initialization.\n   */\n  function initialize(IModule initModule) external;\n}\n"},"node_modules/@latticexyz/world/src/codegen/interfaces/IRegistrationSystem.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\n/**\n * @title IRegistrationSystem\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface is automatically generated from the corresponding system contract. Do not edit manually.\n */\ninterface IRegistrationSystem {}\n"},"node_modules/@latticexyz/world/src/codegen/interfaces/IAccessManagementSystem.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\nimport { ResourceId } from \"../../WorldResourceId.sol\";\n\n/**\n * @title IAccessManagementSystem\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface is automatically generated from the corresponding system contract. Do not edit manually.\n */\ninterface IAccessManagementSystem {\n  function grantAccess(ResourceId resourceId, address grantee) external;\n\n  function revokeAccess(ResourceId resourceId, address grantee) external;\n\n  function transferOwnership(ResourceId namespaceId, address newOwner) external;\n\n  function renounceOwnership(ResourceId namespaceId) external;\n}\n"},"node_modules/@latticexyz/world/src/codegen/interfaces/IBalanceTransferSystem.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\nimport { ResourceId } from \"@latticexyz/store/src/ResourceId.sol\";\n\n/**\n * @title IBalanceTransferSystem\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface is automatically generated from the corresponding system contract. Do not edit manually.\n */\ninterface IBalanceTransferSystem {\n  function transferBalanceToNamespace(ResourceId fromNamespaceId, ResourceId toNamespaceId, uint256 amount) external;\n\n  function transferBalanceToAddress(ResourceId fromNamespaceId, address toAddress, uint256 amount) external;\n}\n"},"node_modules/@latticexyz/world/src/codegen/interfaces/IBatchCallSystem.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\nimport { SystemCallData, SystemCallFromData } from \"../../modules/init/types.sol\";\n\n/**\n * @title IBatchCallSystem\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface is automatically generated from the corresponding system contract. Do not edit manually.\n */\ninterface IBatchCallSystem {\n  function batchCall(SystemCallData[] calldata systemCalls) external returns (bytes[] memory returnDatas);\n\n  function batchCallFrom(SystemCallFromData[] calldata systemCalls) external returns (bytes[] memory returnDatas);\n}\n"},"node_modules/@latticexyz/world/src/codegen/interfaces/IModuleInstallationSystem.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\nimport { IModule } from \"../../IModule.sol\";\n\n/**\n * @title IModuleInstallationSystem\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface is automatically generated from the corresponding system contract. Do not edit manually.\n */\ninterface IModuleInstallationSystem {\n  function installModule(IModule module, bytes memory encodedArgs) external;\n}\n"},"node_modules/@latticexyz/world/src/codegen/interfaces/IWorldRegistrationSystem.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\nimport { ResourceId } from \"@latticexyz/store/src/ResourceId.sol\";\nimport { ISystemHook } from \"../../ISystemHook.sol\";\nimport { System } from \"../../System.sol\";\n\n/**\n * @title IWorldRegistrationSystem\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface is automatically generated from the corresponding system contract. Do not edit manually.\n */\ninterface IWorldRegistrationSystem {\n  function registerNamespace(ResourceId namespaceId) external;\n\n  function registerSystemHook(ResourceId systemId, ISystemHook hookAddress, uint8 enabledHooksBitmap) external;\n\n  function unregisterSystemHook(ResourceId systemId, ISystemHook hookAddress) external;\n\n  function registerSystem(ResourceId systemId, System system, bool publicAccess) external;\n\n  function registerFunctionSelector(\n    ResourceId systemId,\n    string memory systemFunctionSignature\n  ) external returns (bytes4 worldFunctionSelector);\n\n  function registerRootFunctionSelector(\n    ResourceId systemId,\n    string memory worldFunctionSignature,\n    string memory systemFunctionSignature\n  ) external returns (bytes4 worldFunctionSelector);\n\n  function registerDelegation(address delegatee, ResourceId delegationControlId, bytes memory initCallData) external;\n\n  function unregisterDelegation(address delegatee) external;\n\n  function registerNamespaceDelegation(\n    ResourceId namespaceId,\n    ResourceId delegationControlId,\n    bytes memory initCallData\n  ) external;\n\n  function unregisterNamespaceDelegation(ResourceId namespaceId) external;\n}\n"},"node_modules/@latticexyz/store/src/Bytes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title Bytes\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Utility functions for bytes.\n */\nlibrary Bytes {\n  /************************************************************************\n   *\n   *    UTILS\n   *\n   ************************************************************************/\n\n  /**\n   * @dev Sets the length of a bytes blob in memory.\n   * This function does not resize the memory allocation; it only changes the length\n   * field, which affects operations that access the length property.\n   * @param input The bytes blob to modify.\n   * @param length The new length to set.\n   * @return Reference to the input bytes blob with modified length.\n   */\n  function setLength(bytes memory input, uint256 length) internal pure returns (bytes memory) {\n    assembly {\n      mstore(input, length)\n    }\n    return input;\n  }\n\n  /************************************************************************\n   *\n   *    SET\n   *\n   ************************************************************************/\n\n  /**\n   * @dev Sets a specific 4-byte sequence in a bytes blob at a given index.\n   * @param input The bytes blob in which a specific 4-byte sequence is to be altered.\n   * @param index The position within the bytes blob to start altering the 4-byte sequence. Index starts from the left.\n   * @param overwrite The new 4-byte value to be set at the specified index.\n   * @return The modified bytes blob with the new 4-byte value at the specified index.\n   */\n  function setBytes4(bytes memory input, uint256 index, bytes4 overwrite) internal pure returns (bytes memory) {\n    bytes4 mask = 0xffffffff;\n    assembly {\n      let value := mload(add(add(input, 0x20), index)) // load 32 bytes from input starting at offset\n      value := and(value, not(mask)) // zero out the first 4 bytes\n      value := or(value, overwrite) // set the bytes at the offset\n      mstore(add(add(input, 0x20), index), value) // store the new value\n    }\n    return input;\n  }\n\n  /************************************************************************\n   *\n   *    GET\n   *\n   *    Used by codegen libraries\n   *\n   ************************************************************************/\n\n  /**\n   * @dev Extracts a single byte from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a byte is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes1 value from the specified position in the bytes blob.\n   */\n  function getBytes1(bytes memory data, uint256 start) internal pure returns (bytes1 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a single byte from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a byte is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes1 value from the specified position in the bytes32 value.\n   */\n  function getBytes1(bytes32 data, uint256 start) internal pure returns (bytes1 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 2-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 2-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes2 value from the specified position in the bytes blob.\n   */\n  function getBytes2(bytes memory data, uint256 start) internal pure returns (bytes2 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 2-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 2-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes2 value from the specified position in the bytes32 value.\n   */\n  function getBytes2(bytes32 data, uint256 start) internal pure returns (bytes2 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 3-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 3-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes3 value from the specified position in the bytes blob.\n   */\n  function getBytes3(bytes memory data, uint256 start) internal pure returns (bytes3 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 3-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 3-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes3 value from the specified position in the bytes32 value.\n   */\n  function getBytes3(bytes32 data, uint256 start) internal pure returns (bytes3 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 4-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 4-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes4 value from the specified position in the bytes blob.\n   */\n  function getBytes4(bytes memory data, uint256 start) internal pure returns (bytes4 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 4-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 4-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes4 value from the specified position in the bytes32 value.\n   */\n  function getBytes4(bytes32 data, uint256 start) internal pure returns (bytes4 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 5-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 5-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes5 value from the specified position in the bytes blob.\n   */\n  function getBytes5(bytes memory data, uint256 start) internal pure returns (bytes5 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 5-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 5-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes5 value from the specified position in the bytes32 value.\n   */\n  function getBytes5(bytes32 data, uint256 start) internal pure returns (bytes5 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 6-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 6-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes6 value from the specified position in the bytes blob.\n   */\n  function getBytes6(bytes memory data, uint256 start) internal pure returns (bytes6 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 6-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 6-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes6 value from the specified position in the bytes32 value.\n   */\n  function getBytes6(bytes32 data, uint256 start) internal pure returns (bytes6 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 7-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 7-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes7 value from the specified position in the bytes blob.\n   */\n  function getBytes7(bytes memory data, uint256 start) internal pure returns (bytes7 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 7-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 7-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes7 value from the specified position in the bytes32 value.\n   */\n  function getBytes7(bytes32 data, uint256 start) internal pure returns (bytes7 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 8-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 8-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes8 value from the specified position in the bytes blob.\n   */\n  function getBytes8(bytes memory data, uint256 start) internal pure returns (bytes8 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 8-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 8-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes8 value from the specified position in the bytes32 value.\n   */\n  function getBytes8(bytes32 data, uint256 start) internal pure returns (bytes8 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 9-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 9-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes9 value from the specified position in the bytes blob.\n   */\n  function getBytes9(bytes memory data, uint256 start) internal pure returns (bytes9 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 9-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 9-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes9 value from the specified position in the bytes32 value.\n   */\n  function getBytes9(bytes32 data, uint256 start) internal pure returns (bytes9 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 10-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 10-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes10 value from the specified position in the bytes blob.\n   */\n  function getBytes10(bytes memory data, uint256 start) internal pure returns (bytes10 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 10-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 10-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes10 value from the specified position in the bytes32 value.\n   */\n  function getBytes10(bytes32 data, uint256 start) internal pure returns (bytes10 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 11-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 11-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes11 value from the specified position in the bytes blob.\n   */\n  function getBytes11(bytes memory data, uint256 start) internal pure returns (bytes11 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 11-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 11-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes11 value from the specified position in the bytes32 value.\n   */\n  function getBytes11(bytes32 data, uint256 start) internal pure returns (bytes11 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 12-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 12-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes12 value from the specified position in the bytes blob.\n   */\n  function getBytes12(bytes memory data, uint256 start) internal pure returns (bytes12 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 12-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 12-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes12 value from the specified position in the bytes32 value.\n   */\n  function getBytes12(bytes32 data, uint256 start) internal pure returns (bytes12 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 13-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 13-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes13 value from the specified position in the bytes blob.\n   */\n  function getBytes13(bytes memory data, uint256 start) internal pure returns (bytes13 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 13-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 13-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes13 value from the specified position in the bytes32 value.\n   */\n  function getBytes13(bytes32 data, uint256 start) internal pure returns (bytes13 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 14-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 14-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes14 value from the specified position in the bytes blob.\n   */\n  function getBytes14(bytes memory data, uint256 start) internal pure returns (bytes14 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 14-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 14-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes14 value from the specified position in the bytes32 value.\n   */\n  function getBytes14(bytes32 data, uint256 start) internal pure returns (bytes14 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 15-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 15-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes15 value from the specified position in the bytes blob.\n   */\n  function getBytes15(bytes memory data, uint256 start) internal pure returns (bytes15 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 15-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 15-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes15 value from the specified position in the bytes32 value.\n   */\n  function getBytes15(bytes32 data, uint256 start) internal pure returns (bytes15 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 16-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 16-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes16 value from the specified position in the bytes blob.\n   */\n  function getBytes16(bytes memory data, uint256 start) internal pure returns (bytes16 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 16-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 16-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes16 value from the specified position in the bytes32 value.\n   */\n  function getBytes16(bytes32 data, uint256 start) internal pure returns (bytes16 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 17-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 17-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes17 value from the specified position in the bytes blob.\n   */\n  function getBytes17(bytes memory data, uint256 start) internal pure returns (bytes17 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 17-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 17-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes17 value from the specified position in the bytes32 value.\n   */\n  function getBytes17(bytes32 data, uint256 start) internal pure returns (bytes17 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 18-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 18-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes18 value from the specified position in the bytes blob.\n   */\n  function getBytes18(bytes memory data, uint256 start) internal pure returns (bytes18 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 18-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 18-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes18 value from the specified position in the bytes32 value.\n   */\n  function getBytes18(bytes32 data, uint256 start) internal pure returns (bytes18 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 19-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 19-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes19 value from the specified position in the bytes blob.\n   */\n  function getBytes19(bytes memory data, uint256 start) internal pure returns (bytes19 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 19-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 19-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes19 value from the specified position in the bytes32 value.\n   */\n  function getBytes19(bytes32 data, uint256 start) internal pure returns (bytes19 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 20-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 20-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes20 value from the specified position in the bytes blob.\n   */\n  function getBytes20(bytes memory data, uint256 start) internal pure returns (bytes20 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 20-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 20-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes20 value from the specified position in the bytes32 value.\n   */\n  function getBytes20(bytes32 data, uint256 start) internal pure returns (bytes20 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 21-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 21-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes21 value from the specified position in the bytes blob.\n   */\n  function getBytes21(bytes memory data, uint256 start) internal pure returns (bytes21 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 21-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 21-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes21 value from the specified position in the bytes32 value.\n   */\n  function getBytes21(bytes32 data, uint256 start) internal pure returns (bytes21 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 22-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 22-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes22 value from the specified position in the bytes blob.\n   */\n  function getBytes22(bytes memory data, uint256 start) internal pure returns (bytes22 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 22-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 22-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes22 value from the specified position in the bytes32 value.\n   */\n  function getBytes22(bytes32 data, uint256 start) internal pure returns (bytes22 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 23-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 23-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes23 value from the specified position in the bytes blob.\n   */\n  function getBytes23(bytes memory data, uint256 start) internal pure returns (bytes23 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 23-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 23-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes23 value from the specified position in the bytes32 value.\n   */\n  function getBytes23(bytes32 data, uint256 start) internal pure returns (bytes23 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 24-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 24-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes24 value from the specified position in the bytes blob.\n   */\n  function getBytes24(bytes memory data, uint256 start) internal pure returns (bytes24 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 24-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 24-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes24 value from the specified position in the bytes32 value.\n   */\n  function getBytes24(bytes32 data, uint256 start) internal pure returns (bytes24 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 25-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 25-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes25 value from the specified position in the bytes blob.\n   */\n  function getBytes25(bytes memory data, uint256 start) internal pure returns (bytes25 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 25-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 25-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes25 value from the specified position in the bytes32 value.\n   */\n  function getBytes25(bytes32 data, uint256 start) internal pure returns (bytes25 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 26-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 26-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes26 value from the specified position in the bytes blob.\n   */\n  function getBytes26(bytes memory data, uint256 start) internal pure returns (bytes26 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 26-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 26-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes26 value from the specified position in the bytes32 value.\n   */\n  function getBytes26(bytes32 data, uint256 start) internal pure returns (bytes26 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 27-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 27-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes27 value from the specified position in the bytes blob.\n   */\n  function getBytes27(bytes memory data, uint256 start) internal pure returns (bytes27 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 27-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 27-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes27 value from the specified position in the bytes32 value.\n   */\n  function getBytes27(bytes32 data, uint256 start) internal pure returns (bytes27 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 28-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 28-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes28 value from the specified position in the bytes blob.\n   */\n  function getBytes28(bytes memory data, uint256 start) internal pure returns (bytes28 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 28-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 28-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes28 value from the specified position in the bytes32 value.\n   */\n  function getBytes28(bytes32 data, uint256 start) internal pure returns (bytes28 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 29-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 29-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes29 value from the specified position in the bytes blob.\n   */\n  function getBytes29(bytes memory data, uint256 start) internal pure returns (bytes29 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 29-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 29-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes29 value from the specified position in the bytes32 value.\n   */\n  function getBytes29(bytes32 data, uint256 start) internal pure returns (bytes29 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 30-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 30-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes30 value from the specified position in the bytes blob.\n   */\n  function getBytes30(bytes memory data, uint256 start) internal pure returns (bytes30 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 30-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 30-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes30 value from the specified position in the bytes32 value.\n   */\n  function getBytes30(bytes32 data, uint256 start) internal pure returns (bytes30 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 31-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 31-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes31 value from the specified position in the bytes blob.\n   */\n  function getBytes31(bytes memory data, uint256 start) internal pure returns (bytes31 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 31-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 31-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes31 value from the specified position in the bytes32 value.\n   */\n  function getBytes31(bytes32 data, uint256 start) internal pure returns (bytes31 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n\n  /**\n   * @dev Extracts a 32-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 32-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return output The extracted bytes32 value from the specified position in the bytes blob.\n   */\n  function getBytes32(bytes memory data, uint256 start) internal pure returns (bytes32 output) {\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n  }\n\n  /**\n   * @dev Extracts a 32-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 32-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return output The extracted bytes32 value from the specified position in the bytes32 value.\n   */\n  function getBytes32(bytes32 data, uint256 start) internal pure returns (bytes32 output) {\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n  }\n}\n"},"node_modules/@latticexyz/store/src/Memory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { rightMask } from \"./rightMask.sol\";\n\n/**\n * @title Memory Operations\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice A library for performing low-level memory operations.\n * @dev This library provides low-level memory operations with safety checks.\n */\nlibrary Memory {\n  /**\n   * @notice Gets the actual data pointer of dynamic arrays.\n   * @dev In dynamic arrays, the first word stores the length of the data, after which comes the actual data.\n   * Example: 0x40 0x01 0x02\n   *          ^len ^data\n   * @param data The dynamic bytes data from which to get the pointer.\n   * @return memoryPointer The pointer to the actual data (skipping the length).\n   */\n  function dataPointer(bytes memory data) internal pure returns (uint256 memoryPointer) {\n    assembly {\n      memoryPointer := add(data, 0x20)\n    }\n  }\n\n  /**\n   * @notice Copies memory from one location to another.\n   * @dev Safely copies memory in chunks of 32 bytes, then handles any residual bytes.\n   * @param fromPointer The memory location to copy from.\n   * @param toPointer The memory location to copy to.\n   * @param length The number of bytes to copy.\n   */\n  function copy(uint256 fromPointer, uint256 toPointer, uint256 length) internal pure {\n    // Copy 32-byte chunks\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(toPointer, mload(fromPointer))\n      }\n      // Safe because total addition will be <= length (ptr+len is implicitly safe)\n      unchecked {\n        toPointer += 32;\n        fromPointer += 32;\n        length -= 32;\n      }\n    }\n    if (length == 0) return;\n\n    // Copy the 0-31 length tail\n    uint256 mask = rightMask(length);\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(\n        toPointer,\n        or(\n          // store the left part\n          and(mload(fromPointer), not(mask)),\n          // preserve the right part\n          and(mload(toPointer), mask)\n        )\n      )\n    }\n  }\n}\n"},"node_modules/@latticexyz/store/src/Slice.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { Memory } from \"./Memory.sol\";\nimport { DecodeSlice } from \"./tightcoder/DecodeSlice.sol\";\nimport { ISliceErrors } from \"./ISliceErrors.sol\";\n\n// Acknowledgements:\n// Based on @dk1a's Slice.sol library (https://github.com/dk1a/solidity-stringutils/blob/main/src/Slice.sol)\n\n// First 16 bytes are the pointer to the data, followed by 16 bytes of data length.\ntype Slice is uint256;\n\nusing SliceInstance for Slice global;\nusing DecodeSlice for Slice global;\n\n/**\n * @title Static functions for Slice\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n */\nlibrary SliceLib {\n  uint256 constant MASK_LEN = uint256(type(uint128).max);\n\n  /**\n   * @notice Converts a bytes array to a slice (without copying data)\n   * @param data The bytes array to be converted\n   * @return A new Slice representing the bytes array\n   */\n  function fromBytes(bytes memory data) internal pure returns (Slice) {\n    uint256 pointer;\n    assembly {\n      pointer := add(data, 0x20) // pointer to first data byte\n    }\n\n    // Pointer is stored in upper 128 bits, length is stored in lower 128 bits\n    return Slice.wrap((pointer << 128) | (data.length & MASK_LEN));\n  }\n\n  /**\n   * @notice Subslice a bytes array using the given start index until the end of the array (without copying data)\n   * @param data The bytes array to subslice\n   * @param start The start index for the subslice\n   * @return A new Slice representing the subslice\n   */\n  function getSubslice(bytes memory data, uint256 start) internal pure returns (Slice) {\n    return getSubslice(data, start, data.length);\n  }\n\n  /**\n   * @notice Subslice a bytes array using the given indexes (without copying data)\n   * @dev The start index is inclusive, the end index is exclusive\n   * @param data The bytes array to subslice\n   * @param start The start index for the subslice\n   * @param end The end index for the subslice\n   * @return A new Slice representing the subslice\n   */\n  function getSubslice(bytes memory data, uint256 start, uint256 end) internal pure returns (Slice) {\n    // TODO this check helps catch bugs and can eventually be removed\n    if (start > end || end > data.length) revert ISliceErrors.Slice_OutOfBounds(data, start, end);\n\n    uint256 pointer;\n    assembly {\n      pointer := add(data, 0x20) // pointer to first data byte\n    }\n\n    pointer += start;\n    uint256 _len = end - start;\n\n    // Pointer is stored in upper 128 bits, length is stored in lower 128 bits\n    return Slice.wrap((pointer << 128) | (_len & MASK_LEN));\n  }\n}\n\n/**\n * @title Instance functions for Slice\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n */\nlibrary SliceInstance {\n  /**\n   * @notice Returns the pointer to the start of a slice\n   * @param self The slice whose pointer needs to be fetched\n   * @return The pointer to the start of the slice\n   */\n  function pointer(Slice self) internal pure returns (uint256) {\n    return Slice.unwrap(self) >> 128;\n  }\n\n  /**\n   * @notice Returns the slice length in bytes\n   * @param self The slice whose length needs to be fetched\n   * @return The length of the slice\n   */\n  function length(Slice self) internal pure returns (uint256) {\n    return Slice.unwrap(self) & SliceLib.MASK_LEN;\n  }\n\n  /**\n   * @notice Converts a Slice to bytes\n   * @dev This function internally manages the conversion of a slice into a bytes format.\n   * @param self The Slice to be converted to bytes.\n   * @return data The bytes representation of the provided Slice.\n   */\n  function toBytes(Slice self) internal pure returns (bytes memory data) {\n    uint256 fromPointer = pointer(self);\n    uint256 _length = length(self);\n\n    // Allocate a new bytes array and get the pointer to it\n    data = new bytes(_length);\n    uint256 toPointer;\n    assembly {\n      toPointer := add(data, 0x20)\n    }\n    // Copy the slice contents to the array\n    Memory.copy(fromPointer, toPointer, _length);\n  }\n\n  /**\n   * @notice Converts a Slice to bytes32\n   * @dev This function converts a slice into a fixed-length bytes32. Uses inline assembly for the conversion.\n   * @param self The Slice to be converted to bytes32.\n   * @return result The bytes32 representation of the provided Slice.\n   */\n  function toBytes32(Slice self) internal pure returns (bytes32 result) {\n    uint256 memoryPointer = pointer(self);\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := mload(memoryPointer)\n    }\n    return result;\n  }\n}\n"},"node_modules/@latticexyz/store/src/tightcoder/EncodeArray.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\nimport { TightCoder } from \"./TightCoder.sol\";\n\n/**\n * @title EncodeArray\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This library provides utilities for encoding arrays into tightly packed bytes representations.\n */\nlibrary EncodeArray {\n  /**\n   * @notice Encodes an array of uint8 into a tightly packed bytes representation.\n   * @param _input The array of uint8 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint8[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 1, 248);\n  }\n\n  /**\n   * @notice Encodes an array of uint16 into a tightly packed bytes representation.\n   * @param _input The array of uint16 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint16[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 2, 240);\n  }\n\n  /**\n   * @notice Encodes an array of uint24 into a tightly packed bytes representation.\n   * @param _input The array of uint24 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint24[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 3, 232);\n  }\n\n  /**\n   * @notice Encodes an array of uint32 into a tightly packed bytes representation.\n   * @param _input The array of uint32 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint32[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 4, 224);\n  }\n\n  /**\n   * @notice Encodes an array of uint40 into a tightly packed bytes representation.\n   * @param _input The array of uint40 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint40[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 5, 216);\n  }\n\n  /**\n   * @notice Encodes an array of uint48 into a tightly packed bytes representation.\n   * @param _input The array of uint48 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint48[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 6, 208);\n  }\n\n  /**\n   * @notice Encodes an array of uint56 into a tightly packed bytes representation.\n   * @param _input The array of uint56 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint56[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 7, 200);\n  }\n\n  /**\n   * @notice Encodes an array of uint64 into a tightly packed bytes representation.\n   * @param _input The array of uint64 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint64[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 8, 192);\n  }\n\n  /**\n   * @notice Encodes an array of uint72 into a tightly packed bytes representation.\n   * @param _input The array of uint72 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint72[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 9, 184);\n  }\n\n  /**\n   * @notice Encodes an array of uint80 into a tightly packed bytes representation.\n   * @param _input The array of uint80 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint80[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 10, 176);\n  }\n\n  /**\n   * @notice Encodes an array of uint88 into a tightly packed bytes representation.\n   * @param _input The array of uint88 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint88[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 11, 168);\n  }\n\n  /**\n   * @notice Encodes an array of uint96 into a tightly packed bytes representation.\n   * @param _input The array of uint96 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint96[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 12, 160);\n  }\n\n  /**\n   * @notice Encodes an array of uint104 into a tightly packed bytes representation.\n   * @param _input The array of uint104 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint104[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 13, 152);\n  }\n\n  /**\n   * @notice Encodes an array of uint112 into a tightly packed bytes representation.\n   * @param _input The array of uint112 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint112[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 14, 144);\n  }\n\n  /**\n   * @notice Encodes an array of uint120 into a tightly packed bytes representation.\n   * @param _input The array of uint120 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint120[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 15, 136);\n  }\n\n  /**\n   * @notice Encodes an array of uint128 into a tightly packed bytes representation.\n   * @param _input The array of uint128 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint128[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 16, 128);\n  }\n\n  /**\n   * @notice Encodes an array of uint136 into a tightly packed bytes representation.\n   * @param _input The array of uint136 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint136[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 17, 120);\n  }\n\n  /**\n   * @notice Encodes an array of uint144 into a tightly packed bytes representation.\n   * @param _input The array of uint144 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint144[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 18, 112);\n  }\n\n  /**\n   * @notice Encodes an array of uint152 into a tightly packed bytes representation.\n   * @param _input The array of uint152 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint152[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 19, 104);\n  }\n\n  /**\n   * @notice Encodes an array of uint160 into a tightly packed bytes representation.\n   * @param _input The array of uint160 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint160[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 20, 96);\n  }\n\n  /**\n   * @notice Encodes an array of uint168 into a tightly packed bytes representation.\n   * @param _input The array of uint168 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint168[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 21, 88);\n  }\n\n  /**\n   * @notice Encodes an array of uint176 into a tightly packed bytes representation.\n   * @param _input The array of uint176 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint176[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 22, 80);\n  }\n\n  /**\n   * @notice Encodes an array of uint184 into a tightly packed bytes representation.\n   * @param _input The array of uint184 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint184[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 23, 72);\n  }\n\n  /**\n   * @notice Encodes an array of uint192 into a tightly packed bytes representation.\n   * @param _input The array of uint192 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint192[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 24, 64);\n  }\n\n  /**\n   * @notice Encodes an array of uint200 into a tightly packed bytes representation.\n   * @param _input The array of uint200 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint200[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 25, 56);\n  }\n\n  /**\n   * @notice Encodes an array of uint208 into a tightly packed bytes representation.\n   * @param _input The array of uint208 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint208[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 26, 48);\n  }\n\n  /**\n   * @notice Encodes an array of uint216 into a tightly packed bytes representation.\n   * @param _input The array of uint216 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint216[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 27, 40);\n  }\n\n  /**\n   * @notice Encodes an array of uint224 into a tightly packed bytes representation.\n   * @param _input The array of uint224 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint224[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 28, 32);\n  }\n\n  /**\n   * @notice Encodes an array of uint232 into a tightly packed bytes representation.\n   * @param _input The array of uint232 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint232[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 29, 24);\n  }\n\n  /**\n   * @notice Encodes an array of uint240 into a tightly packed bytes representation.\n   * @param _input The array of uint240 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint240[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 30, 16);\n  }\n\n  /**\n   * @notice Encodes an array of uint248 into a tightly packed bytes representation.\n   * @param _input The array of uint248 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint248[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 31, 8);\n  }\n\n  /**\n   * @notice Encodes an array of uint256 into a tightly packed bytes representation.\n   * @param _input The array of uint256 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(uint256[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 32, 0);\n  }\n\n  /**\n   * @notice Encodes an array of int8 into a tightly packed bytes representation.\n   * @param _input The array of int8 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int8[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 1, 248);\n  }\n\n  /**\n   * @notice Encodes an array of int16 into a tightly packed bytes representation.\n   * @param _input The array of int16 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int16[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 2, 240);\n  }\n\n  /**\n   * @notice Encodes an array of int24 into a tightly packed bytes representation.\n   * @param _input The array of int24 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int24[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 3, 232);\n  }\n\n  /**\n   * @notice Encodes an array of int32 into a tightly packed bytes representation.\n   * @param _input The array of int32 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int32[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 4, 224);\n  }\n\n  /**\n   * @notice Encodes an array of int40 into a tightly packed bytes representation.\n   * @param _input The array of int40 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int40[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 5, 216);\n  }\n\n  /**\n   * @notice Encodes an array of int48 into a tightly packed bytes representation.\n   * @param _input The array of int48 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int48[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 6, 208);\n  }\n\n  /**\n   * @notice Encodes an array of int56 into a tightly packed bytes representation.\n   * @param _input The array of int56 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int56[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 7, 200);\n  }\n\n  /**\n   * @notice Encodes an array of int64 into a tightly packed bytes representation.\n   * @param _input The array of int64 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int64[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 8, 192);\n  }\n\n  /**\n   * @notice Encodes an array of int72 into a tightly packed bytes representation.\n   * @param _input The array of int72 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int72[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 9, 184);\n  }\n\n  /**\n   * @notice Encodes an array of int80 into a tightly packed bytes representation.\n   * @param _input The array of int80 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int80[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 10, 176);\n  }\n\n  /**\n   * @notice Encodes an array of int88 into a tightly packed bytes representation.\n   * @param _input The array of int88 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int88[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 11, 168);\n  }\n\n  /**\n   * @notice Encodes an array of int96 into a tightly packed bytes representation.\n   * @param _input The array of int96 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int96[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 12, 160);\n  }\n\n  /**\n   * @notice Encodes an array of int104 into a tightly packed bytes representation.\n   * @param _input The array of int104 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int104[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 13, 152);\n  }\n\n  /**\n   * @notice Encodes an array of int112 into a tightly packed bytes representation.\n   * @param _input The array of int112 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int112[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 14, 144);\n  }\n\n  /**\n   * @notice Encodes an array of int120 into a tightly packed bytes representation.\n   * @param _input The array of int120 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int120[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 15, 136);\n  }\n\n  /**\n   * @notice Encodes an array of int128 into a tightly packed bytes representation.\n   * @param _input The array of int128 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int128[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 16, 128);\n  }\n\n  /**\n   * @notice Encodes an array of int136 into a tightly packed bytes representation.\n   * @param _input The array of int136 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int136[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 17, 120);\n  }\n\n  /**\n   * @notice Encodes an array of int144 into a tightly packed bytes representation.\n   * @param _input The array of int144 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int144[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 18, 112);\n  }\n\n  /**\n   * @notice Encodes an array of int152 into a tightly packed bytes representation.\n   * @param _input The array of int152 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int152[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 19, 104);\n  }\n\n  /**\n   * @notice Encodes an array of int160 into a tightly packed bytes representation.\n   * @param _input The array of int160 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int160[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 20, 96);\n  }\n\n  /**\n   * @notice Encodes an array of int168 into a tightly packed bytes representation.\n   * @param _input The array of int168 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int168[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 21, 88);\n  }\n\n  /**\n   * @notice Encodes an array of int176 into a tightly packed bytes representation.\n   * @param _input The array of int176 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int176[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 22, 80);\n  }\n\n  /**\n   * @notice Encodes an array of int184 into a tightly packed bytes representation.\n   * @param _input The array of int184 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int184[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 23, 72);\n  }\n\n  /**\n   * @notice Encodes an array of int192 into a tightly packed bytes representation.\n   * @param _input The array of int192 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int192[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 24, 64);\n  }\n\n  /**\n   * @notice Encodes an array of int200 into a tightly packed bytes representation.\n   * @param _input The array of int200 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int200[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 25, 56);\n  }\n\n  /**\n   * @notice Encodes an array of int208 into a tightly packed bytes representation.\n   * @param _input The array of int208 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int208[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 26, 48);\n  }\n\n  /**\n   * @notice Encodes an array of int216 into a tightly packed bytes representation.\n   * @param _input The array of int216 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int216[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 27, 40);\n  }\n\n  /**\n   * @notice Encodes an array of int224 into a tightly packed bytes representation.\n   * @param _input The array of int224 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int224[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 28, 32);\n  }\n\n  /**\n   * @notice Encodes an array of int232 into a tightly packed bytes representation.\n   * @param _input The array of int232 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int232[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 29, 24);\n  }\n\n  /**\n   * @notice Encodes an array of int240 into a tightly packed bytes representation.\n   * @param _input The array of int240 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int240[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 30, 16);\n  }\n\n  /**\n   * @notice Encodes an array of int248 into a tightly packed bytes representation.\n   * @param _input The array of int248 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int248[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 31, 8);\n  }\n\n  /**\n   * @notice Encodes an array of int256 into a tightly packed bytes representation.\n   * @param _input The array of int256 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(int256[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 32, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes1 into a tightly packed bytes representation.\n   * @param _input The array of bytes1 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes1[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 1, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes2 into a tightly packed bytes representation.\n   * @param _input The array of bytes2 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes2[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 2, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes3 into a tightly packed bytes representation.\n   * @param _input The array of bytes3 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes3[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 3, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes4 into a tightly packed bytes representation.\n   * @param _input The array of bytes4 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes4[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 4, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes5 into a tightly packed bytes representation.\n   * @param _input The array of bytes5 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes5[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 5, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes6 into a tightly packed bytes representation.\n   * @param _input The array of bytes6 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes6[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 6, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes7 into a tightly packed bytes representation.\n   * @param _input The array of bytes7 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes7[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 7, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes8 into a tightly packed bytes representation.\n   * @param _input The array of bytes8 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes8[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 8, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes9 into a tightly packed bytes representation.\n   * @param _input The array of bytes9 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes9[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 9, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes10 into a tightly packed bytes representation.\n   * @param _input The array of bytes10 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes10[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 10, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes11 into a tightly packed bytes representation.\n   * @param _input The array of bytes11 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes11[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 11, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes12 into a tightly packed bytes representation.\n   * @param _input The array of bytes12 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes12[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 12, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes13 into a tightly packed bytes representation.\n   * @param _input The array of bytes13 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes13[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 13, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes14 into a tightly packed bytes representation.\n   * @param _input The array of bytes14 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes14[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 14, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes15 into a tightly packed bytes representation.\n   * @param _input The array of bytes15 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes15[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 15, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes16 into a tightly packed bytes representation.\n   * @param _input The array of bytes16 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes16[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 16, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes17 into a tightly packed bytes representation.\n   * @param _input The array of bytes17 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes17[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 17, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes18 into a tightly packed bytes representation.\n   * @param _input The array of bytes18 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes18[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 18, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes19 into a tightly packed bytes representation.\n   * @param _input The array of bytes19 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes19[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 19, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes20 into a tightly packed bytes representation.\n   * @param _input The array of bytes20 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes20[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 20, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes21 into a tightly packed bytes representation.\n   * @param _input The array of bytes21 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes21[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 21, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes22 into a tightly packed bytes representation.\n   * @param _input The array of bytes22 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes22[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 22, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes23 into a tightly packed bytes representation.\n   * @param _input The array of bytes23 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes23[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 23, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes24 into a tightly packed bytes representation.\n   * @param _input The array of bytes24 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes24[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 24, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes25 into a tightly packed bytes representation.\n   * @param _input The array of bytes25 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes25[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 25, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes26 into a tightly packed bytes representation.\n   * @param _input The array of bytes26 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes26[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 26, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes27 into a tightly packed bytes representation.\n   * @param _input The array of bytes27 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes27[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 27, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes28 into a tightly packed bytes representation.\n   * @param _input The array of bytes28 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes28[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 28, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes29 into a tightly packed bytes representation.\n   * @param _input The array of bytes29 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes29[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 29, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes30 into a tightly packed bytes representation.\n   * @param _input The array of bytes30 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes30[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 30, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes31 into a tightly packed bytes representation.\n   * @param _input The array of bytes31 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes31[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 31, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bytes32 into a tightly packed bytes representation.\n   * @param _input The array of bytes32 values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bytes32[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 32, 0);\n  }\n\n  /**\n   * @notice Encodes an array of bool into a tightly packed bytes representation.\n   * @param _input The array of bool values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(bool[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 1, 248);\n  }\n\n  /**\n   * @notice Encodes an array of address into a tightly packed bytes representation.\n   * @param _input The array of address values to be encoded.\n   * @return The resulting tightly packed bytes representation of the input array.\n   */\n  function encode(address[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 20, 96);\n  }\n}\n"},"node_modules/@latticexyz/world/src/constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { ResourceId } from \"@latticexyz/store/src/ResourceId.sol\";\n\nimport { RESOURCE_SYSTEM, RESOURCE_NAMESPACE } from \"./worldResourceTypes.sol\";\n\nbytes14 constant ROOT_NAMESPACE = \"\";\nbytes16 constant ROOT_NAME = \"\";\n\nResourceId constant STORE_NAMESPACE_ID = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_NAMESPACE, bytes14(\"store\"), ROOT_NAME))\n);\n\nResourceId constant WORLD_NAMESPACE_ID = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_NAMESPACE, bytes14(\"world\"), ROOT_NAME))\n);\n\nResourceId constant ROOT_NAMESPACE_ID = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_NAMESPACE, ROOT_NAMESPACE, ROOT_NAME))\n);\n\nResourceId constant UNLIMITED_DELEGATION = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_SYSTEM, ROOT_NAMESPACE, bytes16(\"unlimited\")))\n);\n"},"node_modules/@latticexyz/world/src/worldResourceTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"@latticexyz/store/src/storeResourceTypes.sol\";\n\n/**\n * @dev Constants used to work with world resource types.\n */\n\n// Resource that identifies a namespace, a container belonging to a\n// specific address (not necessarily the original deployer of the World).\n// A namespace can include tables and systems.\nbytes2 constant RESOURCE_NAMESPACE = \"ns\";\n\n// Resource that identifies a system, a contract used to manipulate\n// the state.\nbytes2 constant RESOURCE_SYSTEM = \"sy\";\n\n// Masks used to filter or match a specific resource type\nbytes32 constant MASK_RESOURCE_NAMESPACE = bytes32(RESOURCE_NAMESPACE);\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"node_modules/@openzeppelin/contracts/utils/Panic.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"},"node_modules/@latticexyz/store/src/IStoreKernel.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { IStoreRead } from \"./IStoreRead.sol\";\nimport { IStoreWrite } from \"./IStoreWrite.sol\";\nimport { IStoreErrors } from \"./IStoreErrors.sol\";\nimport { IFieldLayoutErrors } from \"./IFieldLayoutErrors.sol\";\nimport { IEncodedLengthsErrors } from \"./IEncodedLengthsErrors.sol\";\nimport { ISchemaErrors } from \"./ISchemaErrors.sol\";\nimport { ISliceErrors } from \"./ISliceErrors.sol\";\n\n/**\n * @title IStoreKernel\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice IStoreKernel includes the error interfaces for each library that it uses.\n */\ninterface IStoreKernel is\n  IStoreRead,\n  IStoreWrite,\n  IStoreErrors,\n  IFieldLayoutErrors,\n  IEncodedLengthsErrors,\n  ISchemaErrors,\n  ISliceErrors\n{\n  /**\n   * @notice Returns the protocol version of the Store contract.\n   * @return version The protocol version of the Store contract.\n   */\n  function storeVersion() external view returns (bytes32 version);\n}\n"},"node_modules/@latticexyz/store/src/IStoreRegistration.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { Schema } from \"./Schema.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n/**\n * @title IStoreRegistration\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface includes methods for managing table field layouts, metadata, and hooks, which are usually called once in the setup phase of an application, making them less performance critical than the methods.\n */\ninterface IStoreRegistration {\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] calldata keyNames,\n    string[] calldata fieldNames\n  ) external;\n\n  // Register hook to be called when a record or field is set or deleted\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) external;\n\n  // Unregister a hook for the given tableId\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) external;\n}\n"},"node_modules/@latticexyz/store/src/constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title Shared constants for EVM and schema handling\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This file provides constants for better handling of EVM and Schema related functionalities.\n */\n\n/// @dev Represents the total byte length of an EVM word.\nuint256 constant WORD_SIZE = 32;\n\n/// @dev Represents the index of the last byte in an EVM word.\nuint256 constant WORD_LAST_INDEX = 31;\n\n/// @dev Represents the conversion constant from byte to bits.\nuint256 constant BYTE_TO_BITS = 8;\n\n/// @dev Represents the maximum number of fields a Schema can handle.\nuint256 constant MAX_TOTAL_FIELDS = 28;\n\n/// @dev Represents the maximum number of static fields in a FieldLayout.\nuint256 constant MAX_STATIC_FIELDS = 28;\n\n/// @dev Represents the maximum number of dynamic fields that can be packed in EncodedLengths.\nuint256 constant MAX_DYNAMIC_FIELDS = 5;\n\n/**\n * @title LayoutOffsets Library\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This library provides constant offsets for FieldLayout and Schema metadata.\n * @dev FieldLayout and Schema utilize the same offset values for metadata.\n */\nlibrary LayoutOffsets {\n  /// @notice Represents the total length offset within the EVM word.\n  uint256 internal constant TOTAL_LENGTH = (WORD_SIZE - 2) * BYTE_TO_BITS;\n\n  /// @notice Represents the number of static fields offset within the EVM word.\n  uint256 internal constant NUM_STATIC_FIELDS = (WORD_SIZE - 2 - 1) * BYTE_TO_BITS;\n\n  /// @notice Represents the number of dynamic fields offset within the EVM word.\n  uint256 internal constant NUM_DYNAMIC_FIELDS = (WORD_SIZE - 2 - 1 - 1) * BYTE_TO_BITS;\n}\n"},"node_modules/@latticexyz/store/src/IEncodedLengthsErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title IEncodedLengthsErrors\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This interface includes errors for the EncodedLengths library.\n * @dev We bundle these errors in an interface (instead of at the file-level or in their corresponding libraries) so they can be inherited by IStore.\n * This ensures that all possible errors are included in the IStore ABI for proper decoding in the frontend.\n */\ninterface IEncodedLengthsErrors {\n  /**\n   * @notice Error raised when the provided encoded lengths has an invalid length.\n   * @param length The length of the encoded lengths.\n   */\n  error EncodedLengths_InvalidLength(uint256 length);\n}\n"},"node_modules/@latticexyz/store/src/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n// See https://eips.ethereum.org/EIPS/eip-165\ninterface IERC165 {\n  /**\n   * @notice Query if a contract implements an interface\n   * @param interfaceID The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   * @return `true` if the contract implements `interfaceID` and\n   * `interfaceID` is not 0xffffffff, `false` otherwise\n   */\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"node_modules/@latticexyz/store/src/version.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title Store protocol version\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Contains a constant representing the version of the Store protocol.\n */\n\n/// @dev Identifier for the current Store protocol version.\nbytes32 constant STORE_VERSION = \"2.0.2\";\n"},"node_modules/@latticexyz/store/src/Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { rightMask } from \"./rightMask.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { BYTE_TO_BITS } from \"./constants.sol\";\n\n/**\n * @title Storage Library\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Provides functions for low-level storage manipulation, including storing and retrieving bytes.\n */\nlibrary Storage {\n  /**\n   * @notice Store a single word of data at a specific storage pointer.\n   * @param storagePointer The location to store the data.\n   * @param data The 32-byte word of data to store.\n   */\n  function store(uint256 storagePointer, bytes32 data) internal {\n    assembly {\n      sstore(storagePointer, data)\n    }\n  }\n\n  /**\n   * @notice Store bytes of data at a specific storage pointer and offset.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param data Bytes to store.\n   */\n  function store(uint256 storagePointer, uint256 offset, bytes memory data) internal {\n    store(storagePointer, offset, data.length, Memory.dataPointer(data));\n  }\n\n  /**\n   * @notice Stores raw bytes to storage at a given pointer, offset, and length, keeping the rest of the word intact.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the start of the data in memory.\n   * @param length Length of the data in bytes.\n   */\n  function store(uint256 storagePointer, uint256 offset, uint256 length, uint256 memoryPointer) internal {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = ~rightMask(length);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from memory and offset it to match storage\n          let bitOffset := mul(offset, BYTE_TO_BITS)\n          mask := shr(bitOffset, mask)\n          let offsetData := shr(bitOffset, mload(memoryPointer))\n\n          sstore(\n            storagePointer,\n            or(\n              // Store the middle part\n              and(offsetData, mask),\n              // Preserve the surrounding parts\n              and(sload(storagePointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Store full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, mload(memoryPointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = rightMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(\n          storagePointer,\n          or(\n            // store the left part\n            and(mload(memoryPointer), not(mask)),\n            // preserve the right part\n            and(sload(storagePointer), mask)\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Set multiple storage locations to zero.\n   * @param storagePointer The starting storage location.\n   * @param length The number of storage locations to set to zero, in bytes\n   */\n  function zero(uint256 storagePointer, uint256 length) internal {\n    // Ceil division to round up to the nearest word\n    uint256 limit = storagePointer + (length + 31) / 32;\n    while (storagePointer < limit) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, 0)\n        storagePointer := add(storagePointer, 1)\n      }\n    }\n  }\n\n  /**\n   * @notice Load a single word of data from a specific storage pointer.\n   * @param storagePointer The location to load the data from.\n   * @return word The loaded 32-byte word of data.\n   */\n  function load(uint256 storagePointer) internal view returns (bytes32 word) {\n    assembly {\n      word := sload(storagePointer)\n    }\n  }\n\n  /**\n   * @notice Load raw bytes from storage at a given pointer, offset, and length.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes of data.\n   */\n  function load(uint256 storagePointer, uint256 offset, uint256 length) internal view returns (bytes memory result) {\n    uint256 memoryPointer;\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 0x1F), not(0x1F))\n      }\n\n      // Allocate memory\n      result := mload(0x40)\n      memoryPointer := add(result, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(memoryPointer, length)))\n      // Store length\n      mstore(result, length)\n    }\n    load(storagePointer, offset, length, memoryPointer);\n    return result;\n  }\n\n  /**\n   * @notice Append raw bytes from storage at a given pointer, offset, and length to a specific memory pointer.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the location in memory to append the data.\n   */\n  function load(uint256 storagePointer, uint256 offset, uint256 length, uint256 memoryPointer) internal view {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask;\n        if (length < wordRemainder) {\n          mask = rightMask(length);\n        } else {\n          mask = rightMask(wordRemainder);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from storage and offset it to match memory\n          let offsetData := shl(mul(offset, BYTE_TO_BITS), sload(storagePointer))\n\n          mstore(\n            memoryPointer,\n            or(\n              // store the left part\n              and(offsetData, not(mask)),\n              // preserve the right parts\n              and(mload(memoryPointer), mask)\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Load full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(memoryPointer, sload(storagePointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = rightMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(\n          memoryPointer,\n          or(\n            // store the left part\n            and(sload(storagePointer), not(mask)),\n            // preserve the right part\n            and(mload(memoryPointer), mask)\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Load up to 32 bytes from storage at a given pointer and offset.\n   * @dev Since fields are tightly packed, they can span more than one slot.\n   * Since they're max 32 bytes, they can span at most 2 slots.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes, left-aligned bytes. Bytes beyond the length are not zeroed.\n   */\n  function loadField(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes32 result) {\n    if (offset >= 32) {\n      unchecked {\n        storagePointer += offset / 32;\n        offset %= 32;\n      }\n    }\n\n    // Extra data past length is not truncated\n    // This assumes that the caller will handle the overflow bits appropriately\n    assembly {\n      result := shl(mul(offset, BYTE_TO_BITS), sload(storagePointer))\n    }\n\n    uint256 wordRemainder;\n    // (safe because of `offset %= 32` at the start)\n    unchecked {\n      wordRemainder = 32 - offset;\n    }\n\n    // Read from the next slot if field spans 2 slots\n    if (length > wordRemainder) {\n      assembly {\n        result := or(result, shr(mul(wordRemainder, BYTE_TO_BITS), sload(add(storagePointer, 1))))\n      }\n    }\n  }\n}\n"},"node_modules/@latticexyz/store/src/codegen/index.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\nimport { StoreHooks } from \"./tables/StoreHooks.sol\";\nimport { Tables, TablesData } from \"./tables/Tables.sol\";\nimport { ResourceIds } from \"./tables/ResourceIds.sol\";\nimport { Hooks } from \"./tables/Hooks.sol\";\n"},"node_modules/@latticexyz/store/src/IStoreErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { ResourceId } from \"./ResourceId.sol\";\n\n/**\n * @title IStoreErrors\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This interface includes errors for Store.\n * @dev We bundle these errors in an interface (instead of at the file-level or in their corresponding library) so they can be inherited by IStore.\n * This ensures that all possible errors are included in the IStore ABI for proper decoding in the frontend.\n */\ninterface IStoreErrors {\n  /**\n   * @notice Error raised if the provided table already exists.\n   * @param tableId The ID of the table.\n   * @param tableIdString The stringified ID of the table (for easier debugging if cleartext tableIds are used).\n   */\n  error Store_TableAlreadyExists(ResourceId tableId, string tableIdString);\n  /**\n   * @notice Error raised if the provided table cannot be found.\n   * @param tableId The ID of the table.\n   * @param tableIdString The stringified ID of the table (for easier debugging if cleartext tableIds are used).\n   */\n  error Store_TableNotFound(ResourceId tableId, string tableIdString);\n  /**\n   * @notice Error raised if the provided resource ID cannot be found.\n   * @param expected The expected resource type.\n   * @param resourceId The resource ID.\n   * @param resourceIdString The stringified resource ID (for easier debugging).\n   */\n  error Store_InvalidResourceType(bytes2 expected, ResourceId resourceId, string resourceIdString);\n\n  /**\n   * @notice Error raised if the provided slice bounds are invalid.\n   * @param start The start index within the dynamic field for the slice operation (inclusive).\n   * @param end The end index within the dynamic field for the slice operation (exclusive).\n   */\n  error Store_InvalidBounds(uint256 start, uint256 end);\n  /**\n   * @notice Error raised if the provided index is out of bounds.\n   * @dev Raised if the start index is larger than the previous length of the field.\n   * @param length FIXME\n   * @param accessedIndex FIXME\n   */\n  error Store_IndexOutOfBounds(uint256 length, uint256 accessedIndex);\n  /**\n   * @notice Error raised if the provided static data length is invalid.\n   * @param expected The expected length.\n   * @param received The provided length.\n   */\n  error Store_InvalidStaticDataLength(uint256 expected, uint256 received);\n  /**\n   * @notice Error raised if the provided key names length is invalid.\n   * @param expected The expected length.\n   * @param received The provided length.\n   */\n  error Store_InvalidKeyNamesLength(uint256 expected, uint256 received);\n  /**\n   * @notice Error raised if the provided field names length is invalid.\n   * @param expected The expected length.\n   * @param received The provided length.\n   */\n  error Store_InvalidFieldNamesLength(uint256 expected, uint256 received);\n  /**\n   * @notice Error raised if the provided value schema length is invalid.\n   * @param expected The expected length.\n   * @param received The provided length.\n   */\n  error Store_InvalidValueSchemaLength(uint256 expected, uint256 received);\n  /**\n   * @notice Error raised if the provided schema static length is invalid.\n   * @param expected The expected length.\n   * @param received The provided length.\n   */\n  error Store_InvalidValueSchemaStaticLength(uint256 expected, uint256 received);\n  /**\n   * @notice Error raised if the provided schema dynamic length is invalid.\n   * @param expected The expected length.\n   * @param received The provided length.\n   */\n  error Store_InvalidValueSchemaDynamicLength(uint256 expected, uint256 received);\n  /**\n   * @notice Error raised if the provided splice is invalid.\n   * @dev Raised if the splice total length of the field is changed but the splice is not at the end of the field.\n   * @param startWithinField The start index within the field for the splice operation.\n   * @param deleteCount The number of bytes to delete in the splice operation.\n   * @param fieldLength The field length for the splice operation.\n   */\n  error Store_InvalidSplice(uint40 startWithinField, uint40 deleteCount, uint40 fieldLength);\n}\n"},"node_modules/@latticexyz/store/src/Hook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { Hooks } from \"./codegen/tables/Hooks.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n// 20 bytes address, 1 byte bitmap of enabled hooks\ntype Hook is bytes21;\n\nusing HookInstance for Hook global;\n\n/**\n * @title HookLib\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Library for encoding hooks and filtering hooks from a list by address.\n */\nlibrary HookLib {\n  /**\n   * @notice Packs the bitmap of enabled hooks with the hook address into a Hook value (bytes21).\n   * @dev The hook address is stored in the leftmost 20 bytes, and the bitmap is stored in the rightmost byte.\n   * @param hookAddress The address of the hook.\n   * @param encodedHooks The encoded hooks in a bitmap.\n   * @return A Hook type with packed hook address and bitmap.\n   */\n  function encode(address hookAddress, uint8 encodedHooks) internal pure returns (Hook) {\n    // Move the address to the leftmost 20 bytes and the bitmap to the rightmost byte\n    return Hook.wrap(bytes21(bytes20(hookAddress)) | bytes21(uint168(encodedHooks)));\n  }\n\n  /**\n   * @notice Filter a hook from the hook list by its address.\n   * @dev This function writes the updated hook list to the table in place.\n   * @param hookTableId The resource ID of the hook table.\n   * @param resourceWithHooks The resource ID of the table with hooks to filter.\n   * @param hookAddressToRemove The address of the hook to remove.\n   */\n  function filterListByAddress(\n    ResourceId hookTableId,\n    ResourceId resourceWithHooks,\n    address hookAddressToRemove\n  ) internal {\n    bytes21[] memory currentHooks = Hooks._get(hookTableId, resourceWithHooks);\n\n    // Initialize the new hooks array with the same length because we don't know if the hook is registered yet\n    bytes21[] memory newHooks = new bytes21[](currentHooks.length);\n\n    // Filter the array of current hooks\n    uint256 newHooksIndex;\n    unchecked {\n      for (uint256 currentHooksIndex; currentHooksIndex < currentHooks.length; currentHooksIndex++) {\n        if (Hook.wrap(currentHooks[currentHooksIndex]).getAddress() != address(hookAddressToRemove)) {\n          newHooks[newHooksIndex] = currentHooks[currentHooksIndex];\n          newHooksIndex++;\n        }\n      }\n    }\n\n    // Set the new hooks table length in place\n    // (Note: this does not update the free memory pointer)\n    assembly {\n      mstore(newHooks, newHooksIndex)\n    }\n\n    // Set the new hooks table\n    Hooks._set(hookTableId, resourceWithHooks, newHooks);\n  }\n}\n\n/**\n * @title HookInstance\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Library for interacting with Hook instances.\n **/\nlibrary HookInstance {\n  /**\n   * @notice Check if the given hook types are enabled in the hook.\n   * @dev We check multiple hook types at once by using a bitmap.\n   * @param self The Hook instance to check.\n   * @param hookTypes A bitmap of hook types to check.\n   * @return True if the hook types are enabled, false otherwise.\n   */\n  function isEnabled(Hook self, uint8 hookTypes) internal pure returns (bool) {\n    return (getBitmap(self) & hookTypes) == hookTypes;\n  }\n\n  /**\n   * @notice Get the address from the hook.\n   * @dev The address is stored in the leftmost 20 bytes.\n   * @param self The Hook instance to get the address from.\n   * @return The address contained in the Hook instance.\n   */\n  function getAddress(Hook self) internal pure returns (address) {\n    // Extract the address from the leftmost 20 bytes\n    return address(bytes20(Hook.unwrap(self)));\n  }\n\n  /**\n   * @notice Get the bitmap from the hook.\n   * @dev The bitmap is stored in the rightmost byte.\n   * @param self The Hook instance to get the bitmap from.\n   * @return The bitmap contained in the Hook instance.\n   */\n  function getBitmap(Hook self) internal pure returns (uint8) {\n    // Extract the bitmap from the rightmost bytes\n    return uint8(uint168(Hook.unwrap(self)));\n  }\n}\n"},"node_modules/@latticexyz/store/src/storeHookTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title Store Hook Flags\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Constants for enabling store hooks.\n * @dev These bitmaps can be used to enable selected store hooks. They can be combined with a bitwise OR (`|`).\n */\n\n/// @dev Flag to enable the `onBeforeSetRecord` hook.\nuint8 constant BEFORE_SET_RECORD = 1 << 0;\n\n/// @dev Flag to enable the `afterSetRecord` hook.\nuint8 constant AFTER_SET_RECORD = 1 << 1;\n\n/// @dev Flag to enable the `beforeSpliceStaticData` hook.\nuint8 constant BEFORE_SPLICE_STATIC_DATA = 1 << 2;\n\n/// @dev Flag to enable the `afterSpliceStaticData` hook.\nuint8 constant AFTER_SPLICE_STATIC_DATA = 1 << 3;\n\n/// @dev Flag to enable the `beforeSpliceDynamicData` hook.\nuint8 constant BEFORE_SPLICE_DYNAMIC_DATA = 1 << 4;\n\n/// @dev Flag to enable the `afterSpliceDynamicData` hook.\nuint8 constant AFTER_SPLICE_DYNAMIC_DATA = 1 << 5;\n\n/// @dev Flag to enable the `beforeDeleteRecord` hook.\nuint8 constant BEFORE_DELETE_RECORD = 1 << 6;\n\n/// @dev Flag to enable the `afterDeleteRecord` hook.\nuint8 constant AFTER_DELETE_RECORD = 1 << 7;\n\n/// @dev Bitmap to enable all hooks.\nuint8 constant ALL = BEFORE_SET_RECORD |\n  AFTER_SET_RECORD |\n  BEFORE_SPLICE_STATIC_DATA |\n  AFTER_SPLICE_STATIC_DATA |\n  BEFORE_SPLICE_DYNAMIC_DATA |\n  AFTER_SPLICE_DYNAMIC_DATA |\n  BEFORE_DELETE_RECORD |\n  AFTER_DELETE_RECORD;\n\n/// @dev Bitmap to enable all \"before\" hooks.\nuint8 constant BEFORE_ALL = BEFORE_SET_RECORD |\n  BEFORE_SPLICE_STATIC_DATA |\n  BEFORE_SPLICE_DYNAMIC_DATA |\n  BEFORE_DELETE_RECORD;\n\n/// @dev Bitmap to enable all \"after\" hooks.\nuint8 constant AFTER_ALL = AFTER_SET_RECORD |\n  AFTER_SPLICE_STATIC_DATA |\n  AFTER_SPLICE_DYNAMIC_DATA |\n  AFTER_DELETE_RECORD;\n"},"node_modules/@latticexyz/store/src/storeResourceTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title Resource Identifiers\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Constants representing unique identifiers for different resource types.\n * @dev These identifiers can be used to distinguish between various resource types.\n */\n\n/// @dev Identifier for a resource table.\nbytes2 constant RESOURCE_TABLE = \"tb\";\n\n/// @dev Identifier for an offchain resource table.\nbytes2 constant RESOURCE_OFFCHAIN_TABLE = \"ot\";\n"},"node_modules/@latticexyz/store/src/IStoreEvents.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { ResourceId } from \"./ResourceId.sol\";\nimport { EncodedLengths } from \"./EncodedLengths.sol\";\n\n/**\n * @title IStoreEvents\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n */\ninterface IStoreEvents {\n  /**\n   * @notice Emitted when the Store is created.\n   * @param storeVersion The protocol version of the Store.\n   */\n  event HelloStore(bytes32 indexed storeVersion);\n\n  /**\n   * @notice Emitted when a new record is set in the store.\n   * @param tableId The ID of the table where the record is set.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   */\n  event Store_SetRecord(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    bytes staticData,\n    EncodedLengths encodedLengths,\n    bytes dynamicData\n  );\n\n  /**\n   * @notice Emitted when static data in the store is spliced.\n   * @dev In static data, data is always overwritten starting at the start position,\n   * so the total length of the data remains the same and no data is shifted.\n   * @param tableId The ID of the table where the data is spliced.\n   * @param keyTuple An array representing the key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param data The data to write to the static data of the record at the start byte.\n   */\n  event Store_SpliceStaticData(ResourceId indexed tableId, bytes32[] keyTuple, uint48 start, bytes data);\n\n  /**\n   * @notice Emitted when dynamic data in the store is spliced.\n   * @param tableId The ID of the table where the data is spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to splice data, relative to the start of the dynamic fields.\n   * (Dynamic field index = field index - number of static fields)\n   * @param start The start position in bytes for the splice operation.\n   * @param deleteCount The number of bytes to delete in the splice operation.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param data The data to insert into the dynamic data of the record at the start byte.\n   */\n  event Store_SpliceDynamicData(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    uint8 dynamicFieldIndex,\n    uint48 start,\n    uint40 deleteCount,\n    EncodedLengths encodedLengths,\n    bytes data\n  );\n\n  /**\n   * @notice Emitted when a record is deleted from the store.\n   * @param tableId The ID of the table where the record is deleted.\n   * @param keyTuple An array representing the composite key for the record.\n   */\n  event Store_DeleteRecord(ResourceId indexed tableId, bytes32[] keyTuple);\n}\n"},"node_modules/@latticexyz/schema-type/src/solidity/SchemaType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nusing { getStaticByteLength } for SchemaType global;\n\n// WARNING: All enum changes MUST be mirrored for the other languages!\n// WARNING: SchemaType methods use hardcoded enum indexes, review them after any changes to the enum\n// TODO add and implement BYTES_ARRAY, STRING_ARRAY if they are needed (see https://github.com/latticexyz/mud/issues/447)\nenum SchemaType {\n  UINT8,\n  UINT16,\n  UINT24,\n  UINT32,\n  UINT40,\n  UINT48,\n  UINT56,\n  UINT64,\n  UINT72,\n  UINT80,\n  UINT88,\n  UINT96,\n  UINT104,\n  UINT112,\n  UINT120,\n  UINT128,\n  UINT136,\n  UINT144,\n  UINT152,\n  UINT160,\n  UINT168,\n  UINT176,\n  UINT184,\n  UINT192,\n  UINT200,\n  UINT208,\n  UINT216,\n  UINT224,\n  UINT232,\n  UINT240,\n  UINT248,\n  UINT256,\n  INT8,\n  INT16,\n  INT24,\n  INT32,\n  INT40,\n  INT48,\n  INT56,\n  INT64,\n  INT72,\n  INT80,\n  INT88,\n  INT96,\n  INT104,\n  INT112,\n  INT120,\n  INT128,\n  INT136,\n  INT144,\n  INT152,\n  INT160,\n  INT168,\n  INT176,\n  INT184,\n  INT192,\n  INT200,\n  INT208,\n  INT216,\n  INT224,\n  INT232,\n  INT240,\n  INT248,\n  INT256,\n  BYTES1,\n  BYTES2,\n  BYTES3,\n  BYTES4,\n  BYTES5,\n  BYTES6,\n  BYTES7,\n  BYTES8,\n  BYTES9,\n  BYTES10,\n  BYTES11,\n  BYTES12,\n  BYTES13,\n  BYTES14,\n  BYTES15,\n  BYTES16,\n  BYTES17,\n  BYTES18,\n  BYTES19,\n  BYTES20,\n  BYTES21,\n  BYTES22,\n  BYTES23,\n  BYTES24,\n  BYTES25,\n  BYTES26,\n  BYTES27,\n  BYTES28,\n  BYTES29,\n  BYTES30,\n  BYTES31,\n  BYTES32,\n  BOOL,\n  ADDRESS,\n  UINT8_ARRAY,\n  UINT16_ARRAY,\n  UINT24_ARRAY,\n  UINT32_ARRAY,\n  UINT40_ARRAY,\n  UINT48_ARRAY,\n  UINT56_ARRAY,\n  UINT64_ARRAY,\n  UINT72_ARRAY,\n  UINT80_ARRAY,\n  UINT88_ARRAY,\n  UINT96_ARRAY,\n  UINT104_ARRAY,\n  UINT112_ARRAY,\n  UINT120_ARRAY,\n  UINT128_ARRAY,\n  UINT136_ARRAY,\n  UINT144_ARRAY,\n  UINT152_ARRAY,\n  UINT160_ARRAY,\n  UINT168_ARRAY,\n  UINT176_ARRAY,\n  UINT184_ARRAY,\n  UINT192_ARRAY,\n  UINT200_ARRAY,\n  UINT208_ARRAY,\n  UINT216_ARRAY,\n  UINT224_ARRAY,\n  UINT232_ARRAY,\n  UINT240_ARRAY,\n  UINT248_ARRAY,\n  UINT256_ARRAY,\n  INT8_ARRAY,\n  INT16_ARRAY,\n  INT24_ARRAY,\n  INT32_ARRAY,\n  INT40_ARRAY,\n  INT48_ARRAY,\n  INT56_ARRAY,\n  INT64_ARRAY,\n  INT72_ARRAY,\n  INT80_ARRAY,\n  INT88_ARRAY,\n  INT96_ARRAY,\n  INT104_ARRAY,\n  INT112_ARRAY,\n  INT120_ARRAY,\n  INT128_ARRAY,\n  INT136_ARRAY,\n  INT144_ARRAY,\n  INT152_ARRAY,\n  INT160_ARRAY,\n  INT168_ARRAY,\n  INT176_ARRAY,\n  INT184_ARRAY,\n  INT192_ARRAY,\n  INT200_ARRAY,\n  INT208_ARRAY,\n  INT216_ARRAY,\n  INT224_ARRAY,\n  INT232_ARRAY,\n  INT240_ARRAY,\n  INT248_ARRAY,\n  INT256_ARRAY,\n  BYTES1_ARRAY,\n  BYTES2_ARRAY,\n  BYTES3_ARRAY,\n  BYTES4_ARRAY,\n  BYTES5_ARRAY,\n  BYTES6_ARRAY,\n  BYTES7_ARRAY,\n  BYTES8_ARRAY,\n  BYTES9_ARRAY,\n  BYTES10_ARRAY,\n  BYTES11_ARRAY,\n  BYTES12_ARRAY,\n  BYTES13_ARRAY,\n  BYTES14_ARRAY,\n  BYTES15_ARRAY,\n  BYTES16_ARRAY,\n  BYTES17_ARRAY,\n  BYTES18_ARRAY,\n  BYTES19_ARRAY,\n  BYTES20_ARRAY,\n  BYTES21_ARRAY,\n  BYTES22_ARRAY,\n  BYTES23_ARRAY,\n  BYTES24_ARRAY,\n  BYTES25_ARRAY,\n  BYTES26_ARRAY,\n  BYTES27_ARRAY,\n  BYTES28_ARRAY,\n  BYTES29_ARRAY,\n  BYTES30_ARRAY,\n  BYTES31_ARRAY,\n  BYTES32_ARRAY,\n  BOOL_ARRAY,\n  ADDRESS_ARRAY,\n  BYTES,\n  STRING\n}\n\n/**\n * Get the length of the data for the given schema type\n * (Because Solidity doesn't support constant arrays, we need to use a function)\n */\nfunction getStaticByteLength(SchemaType schemaType) pure returns (uint256) {\n  uint256 index = uint8(schemaType);\n\n  if (index < 97) {\n    // SchemaType enum elements are cyclically ordered for optimal static length lookup\n    // indexes: 00-31, 32-63, 64-95, 96, 97, ...\n    // lengths: 01-32, 01-32, 01-32, 01, 20, (the rest are 0s)\n    unchecked {\n      return (index & 31) + 1;\n    }\n  } else if (schemaType == SchemaType.ADDRESS) {\n    return 20;\n  } else {\n    // Return 0 for all dynamic types\n    return 0;\n  }\n}\n"},"node_modules/@latticexyz/store/src/ISchemaErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title ISchemaErrors\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This interface includes errors for the Schema library.\n * @dev We bundle these errors in an interface (instead of at the file-level or in their corresponding libraries) so they can be inherited by IStore.\n * This ensures that all possible errors are included in the IStore ABI for proper decoding in the frontend.\n */\ninterface ISchemaErrors {\n  /**\n   * @notice Error raised when the provided schema has an invalid length.\n   * @param length The length of the schema.\n   */\n  error Schema_InvalidLength(uint256 length);\n\n  /**\n   * @notice Error raised when a static type is placed after a dynamic type in a schema.\n   */\n  error Schema_StaticTypeAfterDynamicType();\n}\n"},"node_modules/@latticexyz/store/src/IFieldLayoutErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title IFieldLayoutErrors\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This interface includes errors for the FieldLayout library.\n * @dev We bundle these errors in an interface (instead of at the file-level or in their corresponding libraries) so they can be inherited by IStore.\n * This ensures that all possible errors are included in the IStore ABI for proper decoding in the frontend.\n */\ninterface IFieldLayoutErrors {\n  /**\n   * @notice Error raised when the provided field layout has too many fields.\n   * @param numFields The total number of fields in the field layout.\n   * @param maxFields The maximum number of fields a Schema can handle.\n   */\n  error FieldLayout_TooManyFields(uint256 numFields, uint256 maxFields);\n  /**\n   * @notice Error raised when the provided field layout has too many dynamic fields.\n   * @param numFields The total number of fields in the field layout.\n   * @param maxFields The maximum number of fields a Schema can handle.\n   */\n  error FieldLayout_TooManyDynamicFields(uint256 numFields, uint256 maxFields);\n  /**\n   * @notice Error raised when the provided field layout is empty.\n   */\n  error FieldLayout_Empty();\n  /**\n   * @notice Error raised when the provided field layout has an invalid static data length.\n   * @param staticDataLength The static data length of the field layout.\n   * @param computedStaticDataLength The computed static data length.\n   */\n  error FieldLayout_InvalidStaticDataLength(uint256 staticDataLength, uint256 computedStaticDataLength);\n  /**\n   * @notice Error raised when the provided field layout has a static data length of zero.\n   * @param index The index of the field.\n   */\n  error FieldLayout_StaticLengthIsZero(uint256 index);\n  /**\n   * @notice Error raised when the provided field layout has a nonzero static data length.\n   * @param index The index of the field.\n   */\n  error FieldLayout_StaticLengthIsNotZero(uint256 index);\n  /**\n   * @notice Error raised when the provided field layout has a static data length that does not fit in a word (32 bytes).\n   * @param index The index of the field.\n   */\n  error FieldLayout_StaticLengthDoesNotFitInAWord(uint256 index);\n}\n"},"node_modules/@latticexyz/world/src/IWorldErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { ResourceId } from \"@latticexyz/store/src/ResourceId.sol\";\n\n/**\n * @title World Errors Interface\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev This interface contains custom error types for the World contract. These errors provide\n * more informative messages for certain operations within the World contract.\n */\ninterface IWorldErrors {\n  /**\n   * @notice Raised when trying to initialize an already initialized World.\n   */\n  error World_AlreadyInitialized();\n\n  /**\n   * @notice Raised when trying to register a resource that already exists.\n   * @param resourceId The ID of the resource.\n   * @param resourceIdString The string representation of the resource ID.\n   */\n  error World_ResourceAlreadyExists(ResourceId resourceId, string resourceIdString);\n\n  /**\n   * @notice Raised when the specified resource is not found.\n   * @param resourceId The ID of the resource.\n   * @param resourceIdString The string representation of the resource ID.\n   */\n  error World_ResourceNotFound(ResourceId resourceId, string resourceIdString);\n\n  /**\n   * @notice Raised when a user tries to access a resource they don't have permission for.\n   * @param resource The resource's identifier.\n   * @param caller The address of the user trying to access the resource.\n   */\n  error World_AccessDenied(string resource, address caller);\n\n  /**\n   * @notice Raised when an invalid resource ID is provided.\n   * @param resourceId The ID of the resource.\n   * @param resourceIdString The string representation of the resource ID.\n   */\n  error World_InvalidResourceId(ResourceId resourceId, string resourceIdString);\n\n  /**\n   * @notice Raised when an namespace contains an invalid sequence of characters (\"__\").\n   * @param namespace The invalid namespace.\n   */\n  error World_InvalidNamespace(bytes14 namespace);\n\n  /**\n   * @notice Raised when trying to register a system that already exists.\n   * @param system The address of the system.\n   */\n  error World_SystemAlreadyExists(address system);\n\n  /**\n   * @notice Raised when trying to register a function selector that already exists.\n   * @param functionSelector The function selector in question.\n   */\n  error World_FunctionSelectorAlreadyExists(bytes4 functionSelector);\n\n  /**\n   * @notice Raised when the specified function selector is not found.\n   * @param functionSelector The function selector in question.\n   */\n  error World_FunctionSelectorNotFound(bytes4 functionSelector);\n\n  /**\n   * @notice Raised when the specified delegation is not found.\n   * @param delegator The address of the delegator.\n   * @param delegatee The address of the delegatee.\n   */\n  error World_DelegationNotFound(address delegator, address delegatee);\n\n  /**\n   * @notice Raised when trying to create an unlimited delegation in a context where it is not allowed,\n   * e.g. when registering a namespace fallback delegation.\n   */\n  error World_UnlimitedDelegationNotAllowed();\n\n  /**\n   * @notice Raised when there's an insufficient balance for a particular operation.\n   * @param balance The current balance.\n   * @param amount The amount needed.\n   */\n  error World_InsufficientBalance(uint256 balance, uint256 amount);\n\n  /**\n   * @notice Raised when the specified interface is not supported by the contract.\n   * @param contractAddress The address of the contract in question.\n   * @param interfaceId The ID of the interface.\n   */\n  error World_InterfaceNotSupported(address contractAddress, bytes4 interfaceId);\n\n  /**\n   * @notice Raised when an invalid resource type is provided.\n   * @param expected The expected resource type.\n   * @param resourceId The ID of the resource.\n   * @param resourceIdString The string representation of the resource ID.\n   */\n  error World_InvalidResourceType(bytes2 expected, ResourceId resourceId, string resourceIdString);\n\n  /**\n   * @notice Raised when the World is calling itself via an external call.\n   * @param functionSelector The function selector of the disallowed callback.\n   */\n  error World_CallbackNotAllowed(bytes4 functionSelector);\n}\n"},"node_modules/@latticexyz/world/src/IModule.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { IERC165 } from \"./IERC165.sol\";\nimport { IModuleErrors } from \"./IModuleErrors.sol\";\n\n/**\n * @title IModule\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Interface for the Module system.\n * A module can be installed within the context of a world, either as a root or non-root module.\n * This interface adheres to the ERC-165 standard for determining interface support.\n */\ninterface IModule is IERC165, IModuleErrors {\n  /**\n   * @notice Installs the module as a root module.\n   * @dev This function is invoked by the World contract during `installRootModule` process.\n   * The module expects to be called via the World contract and thus installs itself on the `msg.sender`.\n   * @param encodedArgs The ABI encoded arguments that may be needed during the installation process.\n   */\n  function installRoot(bytes memory encodedArgs) external;\n\n  /**\n   * @notice Installs the module.\n   * @dev This function is invoked by the World contract during `installModule` process.\n   * The module expects to be called via the World contract and thus installs itself on the `msg.sender`.\n   * Logic might differ from `installRoot`, for example, this might accept namespace parameters.\n   * @param encodedArgs The ABI encoded arguments that may be needed during the installation process.\n   */\n  function install(bytes memory encodedArgs) external;\n}\n"},"node_modules/@latticexyz/world/src/IModuleErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title IModuleErrors\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This interface includes errors for the Module library.\n * @dev We bundle these errors in an interface (instead of at the file-level or in their corresponding library) so they can be inherited by IWorldKernel.\n * This ensures that all errors are included in the IWorldKernel ABI for proper decoding in the frontend.\n */\ninterface IModuleErrors {\n  /**\n   * @notice Error raised if installing in root is not supported.\n   */\n  error Module_RootInstallNotSupported();\n  /**\n   * @notice Error raised if installing in non-root is not supported.\n   */\n  error Module_NonRootInstallNotSupported();\n  /**\n   * @notice Error raised if the provided module is already installed.\n   */\n  error Module_AlreadyInstalled();\n  /**\n   * @notice Error raised if the provided module is missing a dependency.\n   * @param dependency The address of the dependency.\n   */\n  error Module_MissingDependency(address dependency);\n}\n"},"node_modules/@latticexyz/world/src/IWorldEvents.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { IWorldErrors } from \"./IWorldErrors.sol\";\nimport { IModule } from \"./IModule.sol\";\nimport { ResourceId } from \"./WorldResourceId.sol\";\n\n/**\n * @title IWorldEvents\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev We bundle these events in an interface (instead of at the file-level or in their corresponding library) so they can be inherited by IWorldKernel.\n * This ensures that all events are included in the IWorldKernel ABI for proper decoding in the frontend.\n */\ninterface IWorldEvents {\n  /**\n   * @notice Emitted when the World is created.\n   * @param worldVersion The protocol version of the World.\n   */\n  event HelloWorld(bytes32 indexed worldVersion);\n}\n"},"node_modules/@latticexyz/world/src/modules/init/types.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { ResourceId } from \"@latticexyz/store/src/ResourceId.sol\";\n\n/**\n * @title System Call Data Structure\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Holds data for making system calls.\n * @dev Used to represent a call to a specific system identified by a ResourceId.\n */\nstruct SystemCallData {\n  /// @dev The ID of the system to call.\n  ResourceId systemId;\n  /// @dev The call data to pass to the system function.\n  bytes callData;\n}\n\n/**\n * @title System Call From Data Structure\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Holds data for making system calls with a specific sender.\n * @dev Used to represent a call from a specific address to a specific system.\n */\nstruct SystemCallFromData {\n  /// @dev The address from which the system call is made.\n  address from;\n  /// @dev The ID of the system to call.\n  ResourceId systemId;\n  /// @dev The call data to pass to the system function.\n  bytes callData;\n}\n"},"node_modules/@latticexyz/world/src/ISystemHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { IERC165 } from \"./IERC165.sol\";\nimport { ResourceId } from \"./WorldResourceId.sol\";\n\n/**\n * @title ISystemHook\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Interface defining system hooks for external functionality.\n * Provides pre and post hooks that can be triggered before and after a system call respectively.\n * This interface adheres to the ERC-165 standard for determining interface support.\n */\ninterface ISystemHook is IERC165 {\n  /**\n   * @notice Executes before a system call.\n   * @dev Provides the ability to add custom logic or checks before a system is invoked.\n   * @param msgSender The original sender of the system call.\n   * @param systemId The identifier for the system being called.\n   * @param callData Data being sent as part of the system call.\n   */\n  function onBeforeCallSystem(address msgSender, ResourceId systemId, bytes memory callData) external;\n\n  /**\n   * @notice Executes after a system call.\n   * @dev Provides the ability to add custom logic or checks after a system call completes.\n   * @param msgSender The original sender of the system call.\n   * @param systemId The identifier for the system that was called.\n   * @param callData Data that was sent as part of the system call.\n   */\n  function onAfterCallSystem(address msgSender, ResourceId systemId, bytes memory callData) external;\n}\n"},"node_modules/@latticexyz/world/src/System.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { WorldContextConsumer } from \"./WorldContext.sol\";\n\n/**\n * @title System\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev The System contract currently acts as an alias for `WorldContextConsumer`.\n * This structure is chosen for potential extensions in the future, where default functionality might be added to the System.\n */\nabstract contract System is WorldContextConsumer {\n  // Currently, no additional functionality is added. Future enhancements can be introduced here.\n}\n"},"node_modules/@latticexyz/store/src/rightMask.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { BYTE_TO_BITS } from \"./constants.sol\";\n\n/**\n * @title Byte Mask Utility\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Utility functions to manage bytes in memory.\n * @dev Adapted from https://github.com/dk1a/solidity-stringutils/blob/main/src/utils/mem.sol#L149-L167\n */\n\n/**\n * @notice Computes a right-aligned byte mask based on the provided byte length.\n * @dev The mask is used to extract a specified number of rightmost bytes.\n \n * @param byteLength The number of rightmost bytes to be masked.\n * @return mask A right-aligned byte mask corresponding to the specified byte length.\n */\nfunction rightMask(uint256 byteLength) pure returns (uint256 mask) {\n  unchecked {\n    return type(uint256).max >> (byteLength * BYTE_TO_BITS);\n  }\n}\n"},"node_modules/@latticexyz/store/src/tightcoder/DecodeSlice.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\nimport { TightCoder } from \"./TightCoder.sol\";\nimport { Slice } from \"../Slice.sol\";\n\n/**\n * @title DecodeSlice Library\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice A library for decoding slices of data into specific data types.\n * @dev This library provides functions for decoding slices into arrays of basic uint types.\n */\nlibrary DecodeSlice {\n  /**\n   * @notice Decodes a slice into an array of uint8.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint8.\n   */\n  function decodeArray_uint8(Slice _input) internal pure returns (uint8[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 1, 248);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint16.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint16.\n   */\n  function decodeArray_uint16(Slice _input) internal pure returns (uint16[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 2, 240);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint24.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint24.\n   */\n  function decodeArray_uint24(Slice _input) internal pure returns (uint24[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 3, 232);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint32.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint32.\n   */\n  function decodeArray_uint32(Slice _input) internal pure returns (uint32[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 4, 224);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint40.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint40.\n   */\n  function decodeArray_uint40(Slice _input) internal pure returns (uint40[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 5, 216);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint48.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint48.\n   */\n  function decodeArray_uint48(Slice _input) internal pure returns (uint48[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 6, 208);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint56.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint56.\n   */\n  function decodeArray_uint56(Slice _input) internal pure returns (uint56[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 7, 200);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint64.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint64.\n   */\n  function decodeArray_uint64(Slice _input) internal pure returns (uint64[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 8, 192);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint72.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint72.\n   */\n  function decodeArray_uint72(Slice _input) internal pure returns (uint72[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 9, 184);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint80.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint80.\n   */\n  function decodeArray_uint80(Slice _input) internal pure returns (uint80[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 10, 176);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint88.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint88.\n   */\n  function decodeArray_uint88(Slice _input) internal pure returns (uint88[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 11, 168);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint96.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint96.\n   */\n  function decodeArray_uint96(Slice _input) internal pure returns (uint96[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 12, 160);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint104.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint104.\n   */\n  function decodeArray_uint104(Slice _input) internal pure returns (uint104[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 13, 152);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint112.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint112.\n   */\n  function decodeArray_uint112(Slice _input) internal pure returns (uint112[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 14, 144);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint120.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint120.\n   */\n  function decodeArray_uint120(Slice _input) internal pure returns (uint120[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 15, 136);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint128.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint128.\n   */\n  function decodeArray_uint128(Slice _input) internal pure returns (uint128[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 16, 128);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint136.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint136.\n   */\n  function decodeArray_uint136(Slice _input) internal pure returns (uint136[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 17, 120);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint144.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint144.\n   */\n  function decodeArray_uint144(Slice _input) internal pure returns (uint144[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 18, 112);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint152.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint152.\n   */\n  function decodeArray_uint152(Slice _input) internal pure returns (uint152[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 19, 104);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint160.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint160.\n   */\n  function decodeArray_uint160(Slice _input) internal pure returns (uint160[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 20, 96);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint168.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint168.\n   */\n  function decodeArray_uint168(Slice _input) internal pure returns (uint168[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 21, 88);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint176.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint176.\n   */\n  function decodeArray_uint176(Slice _input) internal pure returns (uint176[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 22, 80);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint184.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint184.\n   */\n  function decodeArray_uint184(Slice _input) internal pure returns (uint184[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 23, 72);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint192.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint192.\n   */\n  function decodeArray_uint192(Slice _input) internal pure returns (uint192[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 24, 64);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint200.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint200.\n   */\n  function decodeArray_uint200(Slice _input) internal pure returns (uint200[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 25, 56);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint208.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint208.\n   */\n  function decodeArray_uint208(Slice _input) internal pure returns (uint208[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 26, 48);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint216.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint216.\n   */\n  function decodeArray_uint216(Slice _input) internal pure returns (uint216[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 27, 40);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint224.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint224.\n   */\n  function decodeArray_uint224(Slice _input) internal pure returns (uint224[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 28, 32);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint232.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint232.\n   */\n  function decodeArray_uint232(Slice _input) internal pure returns (uint232[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 29, 24);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint240.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint240.\n   */\n  function decodeArray_uint240(Slice _input) internal pure returns (uint240[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 30, 16);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint248.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint248.\n   */\n  function decodeArray_uint248(Slice _input) internal pure returns (uint248[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 31, 8);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of uint256.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of uint256.\n   */\n  function decodeArray_uint256(Slice _input) internal pure returns (uint256[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 32, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int8.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int8.\n   */\n  function decodeArray_int8(Slice _input) internal pure returns (int8[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 1, 248);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int16.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int16.\n   */\n  function decodeArray_int16(Slice _input) internal pure returns (int16[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 2, 240);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int24.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int24.\n   */\n  function decodeArray_int24(Slice _input) internal pure returns (int24[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 3, 232);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int32.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int32.\n   */\n  function decodeArray_int32(Slice _input) internal pure returns (int32[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 4, 224);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int40.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int40.\n   */\n  function decodeArray_int40(Slice _input) internal pure returns (int40[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 5, 216);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int48.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int48.\n   */\n  function decodeArray_int48(Slice _input) internal pure returns (int48[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 6, 208);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int56.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int56.\n   */\n  function decodeArray_int56(Slice _input) internal pure returns (int56[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 7, 200);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int64.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int64.\n   */\n  function decodeArray_int64(Slice _input) internal pure returns (int64[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 8, 192);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int72.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int72.\n   */\n  function decodeArray_int72(Slice _input) internal pure returns (int72[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 9, 184);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int80.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int80.\n   */\n  function decodeArray_int80(Slice _input) internal pure returns (int80[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 10, 176);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int88.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int88.\n   */\n  function decodeArray_int88(Slice _input) internal pure returns (int88[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 11, 168);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int96.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int96.\n   */\n  function decodeArray_int96(Slice _input) internal pure returns (int96[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 12, 160);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int104.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int104.\n   */\n  function decodeArray_int104(Slice _input) internal pure returns (int104[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 13, 152);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int112.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int112.\n   */\n  function decodeArray_int112(Slice _input) internal pure returns (int112[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 14, 144);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int120.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int120.\n   */\n  function decodeArray_int120(Slice _input) internal pure returns (int120[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 15, 136);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int128.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int128.\n   */\n  function decodeArray_int128(Slice _input) internal pure returns (int128[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 16, 128);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int136.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int136.\n   */\n  function decodeArray_int136(Slice _input) internal pure returns (int136[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 17, 120);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int144.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int144.\n   */\n  function decodeArray_int144(Slice _input) internal pure returns (int144[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 18, 112);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int152.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int152.\n   */\n  function decodeArray_int152(Slice _input) internal pure returns (int152[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 19, 104);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int160.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int160.\n   */\n  function decodeArray_int160(Slice _input) internal pure returns (int160[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 20, 96);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int168.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int168.\n   */\n  function decodeArray_int168(Slice _input) internal pure returns (int168[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 21, 88);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int176.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int176.\n   */\n  function decodeArray_int176(Slice _input) internal pure returns (int176[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 22, 80);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int184.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int184.\n   */\n  function decodeArray_int184(Slice _input) internal pure returns (int184[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 23, 72);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int192.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int192.\n   */\n  function decodeArray_int192(Slice _input) internal pure returns (int192[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 24, 64);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int200.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int200.\n   */\n  function decodeArray_int200(Slice _input) internal pure returns (int200[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 25, 56);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int208.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int208.\n   */\n  function decodeArray_int208(Slice _input) internal pure returns (int208[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 26, 48);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int216.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int216.\n   */\n  function decodeArray_int216(Slice _input) internal pure returns (int216[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 27, 40);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int224.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int224.\n   */\n  function decodeArray_int224(Slice _input) internal pure returns (int224[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 28, 32);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int232.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int232.\n   */\n  function decodeArray_int232(Slice _input) internal pure returns (int232[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 29, 24);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int240.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int240.\n   */\n  function decodeArray_int240(Slice _input) internal pure returns (int240[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 30, 16);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int248.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int248.\n   */\n  function decodeArray_int248(Slice _input) internal pure returns (int248[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 31, 8);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of int256.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of int256.\n   */\n  function decodeArray_int256(Slice _input) internal pure returns (int256[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 32, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes1.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes1.\n   */\n  function decodeArray_bytes1(Slice _input) internal pure returns (bytes1[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 1, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes2.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes2.\n   */\n  function decodeArray_bytes2(Slice _input) internal pure returns (bytes2[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 2, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes3.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes3.\n   */\n  function decodeArray_bytes3(Slice _input) internal pure returns (bytes3[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 3, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes4.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes4.\n   */\n  function decodeArray_bytes4(Slice _input) internal pure returns (bytes4[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 4, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes5.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes5.\n   */\n  function decodeArray_bytes5(Slice _input) internal pure returns (bytes5[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 5, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes6.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes6.\n   */\n  function decodeArray_bytes6(Slice _input) internal pure returns (bytes6[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 6, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes7.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes7.\n   */\n  function decodeArray_bytes7(Slice _input) internal pure returns (bytes7[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 7, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes8.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes8.\n   */\n  function decodeArray_bytes8(Slice _input) internal pure returns (bytes8[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 8, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes9.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes9.\n   */\n  function decodeArray_bytes9(Slice _input) internal pure returns (bytes9[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 9, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes10.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes10.\n   */\n  function decodeArray_bytes10(Slice _input) internal pure returns (bytes10[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 10, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes11.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes11.\n   */\n  function decodeArray_bytes11(Slice _input) internal pure returns (bytes11[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 11, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes12.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes12.\n   */\n  function decodeArray_bytes12(Slice _input) internal pure returns (bytes12[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 12, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes13.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes13.\n   */\n  function decodeArray_bytes13(Slice _input) internal pure returns (bytes13[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 13, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes14.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes14.\n   */\n  function decodeArray_bytes14(Slice _input) internal pure returns (bytes14[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 14, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes15.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes15.\n   */\n  function decodeArray_bytes15(Slice _input) internal pure returns (bytes15[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 15, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes16.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes16.\n   */\n  function decodeArray_bytes16(Slice _input) internal pure returns (bytes16[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 16, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes17.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes17.\n   */\n  function decodeArray_bytes17(Slice _input) internal pure returns (bytes17[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 17, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes18.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes18.\n   */\n  function decodeArray_bytes18(Slice _input) internal pure returns (bytes18[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 18, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes19.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes19.\n   */\n  function decodeArray_bytes19(Slice _input) internal pure returns (bytes19[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 19, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes20.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes20.\n   */\n  function decodeArray_bytes20(Slice _input) internal pure returns (bytes20[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 20, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes21.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes21.\n   */\n  function decodeArray_bytes21(Slice _input) internal pure returns (bytes21[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 21, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes22.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes22.\n   */\n  function decodeArray_bytes22(Slice _input) internal pure returns (bytes22[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 22, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes23.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes23.\n   */\n  function decodeArray_bytes23(Slice _input) internal pure returns (bytes23[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 23, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes24.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes24.\n   */\n  function decodeArray_bytes24(Slice _input) internal pure returns (bytes24[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 24, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes25.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes25.\n   */\n  function decodeArray_bytes25(Slice _input) internal pure returns (bytes25[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 25, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes26.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes26.\n   */\n  function decodeArray_bytes26(Slice _input) internal pure returns (bytes26[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 26, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes27.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes27.\n   */\n  function decodeArray_bytes27(Slice _input) internal pure returns (bytes27[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 27, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes28.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes28.\n   */\n  function decodeArray_bytes28(Slice _input) internal pure returns (bytes28[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 28, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes29.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes29.\n   */\n  function decodeArray_bytes29(Slice _input) internal pure returns (bytes29[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 29, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes30.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes30.\n   */\n  function decodeArray_bytes30(Slice _input) internal pure returns (bytes30[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 30, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes31.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes31.\n   */\n  function decodeArray_bytes31(Slice _input) internal pure returns (bytes31[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 31, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bytes32.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bytes32.\n   */\n  function decodeArray_bytes32(Slice _input) internal pure returns (bytes32[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 32, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of bool.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of bool.\n   */\n  function decodeArray_bool(Slice _input) internal pure returns (bool[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 1, 248);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  /**\n   * @notice Decodes a slice into an array of address.\n   * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n   * @param _input The slice to decode.\n   * @return _output The decoded array of address.\n   */\n  function decodeArray_address(Slice _input) internal pure returns (address[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 20, 96);\n    assembly {\n      _output := _genericArray\n    }\n  }\n}\n"},"node_modules/@latticexyz/store/src/ISliceErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title ISliceErrors\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This interface includes errors for the Slice library.\n * @dev We bundle these errors in an interface (instead of at the file-level or in their corresponding libraries) so they can be inherited by IStore.\n * This ensures that all possible errors are included in the IStore ABI for proper decoding in the frontend.\n */\ninterface ISliceErrors {\n  /**\n   * @notice Error raised when the provided slice is out of bounds.\n   * @dev Raised if `start` is greater than `end` or `end` greater than the length of `data`.\n   * @param data The bytes array to subslice.\n   * @param start The start index for the subslice.\n   * @param end The end index for the subslice.\n   */\n  error Slice_OutOfBounds(bytes data, uint256 start, uint256 end);\n}\n"},"node_modules/@latticexyz/store/src/tightcoder/TightCoder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { Slice } from \"../Slice.sol\";\n\n/**\n * @title TightCoder\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Provides low-level generic implementations of tight encoding and decoding for arrays.\n * This is consistent with Solidity's internal tight encoding for array data in storage.\n */\nlibrary TightCoder {\n  /**\n   * @dev Copies the array to a new bytes array, tightly packing its elements.\n   * @param array The array to encode.\n   * @param elementSize The size of each element in bytes.\n   * @param leftPaddingBits The amount to shift each element to the left.\n   * @return data A tightly packed byte array.\n   * @notice elementSize and leftPaddingBits must be correctly provided by the caller based on the array's element type.\n   */\n  function encode(\n    bytes32[] memory array,\n    uint256 elementSize,\n    uint256 leftPaddingBits\n  ) internal pure returns (bytes memory data) {\n    uint256 arrayLength = array.length;\n    uint256 packedLength = array.length * elementSize;\n\n    // Manual memory allocation is cheaper and removes the issue of memory corruption at the tail\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 0x1F), not(0x1F))\n      }\n\n      // Allocate memory\n      data := mload(0x40)\n      let packedPointer := add(data, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(packedPointer, packedLength)))\n      // Store length\n      mstore(data, packedLength)\n\n      for {\n        let i := 0\n        // Skip array length\n        let arrayPointer := add(array, 0x20)\n      } lt(i, arrayLength) {\n        // Loop until we reach the end of the array\n        i := add(i, 1)\n        // Increment array pointer by one word\n        arrayPointer := add(arrayPointer, 0x20)\n        // Increment packed pointer by one element size\n        packedPointer := add(packedPointer, elementSize)\n      } {\n        // Pack one array element\n        mstore(packedPointer, shl(leftPaddingBits, mload(arrayPointer)))\n      }\n    }\n  }\n\n  /**\n   * @notice Decodes a tightly packed byte slice into a bytes32 array.\n   * @param packedSlice The tightly packed data to be decoded.\n   * @param elementSize The size of each element in bytes.\n   * @param leftPaddingBits The number of padding bits on the left side of each element.\n   * @dev elementSize and leftPaddingBits must be correctly provided based on the desired output array's element type.\n   * @return array The resulting array of bytes32 elements from decoding the packed slice.\n   */\n  function decode(\n    Slice packedSlice,\n    uint256 elementSize,\n    uint256 leftPaddingBits\n  ) internal pure returns (bytes32[] memory array) {\n    uint256 packedPointer = packedSlice.pointer();\n    uint256 packedLength = packedSlice.length();\n    // Array length (number of elements)\n    uint256 arrayLength;\n    unchecked {\n      arrayLength = packedLength / elementSize;\n    }\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Allocate memory\n      array := mload(0x40)\n      let arrayPointer := add(array, 0x20)\n      mstore(0x40, add(arrayPointer, mul(arrayLength, 0x20)))\n      // Store length\n      mstore(array, arrayLength)\n\n      for {\n        let i := 0\n      } lt(i, arrayLength) {\n        // Loop until we reach the end of the array\n        i := add(i, 1)\n        // Increment array pointer by one word\n        arrayPointer := add(arrayPointer, 0x20)\n        // Increment packed pointer by one element size\n        packedPointer := add(packedPointer, elementSize)\n      } {\n        // Unpack one array element\n        mstore(arrayPointer, shr(leftPaddingBits, mload(packedPointer)))\n      }\n    }\n  }\n}\n"},"node_modules/@latticexyz/store/src/IStoreRead.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { EncodedLengths } from \"./EncodedLengths.sol\";\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { Schema } from \"./Schema.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n/**\n * @title IStoreRead\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n */\ninterface IStoreRead {\n  function getFieldLayout(ResourceId tableId) external view returns (FieldLayout fieldLayout);\n\n  function getValueSchema(ResourceId tableId) external view returns (Schema valueSchema);\n\n  function getKeySchema(ResourceId tableId) external view returns (Schema keySchema);\n\n  /**\n   * Get full record (all fields, static and dynamic data) for the given tableId and key tuple, loading the field layout from storage\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple\n  ) external view returns (bytes memory staticData, EncodedLengths encodedLengths, bytes memory dynamicData);\n\n  /**\n   * Get full record (all fields, static and dynamic data) for the given tableId and key tuple, with the given field layout\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    FieldLayout fieldLayout\n  ) external view returns (bytes memory staticData, EncodedLengths encodedLengths, bytes memory dynamicData);\n\n  /**\n   * Get a single field from the given tableId and key tuple, loading the field layout from storage\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex\n  ) external view returns (bytes memory data);\n\n  /**\n   * Get a single field from the given tableId and key tuple, with the given field layout\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) external view returns (bytes memory data);\n\n  /**\n   * Get a single static field from the given tableId and key tuple, with the given value field layout.\n   * Note: the field value is left-aligned in the returned bytes32, the rest of the word is not zeroed out.\n   * Consumers are expected to truncate the returned value as needed.\n   */\n  function getStaticField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) external view returns (bytes32);\n\n  /**\n   * Get a single dynamic field from the given tableId and key tuple at the given dynamic field index.\n   * (Dynamic field index = field index - number of static fields)\n   */\n  function getDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) external view returns (bytes memory);\n\n  /**\n   * Get the byte length of a single field from the given tableId and key tuple, loading the field layout from storage\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) external view returns (uint256);\n\n  /**\n   * Get the byte length of a single field from the given tableId and key tuple, with the given value field layout\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) external view returns (uint256);\n\n  /**\n   * Get the byte length of a single dynamic field from the given tableId and key tuple\n   */\n  function getDynamicFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) external view returns (uint256);\n\n  /**\n   * Get a byte slice (including start, excluding end) of a single dynamic field from the given tableId and key tuple, with the given value field layout.\n   * The slice is unchecked and will return invalid data if `start`:`end` overflow.\n   */\n  function getDynamicFieldSlice(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 start,\n    uint256 end\n  ) external view returns (bytes memory data);\n}\n"},"node_modules/@latticexyz/store/src/IStoreWrite.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { IStoreEvents } from \"./IStoreEvents.sol\";\nimport { EncodedLengths } from \"./EncodedLengths.sol\";\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n/**\n * @title IStoreWrite\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n */\ninterface IStoreWrite is IStoreEvents {\n  // Set full record (including full dynamic data)\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    bytes calldata staticData,\n    EncodedLengths encodedLengths,\n    bytes calldata dynamicData\n  ) external;\n\n  // Splice data in the static part of the record\n  function spliceStaticData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint48 start,\n    bytes calldata data\n  ) external;\n\n  // Splice data in the dynamic part of the record\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes calldata data\n  ) external;\n\n  // Set partial data at field index\n  function setField(ResourceId tableId, bytes32[] calldata keyTuple, uint8 fieldIndex, bytes calldata data) external;\n\n  // Set partial data at field index\n  function setField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) external;\n\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) external;\n\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata data\n  ) external;\n\n  // Push encoded items to the dynamic field at field index\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata dataToPush\n  ) external;\n\n  // Pop byte length from the dynamic field at field index\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) external;\n\n  // Set full record (including full dynamic data)\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple) external;\n}\n"},"node_modules/@latticexyz/store/src/codegen/tables/StoreHooks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\n// Import store internals\nimport { IStore } from \"../../IStore.sol\";\nimport { StoreSwitch } from \"../../StoreSwitch.sol\";\nimport { StoreCore } from \"../../StoreCore.sol\";\nimport { Bytes } from \"../../Bytes.sol\";\nimport { Memory } from \"../../Memory.sol\";\nimport { SliceLib } from \"../../Slice.sol\";\nimport { EncodeArray } from \"../../tightcoder/EncodeArray.sol\";\nimport { FieldLayout } from \"../../FieldLayout.sol\";\nimport { Schema } from \"../../Schema.sol\";\nimport { EncodedLengths, EncodedLengthsLib } from \"../../EncodedLengths.sol\";\nimport { ResourceId } from \"../../ResourceId.sol\";\n\n// Import user types\nimport { ResourceId } from \"../../ResourceId.sol\";\n\nlibrary StoreHooks {\n  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: \"store\", name: \"StoreHooks\", typeId: RESOURCE_TABLE });`\n  ResourceId constant _tableId = ResourceId.wrap(0x746273746f726500000000000000000053746f7265486f6f6b73000000000000);\n\n  FieldLayout constant _fieldLayout =\n    FieldLayout.wrap(0x0000000100000000000000000000000000000000000000000000000000000000);\n\n  // Hex-encoded key schema of (bytes32)\n  Schema constant _keySchema = Schema.wrap(0x002001005f000000000000000000000000000000000000000000000000000000);\n  // Hex-encoded value schema of (bytes21[])\n  Schema constant _valueSchema = Schema.wrap(0x00000001b6000000000000000000000000000000000000000000000000000000);\n\n  /**\n   * @notice Get the table's key field names.\n   * @return keyNames An array of strings with the names of key fields.\n   */\n  function getKeyNames() internal pure returns (string[] memory keyNames) {\n    keyNames = new string[](1);\n    keyNames[0] = \"tableId\";\n  }\n\n  /**\n   * @notice Get the table's value field names.\n   * @return fieldNames An array of strings with the names of value fields.\n   */\n  function getFieldNames() internal pure returns (string[] memory fieldNames) {\n    fieldNames = new string[](1);\n    fieldNames[0] = \"hooks\";\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function register() internal {\n    StoreSwitch.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function _register() internal {\n    StoreCore.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Get hooks.\n   */\n  function getHooks(ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /**\n   * @notice Get hooks.\n   */\n  function _getHooks(ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /**\n   * @notice Get hooks.\n   */\n  function get(ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /**\n   * @notice Get hooks.\n   */\n  function _get(ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /**\n   * @notice Set hooks.\n   */\n  function setHooks(ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Set hooks.\n   */\n  function _setHooks(ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Set hooks.\n   */\n  function set(ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Set hooks.\n   */\n  function _set(ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Get the length of hooks.\n   */\n  function lengthHooks(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * @notice Get the length of hooks.\n   */\n  function _lengthHooks(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * @notice Get the length of hooks.\n   */\n  function length(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * @notice Get the length of hooks.\n   */\n  function _length(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * @notice Get an item of hooks.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function getItemHooks(ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * @notice Get an item of hooks.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function _getItemHooks(ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * @notice Get an item of hooks.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function getItem(ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * @notice Get an item of hooks.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function _getItem(ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * @notice Push an element to hooks.\n   */\n  function pushHooks(ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /**\n   * @notice Push an element to hooks.\n   */\n  function _pushHooks(ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /**\n   * @notice Push an element to hooks.\n   */\n  function push(ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /**\n   * @notice Push an element to hooks.\n   */\n  function _push(ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /**\n   * @notice Pop an element from hooks.\n   */\n  function popHooks(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * @notice Pop an element from hooks.\n   */\n  function _popHooks(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * @notice Pop an element from hooks.\n   */\n  function pop(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * @notice Pop an element from hooks.\n   */\n  function _pop(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * @notice Update an element of hooks at `_index`.\n   */\n  function updateHooks(ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Update an element of hooks at `_index`.\n   */\n  function _updateHooks(ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Update an element of hooks at `_index`.\n   */\n  function update(ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Update an element of hooks at `_index`.\n   */\n  function _update(ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function deleteRecord(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function _deleteRecord(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);\n  }\n\n  /**\n   * @notice Tightly pack dynamic data lengths using this table's schema.\n   * @return _encodedLengths The lengths of the dynamic fields (packed into a single bytes32 value).\n   */\n  function encodeLengths(bytes21[] memory hooks) internal pure returns (EncodedLengths _encodedLengths) {\n    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits\n    unchecked {\n      _encodedLengths = EncodedLengthsLib.pack(hooks.length * 21);\n    }\n  }\n\n  /**\n   * @notice Tightly pack dynamic (variable length) data using this table's schema.\n   * @return The dynamic data, encoded into a sequence of bytes.\n   */\n  function encodeDynamic(bytes21[] memory hooks) internal pure returns (bytes memory) {\n    return abi.encodePacked(EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Encode all of a record's fields.\n   * @return The static (fixed length) data, encoded into a sequence of bytes.\n   * @return The lengths of the dynamic fields (packed into a single bytes32 value).\n   * @return The dynamic (variable length) data, encoded into a sequence of bytes.\n   */\n  function encode(bytes21[] memory hooks) internal pure returns (bytes memory, EncodedLengths, bytes memory) {\n    bytes memory _staticData;\n    EncodedLengths _encodedLengths = encodeLengths(hooks);\n    bytes memory _dynamicData = encodeDynamic(hooks);\n\n    return (_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Encode keys as a bytes32 array using this table's field layout.\n   */\n  function encodeKeyTuple(ResourceId tableId) internal pure returns (bytes32[] memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    return _keyTuple;\n  }\n}\n"},"node_modules/@latticexyz/store/src/codegen/tables/Tables.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\n// Import store internals\nimport { IStore } from \"../../IStore.sol\";\nimport { StoreSwitch } from \"../../StoreSwitch.sol\";\nimport { StoreCore } from \"../../StoreCore.sol\";\nimport { Bytes } from \"../../Bytes.sol\";\nimport { Memory } from \"../../Memory.sol\";\nimport { SliceLib } from \"../../Slice.sol\";\nimport { EncodeArray } from \"../../tightcoder/EncodeArray.sol\";\nimport { FieldLayout } from \"../../FieldLayout.sol\";\nimport { Schema } from \"../../Schema.sol\";\nimport { EncodedLengths, EncodedLengthsLib } from \"../../EncodedLengths.sol\";\nimport { ResourceId } from \"../../ResourceId.sol\";\n\n// Import user types\nimport { ResourceId } from \"../../ResourceId.sol\";\nimport { FieldLayout } from \"../../FieldLayout.sol\";\nimport { Schema } from \"../../Schema.sol\";\n\nstruct TablesData {\n  FieldLayout fieldLayout;\n  Schema keySchema;\n  Schema valueSchema;\n  bytes abiEncodedKeyNames;\n  bytes abiEncodedFieldNames;\n}\n\nlibrary Tables {\n  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: \"store\", name: \"Tables\", typeId: RESOURCE_TABLE });`\n  ResourceId constant _tableId = ResourceId.wrap(0x746273746f72650000000000000000005461626c657300000000000000000000);\n\n  FieldLayout constant _fieldLayout =\n    FieldLayout.wrap(0x0060030220202000000000000000000000000000000000000000000000000000);\n\n  // Hex-encoded key schema of (bytes32)\n  Schema constant _keySchema = Schema.wrap(0x002001005f000000000000000000000000000000000000000000000000000000);\n  // Hex-encoded value schema of (bytes32, bytes32, bytes32, bytes, bytes)\n  Schema constant _valueSchema = Schema.wrap(0x006003025f5f5fc4c40000000000000000000000000000000000000000000000);\n\n  /**\n   * @notice Get the table's key field names.\n   * @return keyNames An array of strings with the names of key fields.\n   */\n  function getKeyNames() internal pure returns (string[] memory keyNames) {\n    keyNames = new string[](1);\n    keyNames[0] = \"tableId\";\n  }\n\n  /**\n   * @notice Get the table's value field names.\n   * @return fieldNames An array of strings with the names of value fields.\n   */\n  function getFieldNames() internal pure returns (string[] memory fieldNames) {\n    fieldNames = new string[](5);\n    fieldNames[0] = \"fieldLayout\";\n    fieldNames[1] = \"keySchema\";\n    fieldNames[2] = \"valueSchema\";\n    fieldNames[3] = \"abiEncodedKeyNames\";\n    fieldNames[4] = \"abiEncodedFieldNames\";\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function register() internal {\n    StoreSwitch.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function _register() internal {\n    StoreCore.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Get fieldLayout.\n   */\n  function getFieldLayout(ResourceId tableId) internal view returns (FieldLayout fieldLayout) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return FieldLayout.wrap(bytes32(_blob));\n  }\n\n  /**\n   * @notice Get fieldLayout.\n   */\n  function _getFieldLayout(ResourceId tableId) internal view returns (FieldLayout fieldLayout) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return FieldLayout.wrap(bytes32(_blob));\n  }\n\n  /**\n   * @notice Set fieldLayout.\n   */\n  function setFieldLayout(ResourceId tableId, FieldLayout fieldLayout) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked(FieldLayout.unwrap(fieldLayout)), _fieldLayout);\n  }\n\n  /**\n   * @notice Set fieldLayout.\n   */\n  function _setFieldLayout(ResourceId tableId, FieldLayout fieldLayout) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked(FieldLayout.unwrap(fieldLayout)), _fieldLayout);\n  }\n\n  /**\n   * @notice Get keySchema.\n   */\n  function getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 1, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /**\n   * @notice Get keySchema.\n   */\n  function _getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 1, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /**\n   * @notice Set keySchema.\n   */\n  function setKeySchema(ResourceId tableId, Schema keySchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked(Schema.unwrap(keySchema)), _fieldLayout);\n  }\n\n  /**\n   * @notice Set keySchema.\n   */\n  function _setKeySchema(ResourceId tableId, Schema keySchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked(Schema.unwrap(keySchema)), _fieldLayout);\n  }\n\n  /**\n   * @notice Get valueSchema.\n   */\n  function getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 2, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /**\n   * @notice Get valueSchema.\n   */\n  function _getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 2, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /**\n   * @notice Set valueSchema.\n   */\n  function setValueSchema(ResourceId tableId, Schema valueSchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked(Schema.unwrap(valueSchema)), _fieldLayout);\n  }\n\n  /**\n   * @notice Set valueSchema.\n   */\n  function _setValueSchema(ResourceId tableId, Schema valueSchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked(Schema.unwrap(valueSchema)), _fieldLayout);\n  }\n\n  /**\n   * @notice Get abiEncodedKeyNames.\n   */\n  function getAbiEncodedKeyNames(ResourceId tableId) internal view returns (bytes memory abiEncodedKeyNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (bytes(_blob));\n  }\n\n  /**\n   * @notice Get abiEncodedKeyNames.\n   */\n  function _getAbiEncodedKeyNames(ResourceId tableId) internal view returns (bytes memory abiEncodedKeyNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (bytes(_blob));\n  }\n\n  /**\n   * @notice Set abiEncodedKeyNames.\n   */\n  function setAbiEncodedKeyNames(ResourceId tableId, bytes memory abiEncodedKeyNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, bytes((abiEncodedKeyNames)));\n  }\n\n  /**\n   * @notice Set abiEncodedKeyNames.\n   */\n  function _setAbiEncodedKeyNames(ResourceId tableId, bytes memory abiEncodedKeyNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, bytes((abiEncodedKeyNames)));\n  }\n\n  /**\n   * @notice Get the length of abiEncodedKeyNames.\n   */\n  function lengthAbiEncodedKeyNames(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /**\n   * @notice Get the length of abiEncodedKeyNames.\n   */\n  function _lengthAbiEncodedKeyNames(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /**\n   * @notice Get an item of abiEncodedKeyNames.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function getItemAbiEncodedKeyNames(ResourceId tableId, uint256 _index) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /**\n   * @notice Get an item of abiEncodedKeyNames.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function _getItemAbiEncodedKeyNames(ResourceId tableId, uint256 _index) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /**\n   * @notice Push a slice to abiEncodedKeyNames.\n   */\n  function pushAbiEncodedKeyNames(ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, bytes((_slice)));\n  }\n\n  /**\n   * @notice Push a slice to abiEncodedKeyNames.\n   */\n  function _pushAbiEncodedKeyNames(ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, bytes((_slice)));\n  }\n\n  /**\n   * @notice Pop a slice from abiEncodedKeyNames.\n   */\n  function popAbiEncodedKeyNames(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 1);\n  }\n\n  /**\n   * @notice Pop a slice from abiEncodedKeyNames.\n   */\n  function _popAbiEncodedKeyNames(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 1);\n  }\n\n  /**\n   * @notice Update a slice of abiEncodedKeyNames at `_index`.\n   */\n  function updateAbiEncodedKeyNames(ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Update a slice of abiEncodedKeyNames at `_index`.\n   */\n  function _updateAbiEncodedKeyNames(ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Get abiEncodedFieldNames.\n   */\n  function getAbiEncodedFieldNames(ResourceId tableId) internal view returns (bytes memory abiEncodedFieldNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 1);\n    return (bytes(_blob));\n  }\n\n  /**\n   * @notice Get abiEncodedFieldNames.\n   */\n  function _getAbiEncodedFieldNames(ResourceId tableId) internal view returns (bytes memory abiEncodedFieldNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 1);\n    return (bytes(_blob));\n  }\n\n  /**\n   * @notice Set abiEncodedFieldNames.\n   */\n  function setAbiEncodedFieldNames(ResourceId tableId, bytes memory abiEncodedFieldNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 1, bytes((abiEncodedFieldNames)));\n  }\n\n  /**\n   * @notice Set abiEncodedFieldNames.\n   */\n  function _setAbiEncodedFieldNames(ResourceId tableId, bytes memory abiEncodedFieldNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 1, bytes((abiEncodedFieldNames)));\n  }\n\n  /**\n   * @notice Get the length of abiEncodedFieldNames.\n   */\n  function lengthAbiEncodedFieldNames(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 1);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /**\n   * @notice Get the length of abiEncodedFieldNames.\n   */\n  function _lengthAbiEncodedFieldNames(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 1);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /**\n   * @notice Get an item of abiEncodedFieldNames.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function getItemAbiEncodedFieldNames(ResourceId tableId, uint256 _index) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /**\n   * @notice Get an item of abiEncodedFieldNames.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function _getItemAbiEncodedFieldNames(ResourceId tableId, uint256 _index) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /**\n   * @notice Push a slice to abiEncodedFieldNames.\n   */\n  function pushAbiEncodedFieldNames(ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 1, bytes((_slice)));\n  }\n\n  /**\n   * @notice Push a slice to abiEncodedFieldNames.\n   */\n  function _pushAbiEncodedFieldNames(ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 1, bytes((_slice)));\n  }\n\n  /**\n   * @notice Pop a slice from abiEncodedFieldNames.\n   */\n  function popAbiEncodedFieldNames(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 1, 1);\n  }\n\n  /**\n   * @notice Pop a slice from abiEncodedFieldNames.\n   */\n  function _popAbiEncodedFieldNames(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 1, 1);\n  }\n\n  /**\n   * @notice Update a slice of abiEncodedFieldNames at `_index`.\n   */\n  function updateAbiEncodedFieldNames(ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Update a slice of abiEncodedFieldNames at `_index`.\n   */\n  function _updateAbiEncodedFieldNames(ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Get the full data.\n   */\n  function get(ResourceId tableId) internal view returns (TablesData memory _table) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    (bytes memory _staticData, EncodedLengths _encodedLengths, bytes memory _dynamicData) = StoreSwitch.getRecord(\n      _tableId,\n      _keyTuple,\n      _fieldLayout\n    );\n    return decode(_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Get the full data.\n   */\n  function _get(ResourceId tableId) internal view returns (TablesData memory _table) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    (bytes memory _staticData, EncodedLengths _encodedLengths, bytes memory _dynamicData) = StoreCore.getRecord(\n      _tableId,\n      _keyTuple,\n      _fieldLayout\n    );\n    return decode(_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Set the full data using individual values.\n   */\n  function set(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal {\n    bytes memory _staticData = encodeStatic(fieldLayout, keySchema, valueSchema);\n\n    EncodedLengths _encodedLengths = encodeLengths(abiEncodedKeyNames, abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(abiEncodedKeyNames, abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Set the full data using individual values.\n   */\n  function _set(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal {\n    bytes memory _staticData = encodeStatic(fieldLayout, keySchema, valueSchema);\n\n    EncodedLengths _encodedLengths = encodeLengths(abiEncodedKeyNames, abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(abiEncodedKeyNames, abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);\n  }\n\n  /**\n   * @notice Set the full data using the data struct.\n   */\n  function set(ResourceId tableId, TablesData memory _table) internal {\n    bytes memory _staticData = encodeStatic(_table.fieldLayout, _table.keySchema, _table.valueSchema);\n\n    EncodedLengths _encodedLengths = encodeLengths(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Set the full data using the data struct.\n   */\n  function _set(ResourceId tableId, TablesData memory _table) internal {\n    bytes memory _staticData = encodeStatic(_table.fieldLayout, _table.keySchema, _table.valueSchema);\n\n    EncodedLengths _encodedLengths = encodeLengths(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);\n  }\n\n  /**\n   * @notice Decode the tightly packed blob of static data using this table's field layout.\n   */\n  function decodeStatic(\n    bytes memory _blob\n  ) internal pure returns (FieldLayout fieldLayout, Schema keySchema, Schema valueSchema) {\n    fieldLayout = FieldLayout.wrap(Bytes.getBytes32(_blob, 0));\n\n    keySchema = Schema.wrap(Bytes.getBytes32(_blob, 32));\n\n    valueSchema = Schema.wrap(Bytes.getBytes32(_blob, 64));\n  }\n\n  /**\n   * @notice Decode the tightly packed blob of dynamic data using the encoded lengths.\n   */\n  function decodeDynamic(\n    EncodedLengths _encodedLengths,\n    bytes memory _blob\n  ) internal pure returns (bytes memory abiEncodedKeyNames, bytes memory abiEncodedFieldNames) {\n    uint256 _start;\n    uint256 _end;\n    unchecked {\n      _end = _encodedLengths.atIndex(0);\n    }\n    abiEncodedKeyNames = (bytes(SliceLib.getSubslice(_blob, _start, _end).toBytes()));\n\n    _start = _end;\n    unchecked {\n      _end += _encodedLengths.atIndex(1);\n    }\n    abiEncodedFieldNames = (bytes(SliceLib.getSubslice(_blob, _start, _end).toBytes()));\n  }\n\n  /**\n   * @notice Decode the tightly packed blobs using this table's field layout.\n   * @param _staticData Tightly packed static fields.\n   * @param _encodedLengths Encoded lengths of dynamic fields.\n   * @param _dynamicData Tightly packed dynamic fields.\n   */\n  function decode(\n    bytes memory _staticData,\n    EncodedLengths _encodedLengths,\n    bytes memory _dynamicData\n  ) internal pure returns (TablesData memory _table) {\n    (_table.fieldLayout, _table.keySchema, _table.valueSchema) = decodeStatic(_staticData);\n\n    (_table.abiEncodedKeyNames, _table.abiEncodedFieldNames) = decodeDynamic(_encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function deleteRecord(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function _deleteRecord(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);\n  }\n\n  /**\n   * @notice Tightly pack static (fixed length) data using this table's schema.\n   * @return The static data, encoded into a sequence of bytes.\n   */\n  function encodeStatic(\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(fieldLayout, keySchema, valueSchema);\n  }\n\n  /**\n   * @notice Tightly pack dynamic data lengths using this table's schema.\n   * @return _encodedLengths The lengths of the dynamic fields (packed into a single bytes32 value).\n   */\n  function encodeLengths(\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal pure returns (EncodedLengths _encodedLengths) {\n    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits\n    unchecked {\n      _encodedLengths = EncodedLengthsLib.pack(bytes(abiEncodedKeyNames).length, bytes(abiEncodedFieldNames).length);\n    }\n  }\n\n  /**\n   * @notice Tightly pack dynamic (variable length) data using this table's schema.\n   * @return The dynamic data, encoded into a sequence of bytes.\n   */\n  function encodeDynamic(\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(bytes((abiEncodedKeyNames)), bytes((abiEncodedFieldNames)));\n  }\n\n  /**\n   * @notice Encode all of a record's fields.\n   * @return The static (fixed length) data, encoded into a sequence of bytes.\n   * @return The lengths of the dynamic fields (packed into a single bytes32 value).\n   * @return The dynamic (variable length) data, encoded into a sequence of bytes.\n   */\n  function encode(\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal pure returns (bytes memory, EncodedLengths, bytes memory) {\n    bytes memory _staticData = encodeStatic(fieldLayout, keySchema, valueSchema);\n\n    EncodedLengths _encodedLengths = encodeLengths(abiEncodedKeyNames, abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(abiEncodedKeyNames, abiEncodedFieldNames);\n\n    return (_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Encode keys as a bytes32 array using this table's field layout.\n   */\n  function encodeKeyTuple(ResourceId tableId) internal pure returns (bytes32[] memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    return _keyTuple;\n  }\n}\n"},"node_modules/@latticexyz/store/src/codegen/tables/ResourceIds.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\n// Import store internals\nimport { IStore } from \"../../IStore.sol\";\nimport { StoreSwitch } from \"../../StoreSwitch.sol\";\nimport { StoreCore } from \"../../StoreCore.sol\";\nimport { Bytes } from \"../../Bytes.sol\";\nimport { Memory } from \"../../Memory.sol\";\nimport { SliceLib } from \"../../Slice.sol\";\nimport { EncodeArray } from \"../../tightcoder/EncodeArray.sol\";\nimport { FieldLayout } from \"../../FieldLayout.sol\";\nimport { Schema } from \"../../Schema.sol\";\nimport { EncodedLengths, EncodedLengthsLib } from \"../../EncodedLengths.sol\";\nimport { ResourceId } from \"../../ResourceId.sol\";\n\n// Import user types\nimport { ResourceId } from \"../../ResourceId.sol\";\n\nlibrary ResourceIds {\n  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: \"store\", name: \"ResourceIds\", typeId: RESOURCE_TABLE });`\n  ResourceId constant _tableId = ResourceId.wrap(0x746273746f72650000000000000000005265736f757263654964730000000000);\n\n  FieldLayout constant _fieldLayout =\n    FieldLayout.wrap(0x0001010001000000000000000000000000000000000000000000000000000000);\n\n  // Hex-encoded key schema of (bytes32)\n  Schema constant _keySchema = Schema.wrap(0x002001005f000000000000000000000000000000000000000000000000000000);\n  // Hex-encoded value schema of (bool)\n  Schema constant _valueSchema = Schema.wrap(0x0001010060000000000000000000000000000000000000000000000000000000);\n\n  /**\n   * @notice Get the table's key field names.\n   * @return keyNames An array of strings with the names of key fields.\n   */\n  function getKeyNames() internal pure returns (string[] memory keyNames) {\n    keyNames = new string[](1);\n    keyNames[0] = \"resourceId\";\n  }\n\n  /**\n   * @notice Get the table's value field names.\n   * @return fieldNames An array of strings with the names of value fields.\n   */\n  function getFieldNames() internal pure returns (string[] memory fieldNames) {\n    fieldNames = new string[](1);\n    fieldNames[0] = \"exists\";\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function register() internal {\n    StoreSwitch.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function _register() internal {\n    StoreCore.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Get exists.\n   */\n  function getExists(ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /**\n   * @notice Get exists.\n   */\n  function _getExists(ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /**\n   * @notice Get exists.\n   */\n  function get(ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /**\n   * @notice Get exists.\n   */\n  function _get(ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /**\n   * @notice Set exists.\n   */\n  function setExists(ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /**\n   * @notice Set exists.\n   */\n  function _setExists(ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /**\n   * @notice Set exists.\n   */\n  function set(ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /**\n   * @notice Set exists.\n   */\n  function _set(ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function deleteRecord(ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function _deleteRecord(ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);\n  }\n\n  /**\n   * @notice Tightly pack static (fixed length) data using this table's schema.\n   * @return The static data, encoded into a sequence of bytes.\n   */\n  function encodeStatic(bool exists) internal pure returns (bytes memory) {\n    return abi.encodePacked(exists);\n  }\n\n  /**\n   * @notice Encode all of a record's fields.\n   * @return The static (fixed length) data, encoded into a sequence of bytes.\n   * @return The lengths of the dynamic fields (packed into a single bytes32 value).\n   * @return The dynamic (variable length) data, encoded into a sequence of bytes.\n   */\n  function encode(bool exists) internal pure returns (bytes memory, EncodedLengths, bytes memory) {\n    bytes memory _staticData = encodeStatic(exists);\n\n    EncodedLengths _encodedLengths;\n    bytes memory _dynamicData;\n\n    return (_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Encode keys as a bytes32 array using this table's field layout.\n   */\n  function encodeKeyTuple(ResourceId resourceId) internal pure returns (bytes32[] memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    return _keyTuple;\n  }\n}\n\n/**\n * @notice Cast a value to a bool.\n * @dev Boolean values are encoded as uint8 (1 = true, 0 = false), but Solidity doesn't allow casting between uint8 and bool.\n * @param value The uint8 value to convert.\n * @return result The boolean value.\n */\nfunction _toBool(uint8 value) pure returns (bool result) {\n  assembly {\n    result := value\n  }\n}\n"},"node_modules/@latticexyz/store/src/codegen/tables/Hooks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/* Autogenerated file. Do not edit manually. */\n\n// Import store internals\nimport { IStore } from \"../../IStore.sol\";\nimport { StoreSwitch } from \"../../StoreSwitch.sol\";\nimport { StoreCore } from \"../../StoreCore.sol\";\nimport { Bytes } from \"../../Bytes.sol\";\nimport { Memory } from \"../../Memory.sol\";\nimport { SliceLib } from \"../../Slice.sol\";\nimport { EncodeArray } from \"../../tightcoder/EncodeArray.sol\";\nimport { FieldLayout } from \"../../FieldLayout.sol\";\nimport { Schema } from \"../../Schema.sol\";\nimport { EncodedLengths, EncodedLengthsLib } from \"../../EncodedLengths.sol\";\nimport { ResourceId } from \"../../ResourceId.sol\";\n\n// Import user types\nimport { ResourceId } from \"../../ResourceId.sol\";\n\nlibrary Hooks {\n  FieldLayout constant _fieldLayout =\n    FieldLayout.wrap(0x0000000100000000000000000000000000000000000000000000000000000000);\n\n  // Hex-encoded key schema of (bytes32)\n  Schema constant _keySchema = Schema.wrap(0x002001005f000000000000000000000000000000000000000000000000000000);\n  // Hex-encoded value schema of (bytes21[])\n  Schema constant _valueSchema = Schema.wrap(0x00000001b6000000000000000000000000000000000000000000000000000000);\n\n  /**\n   * @notice Get the table's key field names.\n   * @return keyNames An array of strings with the names of key fields.\n   */\n  function getKeyNames() internal pure returns (string[] memory keyNames) {\n    keyNames = new string[](1);\n    keyNames[0] = \"resourceId\";\n  }\n\n  /**\n   * @notice Get the table's value field names.\n   * @return fieldNames An array of strings with the names of value fields.\n   */\n  function getFieldNames() internal pure returns (string[] memory fieldNames) {\n    fieldNames = new string[](1);\n    fieldNames[0] = \"hooks\";\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function register(ResourceId _tableId) internal {\n    StoreSwitch.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Register the table with its config.\n   */\n  function _register(ResourceId _tableId) internal {\n    StoreCore.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());\n  }\n\n  /**\n   * @notice Get hooks.\n   */\n  function getHooks(ResourceId _tableId, ResourceId resourceId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /**\n   * @notice Get hooks.\n   */\n  function _getHooks(ResourceId _tableId, ResourceId resourceId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /**\n   * @notice Get hooks.\n   */\n  function get(ResourceId _tableId, ResourceId resourceId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /**\n   * @notice Get hooks.\n   */\n  function _get(ResourceId _tableId, ResourceId resourceId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /**\n   * @notice Set hooks.\n   */\n  function setHooks(ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Set hooks.\n   */\n  function _setHooks(ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Set hooks.\n   */\n  function set(ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Set hooks.\n   */\n  function _set(ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Get the length of hooks.\n   */\n  function lengthHooks(ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * @notice Get the length of hooks.\n   */\n  function _lengthHooks(ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * @notice Get the length of hooks.\n   */\n  function length(ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * @notice Get the length of hooks.\n   */\n  function _length(ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * @notice Get an item of hooks.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function getItemHooks(ResourceId _tableId, ResourceId resourceId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * @notice Get an item of hooks.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function _getItemHooks(ResourceId _tableId, ResourceId resourceId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * @notice Get an item of hooks.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function getItem(ResourceId _tableId, ResourceId resourceId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * @notice Get an item of hooks.\n   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.\n   */\n  function _getItem(ResourceId _tableId, ResourceId resourceId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * @notice Push an element to hooks.\n   */\n  function pushHooks(ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /**\n   * @notice Push an element to hooks.\n   */\n  function _pushHooks(ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /**\n   * @notice Push an element to hooks.\n   */\n  function push(ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /**\n   * @notice Push an element to hooks.\n   */\n  function _push(ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /**\n   * @notice Pop an element from hooks.\n   */\n  function popHooks(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * @notice Pop an element from hooks.\n   */\n  function _popHooks(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * @notice Pop an element from hooks.\n   */\n  function pop(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * @notice Pop an element from hooks.\n   */\n  function _pop(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * @notice Update an element of hooks at `_index`.\n   */\n  function updateHooks(ResourceId _tableId, ResourceId resourceId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Update an element of hooks at `_index`.\n   */\n  function _updateHooks(ResourceId _tableId, ResourceId resourceId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Update an element of hooks at `_index`.\n   */\n  function update(ResourceId _tableId, ResourceId resourceId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Update an element of hooks at `_index`.\n   */\n  function _update(ResourceId _tableId, ResourceId resourceId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function deleteRecord(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /**\n   * @notice Delete all data for given keys.\n   */\n  function _deleteRecord(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);\n  }\n\n  /**\n   * @notice Tightly pack dynamic data lengths using this table's schema.\n   * @return _encodedLengths The lengths of the dynamic fields (packed into a single bytes32 value).\n   */\n  function encodeLengths(bytes21[] memory hooks) internal pure returns (EncodedLengths _encodedLengths) {\n    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits\n    unchecked {\n      _encodedLengths = EncodedLengthsLib.pack(hooks.length * 21);\n    }\n  }\n\n  /**\n   * @notice Tightly pack dynamic (variable length) data using this table's schema.\n   * @return The dynamic data, encoded into a sequence of bytes.\n   */\n  function encodeDynamic(bytes21[] memory hooks) internal pure returns (bytes memory) {\n    return abi.encodePacked(EncodeArray.encode((hooks)));\n  }\n\n  /**\n   * @notice Encode all of a record's fields.\n   * @return The static (fixed length) data, encoded into a sequence of bytes.\n   * @return The lengths of the dynamic fields (packed into a single bytes32 value).\n   * @return The dynamic (variable length) data, encoded into a sequence of bytes.\n   */\n  function encode(bytes21[] memory hooks) internal pure returns (bytes memory, EncodedLengths, bytes memory) {\n    bytes memory _staticData;\n    EncodedLengths _encodedLengths = encodeLengths(hooks);\n    bytes memory _dynamicData = encodeDynamic(hooks);\n\n    return (_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * @notice Encode keys as a bytes32 array using this table's field layout.\n   */\n  function encodeKeyTuple(ResourceId resourceId) internal pure returns (bytes32[] memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    return _keyTuple;\n  }\n}\n"},"node_modules/@latticexyz/world/src/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @title IERC165\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @dev Interface for the ERC-165 standard as described in the EIP-165.\n * Allows for contracts to be checked for their support of an interface.\n * See: https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n  /**\n   * @notice Query if a contract implements an interface.\n   * @dev Interface identification is specified in ERC-165.\n   * This function uses less than 30,000 gas.\n   * @param interfaceID The interface identifier, as specified in ERC-165.\n   * @return True if the contract implements `interfaceID` and\n   * `interfaceID` is not 0xffffffff, false otherwise.\n   */\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"node_modules/@latticexyz/world/src/WorldContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\nimport { revertWithBytes } from \"./revertWithBytes.sol\";\nimport { IERC165 } from \"./IERC165.sol\";\nimport { IWorldContextConsumer } from \"./IWorldContextConsumer.sol\";\n\n// The context size is 20 bytes for msg.sender, and 32 bytes for msg.value\nuint256 constant CONTEXT_BYTES = 20 + 32;\n\n/**\n * @title WorldContextConsumer - Extracting trusted context values from appended calldata.\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This contract is designed to extract trusted context values (like msg.sender and msg.value)\n * from the appended calldata. It provides mechanisms similar to EIP-2771 (https://eips.ethereum.org/EIPS/eip-2771),\n * but allowing any contract to be the trusted forwarder.\n * @dev This contract should only be used for contracts without their own storage, like Systems.\n */\nabstract contract WorldContextConsumer is IWorldContextConsumer {\n  /**\n   * @notice Extract the `msg.sender` from the context appended to the calldata.\n   * @return sender The `msg.sender` in the call to the World contract before the World routed the\n   * call to the WorldContextConsumer contract.\n   */\n  function _msgSender() public view virtual returns (address sender) {\n    return WorldContextConsumerLib._msgSender();\n  }\n\n  /**\n   * @notice Extract the `msg.value` from the context appended to the calldata.\n   * @return value The `msg.value` in the call to the World contract before the World routed the\n   * call to the WorldContextConsumer contract.\n   */\n  function _msgValue() public view virtual returns (uint256 value) {\n    return WorldContextConsumerLib._msgValue();\n  }\n\n  /**\n   * @notice Get the address of the World contract that routed the call to this WorldContextConsumer.\n   * @return The address of the World contract that routed the call to this WorldContextConsumer.\n   */\n  function _world() public view returns (address) {\n    return WorldContextConsumerLib._world();\n  }\n\n  /**\n   * @notice Checks if an interface is supported by the contract.\n   * using ERC-165 supportsInterface (see https://eips.ethereum.org/EIPS/eip-165)\n   * @param interfaceId The ID of the interface in question.\n   * @return True if the interface is supported, false otherwise.\n   */\n  function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n    return interfaceId == type(IWorldContextConsumer).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n}\n\n/**\n * @title WorldContextConsumerLib\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice Helpers for working with data in the context of calling a World\n */\nlibrary WorldContextConsumerLib {\n  /**\n   * @notice Extract the `msg.sender` from the context appended to the calldata.\n   * @return sender The `msg.sender` in the call to the World contract before the World routed the\n   * call to the WorldContextConsumer contract.\n   */\n  function _msgSender() internal view returns (address sender) {\n    assembly {\n      // Load 32 bytes from calldata at position calldatasize() - context size,\n      // then shift left 96 bits (to right-align the address)\n      // 96 = 256 - 20 * 8\n      sender := shr(0x60, calldataload(sub(calldatasize(), CONTEXT_BYTES)))\n    }\n    if (sender == address(0)) sender = msg.sender;\n  }\n\n  /**\n   * @notice Extract the `msg.value` from the context appended to the calldata.\n   * @return value The `msg.value` in the call to the World contract before the World routed the\n   * call to the WorldContextConsumer contract.\n   */\n  function _msgValue() internal pure returns (uint256 value) {\n    assembly {\n      // Load 32 bytes from calldata at position calldatasize() - 32 bytes,\n      value := calldataload(sub(calldatasize(), 0x20))\n    }\n  }\n\n  /**\n   * @notice Get the address of the World contract that routed the call to this WorldContextConsumer.\n   * @return The address of the World contract that routed the call to this WorldContextConsumer.\n   */\n  function _world() internal view returns (address) {\n    return StoreSwitch.getStoreAddress();\n  }\n}\n\n/**\n * @title WorldContextProviderLib - Utility functions to call contracts with context values appended to calldata.\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This library provides functions to make calls or delegatecalls to other contracts,\n * appending the context values (like msg.sender and msg.value) to the calldata for WorldContextConsumer to consume.\n */\nlibrary WorldContextProviderLib {\n  /**\n   * @notice Appends context values to the given calldata.\n   * @param callData The original calldata.\n   * @param msgSender The address of the transaction sender.\n   * @param msgValue The amount of ether sent with the original transaction.\n   * @return The new calldata with context values appended.\n   */\n  function appendContext(\n    bytes memory callData,\n    address msgSender,\n    uint256 msgValue\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(callData, msgSender, msgValue);\n  }\n\n  /**\n   * @notice Makes a call to the target contract with context values appended to the calldata.\n   * @param msgSender The address of the transaction sender.\n   * @param msgValue The amount of ether sent with the original transaction.\n   * @param target The address of the contract to call.\n   * @param callData The calldata for the call.\n   * @return success A boolean indicating whether the call was successful or not.\n   * @return data The abi encoded return data from the call.\n   */\n  function callWithContext(\n    address msgSender,\n    uint256 msgValue,\n    address target,\n    bytes memory callData\n  ) internal returns (bool success, bytes memory data) {\n    (success, data) = target.call{ value: 0 }(\n      appendContext({ callData: callData, msgSender: msgSender, msgValue: msgValue })\n    );\n  }\n\n  /**\n   * @notice Makes a staticcall to the target contract with context values appended to the calldata.\n   * @param msgSender The address of the transaction sender.\n   * @param target The address of the contract to call.\n   * @param callData The calldata for the staticcall.\n   * @return success A boolean indicating whether the staticcall was successful or not.\n   * @return data The abi encoded return data from the staticcall.\n   */\n  function staticcallWithContext(\n    address msgSender,\n    address target,\n    bytes memory callData\n  ) internal view returns (bool success, bytes memory data) {\n    (success, data) = target.staticcall(appendContext({ callData: callData, msgSender: msgSender, msgValue: 0 }));\n  }\n\n  /**\n   * @notice Makes a delegatecall to the target contract with context values appended to the calldata.\n   * @param msgSender The address of the transaction sender.\n   * @param msgValue The amount of ether sent with the original transaction.\n   * @param target The address of the contract to call.\n   * @param callData The calldata for the call.\n   * @return success A boolean indicating whether the call was successful or not.\n   * @return data The abi encoded return data from the call.\n   */\n  function delegatecallWithContext(\n    address msgSender,\n    uint256 msgValue,\n    address target,\n    bytes memory callData\n  ) internal returns (bool success, bytes memory data) {\n    (success, data) = target.delegatecall(\n      appendContext({ callData: callData, msgSender: msgSender, msgValue: msgValue })\n    );\n  }\n\n  /**\n   * @notice Makes a call to the target contract with context values appended to the calldata.\n   * @dev Revert in the case of failure.\n   * @param msgSender The address of the transaction sender.\n   * @param msgValue The amount of ether sent with the original transaction.\n   * @param target The address of the contract to call.\n   * @param callData The calldata for the call.\n   * @return data The abi encoded return data from the call.\n   */\n  function callWithContextOrRevert(\n    address msgSender,\n    uint256 msgValue,\n    address target,\n    bytes memory callData\n  ) internal returns (bytes memory data) {\n    (bool success, bytes memory _data) = callWithContext({\n      msgSender: msgSender,\n      msgValue: msgValue,\n      target: target,\n      callData: callData\n    });\n    if (!success) revertWithBytes(_data);\n    return _data;\n  }\n\n  /**\n   * @notice Makes a delegatecall to the target contract with context values appended to the calldata.\n   * @dev Revert in the case of failure.\n   * @param msgSender The address of the transaction sender.\n   * @param msgValue The amount of ether sent with the original transaction.\n   * @param target The address of the contract to call.\n   * @param callData The calldata for the call.\n   * @return data The abi encoded return data from the call.\n   */\n  function delegatecallWithContextOrRevert(\n    address msgSender,\n    uint256 msgValue,\n    address target,\n    bytes memory callData\n  ) internal returns (bytes memory data) {\n    (bool success, bytes memory _data) = delegatecallWithContext({\n      msgSender: msgSender,\n      msgValue: msgValue,\n      target: target,\n      callData: callData\n    });\n    if (!success) revertWithBytes(_data);\n    return _data;\n  }\n}\n"},"node_modules/@latticexyz/world/src/revertWithBytes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\n/**\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n */\n\n/**\n * @notice Reverts the transaction using the provided raw bytes as the revert reason.\n * @dev Uses assembly to perform the revert operation with the raw bytes.\n * @param reason The raw bytes revert reason.\n */\nfunction revertWithBytes(bytes memory reason) pure {\n  assembly {\n    // reason+32 is a pointer to the error message, mload(reason) is the length of the error message\n    revert(add(reason, 0x20), mload(reason))\n  }\n}\n"},"node_modules/@latticexyz/world/src/IWorldContextConsumer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { IERC165 } from \"./IERC165.sol\";\n\n/**\n * @title WorldContextConsumer - Extracting trusted context values from appended calldata.\n * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)\n * @notice This contract is designed to extract trusted context values (like msg.sender and msg.value)\n * from the appended calldata. It provides mechanisms similar to EIP-2771 (https://eips.ethereum.org/EIPS/eip-2771),\n * but allowing any contract to be the trusted forwarder.\n * @dev This contract should only be used for contracts without their own storage, like Systems.\n */\ninterface IWorldContextConsumer is IERC165 {\n  /**\n   * @notice Extract the `msg.sender` from the context appended to the calldata.\n   * @return The address of the `msg.sender` that called the World contract\n   * before the World routed the call to the WorldContextConsumer contract.\n   */\n  function _msgSender() external view returns (address);\n\n  /**\n   * @notice Extract the `msg.value` from the context appended to the calldata.\n   * @return The `msg.value` in the call to the World contract before the World routed the\n   * call to the WorldContextConsumer contract.\n   */\n  function _msgValue() external view returns (uint256);\n\n  /**\n   * @notice Get the address of the World contract that routed the call to this WorldContextConsumer.\n   * @return The address of the World contract that routed the call to this WorldContextConsumer.\n   */\n  function _world() external view returns (address);\n}\n"}},"settings":{"remappings":["forge-std/=node_modules/forge-std/src/","@latticexyz/=node_modules/@latticexyz/","@openzeppelin/=node_modules/@openzeppelin/","@chainlink/=node_modules/@chainlink/","@dk1a/=node_modules/@dk1a/"],"optimizer":{"enabled":true,"runs":3000},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
