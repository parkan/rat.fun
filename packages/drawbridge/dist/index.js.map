{"version":3,"sources":["../src/types/state.ts","../src/types/mud.ts","../src/session/core/storage.ts","../src/session/core/signer.ts","../src/session/core/account.ts","../src/bundler/paymaster.ts","../src/bundler/client.ts","../src/bundler/transport.ts","../src/session/core/client.ts","../src/session/delegation/check.ts","../src/session/patterns/wallet-deployment.ts","../src/session/delegation/shared.ts","../src/session/delegation/smart-account.ts","../src/session/patterns/eip712-signing.ts","../src/session/patterns/call-with-signature.ts","../src/session/delegation/eoa.ts","../src/session/delegation/setup.ts","../src/wallet/config.ts","../src/wallet/watcher.ts","../src/wallet/connection.ts","../src/Drawbridge.ts"],"names":["DrawbridgeStatus","viem_createBundlerClient","getAction","sendUserOperation","waitForUserOperationReceipt","getRecord","viem_writeContract","worldSystemsConfig","waitForTransactionReceipt"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Drawbridge connection and setup status\n *\n * Provides a single source of truth for the current state of Drawbridge.\n * Transitions follow this flow:\n *\n * UNINITIALIZED → initialize() → DISCONNECTED\n *                                      ↓\n *                      connectWallet() ↓\n *                                      ↓\n *                                 CONNECTED\n *                                      ↓\n *                      setupSession()  ↓\n *                                      ↓\n *                             SETTING_UP_SESSION\n *                                      ↓\n *                                   READY\n *\n * Note: READY state can be reached directly from DISCONNECTED if reconnection succeeds.\n */\nexport enum DrawbridgeStatus {\n  /** Drawbridge not yet initialized - call initialize() */\n  UNINITIALIZED = \"uninitialized\",\n\n  /** Drawbridge initialized but no wallet connected */\n  DISCONNECTED = \"disconnected\",\n\n  /** Wallet connection in progress */\n  CONNECTING = \"connecting\",\n\n  /** Wallet connected, but session setup needed (delegation not registered) */\n  CONNECTED = \"connected\",\n\n  /** Session setup in progress (registering delegation) */\n  SETTING_UP_SESSION = \"setting_up_session\",\n\n  /** Fully ready - session client available and delegation registered */\n  READY = \"ready\",\n\n  /** An error occurred */\n  ERROR = \"error\"\n}\n","import { resourceToHex } from \"@latticexyz/common\"\nimport { parseAbi, ClientConfig } from \"viem\"\nimport worldConfig from \"@latticexyz/world/mud.config\"\n\n/**\n * Default viem client configuration\n * Polling interval for watching blockchain state\n */\nexport const defaultClientConfig = {\n  pollingInterval: 250\n} as const satisfies Pick<ClientConfig, \"pollingInterval\">\n\n/**\n * MUD delegation control ID for \"unlimited\" delegation\n *\n * This is a resource ID that identifies the unlimited delegation control system.\n * When a user delegates to a session account with this ID, the session account\n * can call any system in the World on behalf of the user.\n *\n * Format: system resource with namespace=\"\" and name=\"unlimited\"\n */\nexport const unlimitedDelegationControlId = resourceToHex({\n  type: \"system\",\n  namespace: \"\",\n  name: \"unlimited\"\n})\n\n/**\n * MUD World table definitions from world config\n * Used to query World state (e.g., UserDelegationControl table)\n */\nexport const worldTables = worldConfig.namespaces.world.tables\n\n/**\n * Minimal World ABI for delegation registration\n * Full ABI is large, we only need this one function\n */\nexport const worldAbi = parseAbi([\n  \"function registerDelegation(address delegatee, bytes32 delegationControlId, bytes initCallData)\"\n])\n","import { Address, Hex } from \"viem\"\n\ntype SessionStore = {\n  signers: Record<string, string> // lowercase address → private key\n}\n\n/**\n * Session key storage using localStorage\n *\n * Manages persistent session private keys for each user address.\n * Keys are stored in localStorage and survive page refreshes.\n *\n * Storage format: { signers: { \"0xabc...\": \"0x123...\" } }\n * Storage key: \"entrykit:session-signers\"\n */\nexport class SessionStorage {\n  private cache: SessionStore\n  private readonly STORAGE_KEY = \"entrykit:session-signers\"\n\n  constructor() {\n    this.cache = this.load()\n  }\n\n  /**\n   * Load session store from localStorage\n   */\n  private load(): SessionStore {\n    if (typeof localStorage === \"undefined\") {\n      return { signers: {} }\n    }\n\n    const stored = localStorage.getItem(this.STORAGE_KEY)\n    if (!stored) {\n      return { signers: {} }\n    }\n\n    try {\n      return JSON.parse(stored)\n    } catch {\n      return { signers: {} }\n    }\n  }\n\n  /**\n   * Save session store to localStorage\n   */\n  private save(): void {\n    if (typeof localStorage === \"undefined\") return\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.cache))\n  }\n\n  /**\n   * Get session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @returns Private key if exists, undefined otherwise\n   */\n  getSigner(address: Address): Hex | undefined {\n    const key = address.toLowerCase()\n    return this.cache.signers[key] as Hex | undefined\n  }\n\n  /**\n   * Store session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @param privateKey Session private key to store\n   */\n  setSigner(address: Address, privateKey: Hex): void {\n    const key = address.toLowerCase()\n    this.cache.signers[key] = privateKey\n    this.save()\n  }\n\n  /**\n   * Remove session signer for a user address\n   *\n   * @param address User's wallet address\n   */\n  removeSigner(address: Address): void {\n    const key = address.toLowerCase()\n    delete this.cache.signers[key]\n    this.save()\n  }\n\n  /**\n   * Clear all session signers\n   */\n  clear(): void {\n    this.cache = { signers: {} }\n    this.save()\n  }\n}\n\n/**\n * Singleton session storage instance\n */\nexport const sessionStorage = new SessionStorage()\n","import { Address, Hex, isHex } from \"viem\"\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\"\nimport { sessionStorage } from \"./storage\"\n\n/**\n * Get or create session signer for a user address\n *\n * Session signers are persistent private keys stored in localStorage.\n * They're used as the owner of the session smart account.\n *\n * If no signer exists for this user:\n * - Attempts to migrate from old MUD AccountKit storage format\n * - Otherwise generates a fresh random private key\n * - Stores the key for future use\n *\n * @param userAddress User's wallet address\n * @returns LocalAccount (viem account from private key)\n */\nexport function getSessionSigner(userAddress: Address) {\n  let privateKey = sessionStorage.getSigner(userAddress)\n\n  if (!privateKey) {\n    // Attempt to migrate from legacy MUD AccountKit storage format\n    // This allows existing users to keep their session accounts\n    const deprecatedKey =\n      typeof localStorage !== \"undefined\"\n        ? localStorage\n            .getItem(`mud:appSigner:privateKey:${userAddress.toLowerCase()}`)\n            ?.replace(/^\"(.*)\"$/, \"$1\") // Remove JSON quotes if present\n        : null\n\n    // Use migrated key if valid, otherwise generate new random key\n    privateKey = (isHex(deprecatedKey) ? deprecatedKey : generatePrivateKey()) as Hex\n    sessionStorage.setSigner(userAddress, privateKey)\n  }\n\n  return privateKeyToAccount(privateKey)\n}\n","import { Address, Chain, Client, LocalAccount, Transport } from \"viem\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { toSimpleSmartAccount } from \"permissionless/accounts\"\nimport { getSessionSigner } from \"./signer\"\n\nexport type GetSessionAccountReturnType = {\n  readonly account: SmartAccount\n  readonly signer: LocalAccount\n}\n\nexport async function getSessionAccount<chain extends Chain>({\n  client,\n  userAddress\n}: {\n  client: Client<Transport, chain>\n  userAddress: Address\n}): Promise<GetSessionAccountReturnType> {\n  const signer = getSessionSigner(userAddress)\n  const account = await toSimpleSmartAccount({ client, owner: signer })\n  return { account, signer }\n}\n","import { Chain, Hex } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\n\n/**\n * Paymaster configuration\n *\n * Paymasters sponsor gas for user operations (ERC-4337).\n * Two types supported:\n *\n * - **simple**: Basic paymaster with just an address\n *   Returns paymaster address with empty data\n *\n * - **custom**: Advanced paymaster with client\n *   Uses provided PaymasterClient for dynamic sponsorship logic\n *   (e.g., Coinbase Paymaster, Pimlico, etc.)\n */\nexport type Paymaster =\n  | {\n      readonly type: \"simple\"\n      readonly address: Hex\n    }\n  | {\n      readonly type: \"custom\"\n      readonly address?: Hex\n      readonly paymasterClient: PaymasterClient\n    }\n\n/**\n * Get paymaster configuration for a chain\n *\n * Priority:\n * 1. Use paymasterOverride if provided (custom paymaster client)\n * 2. Check chain.contracts.paymaster for simple paymaster address\n * 3. Return undefined if no paymaster configured (user pays own gas)\n *\n * @param chain Chain configuration\n * @param paymasterOverride Optional custom paymaster client\n * @returns Paymaster config or undefined\n */\nexport function getPaymaster(\n  chain: Chain,\n  paymasterOverride?: PaymasterClient\n): Paymaster | undefined {\n  const contracts = chain.contracts ?? {}\n\n  // Use custom paymaster if provided (e.g., Coinbase Paymaster)\n  if (paymasterOverride) {\n    return {\n      type: \"custom\",\n      paymasterClient: paymasterOverride\n    }\n  }\n\n  // Check for simple paymaster in chain config\n  if (\"paymaster\" in contracts && contracts.paymaster != null) {\n    if (\"address\" in contracts.paymaster) {\n      return {\n        type: \"simple\",\n        address: contracts.paymaster.address\n      }\n    }\n  }\n\n  // No paymaster configured - user pays own gas\n  return undefined\n}\n","import { Transport, Chain, Client, RpcSchema, EstimateFeesPerGasReturnType } from \"viem\"\nimport {\n  BundlerClient,\n  BundlerClientConfig,\n  SmartAccount,\n  PaymasterClient,\n  createBundlerClient as viem_createBundlerClient\n} from \"viem/account-abstraction\"\nimport { defaultClientConfig } from \"../types\"\nimport { getPaymaster } from \"./paymaster\"\n\n/**\n * Create a bundler client for submitting ERC-4337 user operations\n *\n * A bundler client is a specialized viem client that:\n * - Submits user operations to the bundler RPC\n * - Handles gas estimation for user operations\n * - Integrates paymaster for gas sponsorship\n * - Manages smart account interactions\n *\n * This function wraps viem's createBundlerClient with:\n * - Automatic paymaster configuration from chain or override\n * - Custom fee estimation for Anvil (local dev)\n * - Default polling interval\n *\n * @param config Bundler client configuration\n * @returns Configured bundler client\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain = Chain,\n  account extends SmartAccount = SmartAccount,\n  client extends Client = Client,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  config: BundlerClientConfig<transport, chain, account, client, rpcSchema>\n): BundlerClient<transport, chain, account, client, rpcSchema> {\n  const client = config.client\n  if (!client) throw new Error(\"No `client` provided to `createBundlerClient`.\")\n\n  const chain = config.chain ?? client.chain\n  const paymaster = chain\n    ? getPaymaster(chain, config.paymaster as PaymasterClient | undefined)\n    : undefined\n\n  return viem_createBundlerClient({\n    ...defaultClientConfig,\n    // Configure paymaster for gas sponsorship\n    paymaster: paymaster\n      ? paymaster.type === \"custom\"\n        ? paymaster.paymasterClient // Use custom paymaster client (e.g., Coinbase)\n        : {\n            // Simple paymaster - just return address with empty data\n            getPaymasterData: async () => ({\n              paymaster: paymaster.address,\n              paymasterData: \"0x\"\n            })\n          }\n      : undefined,\n    // Custom fee estimation for certain chains\n    userOperation: {\n      estimateFeesPerGas: createFeeEstimator(client)\n    },\n    ...config\n  })\n}\n\n/**\n * Create custom fee estimator for specific chains\n *\n * Some chains need special handling for fee estimation:\n *\n * - **Anvil (31337)**: Hardcoded fees because Anvil's eth_maxPriorityFeePerGas\n *   returns a fixed value that doesn't match real chains\n *\n * - **Other chains**: Use viem's default fee estimation (works well)\n *\n * @param client Viem client\n * @returns Fee estimator function or undefined for default behavior\n */\nfunction createFeeEstimator(\n  client: Client\n): undefined | (() => Promise<EstimateFeesPerGasReturnType<\"eip1559\">>) {\n  if (!client.chain) return\n\n  // Anvil (local development) - use fixed fees\n  // See: https://github.com/foundry-rs/foundry/pull/8081#issuecomment-2402002485\n  if (client.chain.id === 31337) {\n    return async () => ({ maxFeePerGas: 100_000n, maxPriorityFeePerGas: 0n })\n  }\n\n  // All other chains - use viem's default fee estimation\n  return undefined\n}\n","import { Chain, http } from \"viem\"\n\n/**\n * Get bundler RPC transport for a chain\n *\n * Bundlers are special RPC endpoints that handle ERC-4337 user operations.\n * They submit user operations to the EntryPoint contract and handle gas sponsorship.\n *\n * The bundler URL must be configured in the chain's rpcUrls.bundler.http array.\n *\n * @param chain Chain configuration with bundler RPC URL\n * @returns HTTP transport for the bundler\n * @throws If chain doesn't have a bundler RPC URL configured\n */\nexport function getBundlerTransport(chain: Chain) {\n  const bundlerHttpUrl = chain.rpcUrls.bundler?.http[0]\n\n  if (bundlerHttpUrl) {\n    return http(bundlerHttpUrl)\n  }\n\n  throw new Error(`Chain ${chain.id} config did not include a bundler RPC URL.`)\n}\n","import { Account, Address, Chain, Client, LocalAccount, RpcSchema, Transport } from \"viem\"\nimport { smartAccountActions } from \"permissionless\"\nimport { callFrom, sendUserOperationFrom } from \"@latticexyz/world/internal\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { createBundlerClient } from \"../../bundler/client\"\nimport { SessionClient } from \"../../types\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { getBundlerTransport } from \"../../bundler/transport\"\n\n/**\n * Create session client with MUD World extensions\n *\n * Takes a standard ERC-4337 smart account and extends it with MUD-specific functionality:\n *\n * 1. **smartAccountActions** - Standard AA operations (sendUserOperation, etc.)\n * 2. **callFrom** - Routes writeContract calls through World.callFrom()\n *    - Automatically adds delegator context\n *    - World validates delegation before executing\n * 3. **sendUserOperationFrom** - Routes user operations through World\n * 4. **Context properties** - Adds userAddress, worldAddress, internal_signer\n *\n * The resulting SessionClient can call World systems on behalf of the user,\n * as long as delegation is registered.\n *\n * @param params Session client parameters\n * @returns SessionClient with MUD World extensions\n */\nexport async function getSessionClient({\n  userAddress,\n  sessionAccount,\n  sessionSigner,\n  worldAddress,\n  paymasterOverride\n}: {\n  userAddress: Address\n  sessionAccount: SmartAccount\n  sessionSigner: LocalAccount\n  worldAddress: Address\n  paymasterOverride?: PaymasterClient\n}): Promise<SessionClient> {\n  const client = sessionAccount.client\n  if (!clientHasChain(client)) {\n    throw new Error(\"Session account client had no associated chain.\")\n  }\n\n  // Create bundler client for submitting user operations\n  const bundlerClient = createBundlerClient({\n    transport: getBundlerTransport(client.chain),\n    client,\n    account: sessionAccount,\n    paymaster: paymasterOverride\n  })\n\n  // Extend with standard ERC-4337 smart account actions\n  const sessionClient = bundlerClient\n    .extend(smartAccountActions)\n    // Extend with MUD World delegation routing\n    // This intercepts writeContract calls and routes them through World.callFrom()\n    .extend(\n      callFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    // Extend with MUD World user operation routing\n    .extend(\n      sendUserOperationFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    // Add context properties for reference\n    .extend(() => ({ userAddress, worldAddress, internal_signer: sessionSigner }))\n\n  return sessionClient\n}\n\n/**\n * Type guard to ensure client has a chain\n */\nfunction clientHasChain<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  client: Client<transport, chain, account, rpcSchema>\n): client is Client<transport, Exclude<chain, undefined>, account, rpcSchema> {\n  return client.chain != null\n}\n","import { Address, Client } from \"viem\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport { unlimitedDelegationControlId, worldTables } from \"../../types\"\n\nexport type CheckDelegationParams = {\n  client: Client\n  worldAddress: Address\n  userAddress: Address\n  sessionAddress: Address\n  blockTag?: \"pending\" | \"latest\"\n}\n\n/**\n * Check if delegation exists in MUD World contract\n *\n * MUD World stores delegations in the UserDelegationControl table.\n * A delegation allows the session account (delegatee) to call World systems\n * on behalf of the user account (delegator).\n *\n * This function queries that table and checks if \"unlimited\" delegation exists,\n * which grants the session account full access to all systems.\n *\n * @param params Delegation check parameters\n * @returns true if unlimited delegation is registered, false otherwise\n */\nexport async function checkDelegation({\n  client,\n  worldAddress,\n  userAddress,\n  sessionAddress,\n  blockTag = \"pending\"\n}: CheckDelegationParams): Promise<boolean> {\n  // Query MUD Store table: UserDelegationControl[delegator][delegatee]\n  const record = await getRecord(client, {\n    address: worldAddress,\n    table: worldTables.UserDelegationControl,\n    key: { delegator: userAddress, delegatee: sessionAddress },\n    blockTag\n  })\n\n  // Check if the delegation type is \"unlimited\" (full system access)\n  return record.delegationControlId === unlimitedDelegationControlId\n}\n","import { Address, Client } from \"viem\"\nimport { getCode, sendTransaction, waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\n\n/**\n * Smart wallet deployment utilities\n *\n * Handles counterfactual smart wallets (e.g., Coinbase Smart Wallet) that use\n * CREATE2 and exist at a deterministic address before deployment.\n */\n\n/**\n * Check if a smart wallet is deployed on-chain\n *\n * @param client Client to use for checking\n * @param address Wallet address to check\n * @returns True if deployed, false otherwise\n */\nexport async function isWalletDeployed(client: Client, address: Address): Promise<boolean> {\n  const code = await getAction(\n    client,\n    getCode,\n    \"getCode\"\n  )({\n    address\n  })\n\n  return code !== undefined && code !== \"0x\"\n}\n\n/**\n * Deploy a smart wallet using a factory contract\n *\n * This handles the deployment of counterfactual smart wallets. The wallet address\n * already exists (can receive funds) but needs on-chain deployment before it can\n * validate signatures or execute transactions.\n *\n * @param client Client to use for deployment transaction (usually session client with paymaster)\n * @param userAddress User's wallet address to deploy\n * @param factoryAddress Factory contract address that can deploy the wallet\n * @param factoryCalldata Deployment calldata for the factory\n */\nexport async function deployWallet(\n  client: Client,\n  userAddress: Address,\n  factoryAddress: Address,\n  factoryCalldata: Address\n): Promise<void> {\n  try {\n    const txHash = await getAction(\n      client,\n      sendTransaction,\n      \"sendTransaction\"\n    )({\n      account: client.account,\n      chain: client.chain,\n      to: factoryAddress,\n      data: factoryCalldata\n    })\n\n    // Wait for deployment confirmation\n    await getAction(\n      client,\n      waitForTransactionReceipt,\n      \"waitForTransactionReceipt\"\n    )({\n      hash: txHash\n    })\n\n    // Add delay for bundler/paymaster state to update\n    // After deployment, bundlers cache account state and need time to refresh\n    await new Promise(resolve => setTimeout(resolve, 2000))\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n\n    // If already deployed, that's fine\n    if (\n      errorMessage.includes(\"AA10\") ||\n      errorMessage.includes(\"already constructed\") ||\n      errorMessage.includes(\"already deployed\")\n    ) {\n      return\n    }\n\n    throw new Error(`Failed to deploy smart wallet: ${errorMessage}`)\n  }\n}\n\n/**\n * Deploy a smart wallet if it's not already deployed\n *\n * @param client Client to use for deployment\n * @param userAddress User's wallet address\n * @param factoryAddress Factory contract address\n * @param factoryCalldata Deployment calldata\n * @returns True if deployment was needed and completed, false if already deployed\n */\nexport async function deployWalletIfNeeded(\n  client: Client,\n  userAddress: Address,\n  factoryAddress: Address,\n  factoryCalldata: Address\n): Promise<boolean> {\n  const deployed = await isWalletDeployed(client, userAddress)\n\n  if (deployed) {\n    return false\n  }\n\n  await deployWallet(client, userAddress, factoryAddress, factoryCalldata)\n\n  // Verify deployment succeeded\n  const nowDeployed = await isWalletDeployed(client, userAddress)\n  if (!nowDeployed) {\n    throw new Error(\n      `Wallet deployment appeared to succeed but contract code not found at ${userAddress}`\n    )\n  }\n\n  return true\n}\n","import { zeroAddress, Hex, Address } from \"viem\"\nimport {\n  sendUserOperation,\n  waitForUserOperationReceipt,\n  SmartAccount,\n  UserOperationReceipt\n} from \"viem/account-abstraction\"\nimport { getAction } from \"viem/utils\"\nimport { SessionClient } from \"../../types\"\n\n/**\n * Smart account with optional factory properties (internal use only)\n * Some smart account implementations add these properties dynamically\n */\nexport type SmartAccountWithFactory = SmartAccount & {\n  factory?: Address\n  factoryData?: Hex\n}\n\n/**\n * Setup session status updates for progress tracking\n */\nexport type SetupSessionStatus =\n  | { type: \"checking_wallet\"; message: string }\n  | { type: \"deploying_wallet\"; message: string }\n  | { type: \"wallet_deployed\"; message: string }\n  | { type: \"registering_delegation\"; message: string }\n  | { type: \"deploying_session\"; message: string }\n  | { type: \"complete\"; message: string }\n  | { type: \"error\"; message: string; error?: Error }\n\n/**\n * Common parameters for session setup (both EOA and Smart Account)\n */\nexport type SetupSessionBaseParams = {\n  /** Session smart account client with MUD extensions */\n  sessionClient: SessionClient\n  /** MUD World contract address */\n  worldAddress: Hex\n  /** Progress callback for status updates */\n  onStatus?: (status: SetupSessionStatus) => void\n}\n\n/**\n * Deploy session account if not already deployed\n *\n * This function is shared by both EOA and Smart Account setup flows.\n * It deploys the session account (ERC-4337 smart account) by sending\n * an empty user operation.\n *\n * @param sessionClient Session smart account client\n * @param onStatus Optional status callback\n */\nexport async function deploySessionAccount(\n  sessionClient: SessionClient,\n  onStatus?: (status: SetupSessionStatus) => void\n): Promise<void> {\n  const sessionDeployed = await sessionClient.account.isDeployed?.()\n  console.log(\"[drawbridge] Session account deployed:\", sessionDeployed)\n\n  if (sessionDeployed) {\n    console.log(\"[drawbridge] Session account already deployed\")\n    return\n  }\n\n  onStatus?.({ type: \"deploying_session\", message: \"Finalizing session setup...\" })\n\n  try {\n    const hash = await getAction(\n      sessionClient,\n      sendUserOperation,\n      \"sendUserOperation\"\n    )({\n      calls: [{ to: zeroAddress }]\n    })\n\n    console.log(\"[drawbridge] Session deploy tx:\", hash)\n\n    // Add timeout\n    const receiptPromise = getAction(\n      sessionClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n\n    const timeoutPromise = new Promise((_, reject) =>\n      setTimeout(() => reject(new Error(\"Session deployment timeout after 30s\")), 30000)\n    )\n\n    const receipt = (await Promise.race([receiptPromise, timeoutPromise])) as UserOperationReceipt\n\n    if (!receipt.success) {\n      throw new Error(\"Failed to deploy session account\")\n    }\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error)\n    console.error(\"[drawbridge] Session deployment error:\", errorMsg)\n\n    // Check if timeout but actually deployed\n    if (errorMsg.includes(\"timeout\")) {\n      const nowDeployed = await sessionClient.account.isDeployed?.()\n      if (nowDeployed) {\n        console.log(\"[drawbridge] Session deployed despite timeout\")\n        onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n        return\n      }\n    }\n\n    onStatus?.({ type: \"error\", message: \"Session deployment failed\", error: error as Error })\n    throw error\n  }\n}\n","import { sendUserOperation, waitForUserOperationReceipt } from \"viem/account-abstraction\"\nimport { getAction } from \"viem/utils\"\nimport { unlimitedDelegationControlId, worldAbi, ConnectedClient } from \"../../types\"\nimport { deployWalletIfNeeded, isWalletDeployed } from \"../patterns/wallet-deployment\"\nimport { SetupSessionBaseParams, SmartAccountWithFactory, deploySessionAccount } from \"./shared\"\n\nexport type SetupSessionSmartAccountParams = SetupSessionBaseParams & {\n  /** User's connected smart wallet client */\n  userClient: ConnectedClient\n  /** Whether to register delegation (default: true) */\n  registerDelegation?: boolean\n}\n\n/**\n * Setup session for Smart Account wallets\n *\n * Smart Account Flow:\n * 1. Check if user's smart wallet is deployed on-chain\n * 2. Deploy wallet via factory if needed (counterfactual → deployed)\n * 3. Remove factory data from account to prevent deployment conflicts\n * 4. Submit user operation to register delegation in World contract\n * 5. Deploy session account if needed\n *\n * Smart accounts can use ERC-4337 user operations with paymaster sponsorship.\n * However, they may be counterfactual (not yet deployed), requiring deployment first.\n *\n * @param params Setup parameters for smart account\n */\nexport async function setupSessionSmartAccount({\n  userClient,\n  sessionClient,\n  worldAddress,\n  registerDelegation = true,\n  onStatus\n}: SetupSessionSmartAccountParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address\n  const userAddress = userClient.account.address\n\n  console.log(\"[drawbridge] Smart Account setup:\", { userAddress })\n\n  onStatus?.({ type: \"checking_wallet\", message: \"Checking wallet status...\" })\n\n  // CHECK AND DEPLOY USER'S WALLET IF NEEDED\n  const account = userClient.account as SmartAccountWithFactory\n  const factoryArgs = await account.getFactoryArgs()\n  const hasFactoryData = factoryArgs.factory && factoryArgs.factoryData\n\n  console.log(\"[drawbridge] Smart wallet check:\", { hasFactoryData, userAddress })\n\n  const alreadyDeployed = await isWalletDeployed(sessionClient, userAddress)\n\n  if (alreadyDeployed && hasFactoryData) {\n    // Wallet deployed but has factory data - remove it\n    console.log(\"[drawbridge] Removing factory data from deployed wallet\")\n    onStatus?.({ type: \"wallet_deployed\", message: \"Wallet ready\" })\n\n    delete account.factory\n    delete account.factoryData\n    account.factory = undefined\n    account.factoryData = undefined\n\n    console.log(\"[drawbridge] Factory removed:\", { stillHasFactory: !!account.factory })\n  } else if (!alreadyDeployed && hasFactoryData) {\n    // Wallet not deployed - deploy it\n    console.log(\"[drawbridge] Deploying user wallet...\")\n    onStatus?.({ type: \"deploying_wallet\", message: \"Deploying wallet (one-time setup)...\" })\n\n    await deployWalletIfNeeded(\n      sessionClient,\n      userAddress,\n      factoryArgs.factory!,\n      factoryArgs.factoryData!\n    )\n\n    onStatus?.({ type: \"wallet_deployed\", message: \"Wallet deployed successfully!\" })\n\n    // Remove factory/factoryData after deployment\n    delete account.factory\n    delete account.factoryData\n    account.factory = undefined\n    account.factoryData = undefined\n\n    console.log(\"[drawbridge] Wallet deployed, factory removed\")\n  } else {\n    onStatus?.({ type: \"wallet_deployed\", message: \"Wallet ready\" })\n  }\n\n  // Proceed with delegation registration\n  const calls = []\n\n  if (registerDelegation) {\n    calls.push({\n      to: worldAddress,\n      abi: worldAbi,\n      functionName: \"registerDelegation\",\n      args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n    })\n  }\n\n  if (!calls.length) {\n    // No delegation to register, just deploy session account\n    await deploySessionAccount(sessionClient, onStatus)\n    onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n    return\n  }\n\n  onStatus?.({ type: \"registering_delegation\", message: \"Setting up session...\" })\n\n  // Final check: if factory/factoryData still present, try aggressive removal\n  const accountBeforeSend = userClient.account as SmartAccountWithFactory\n  console.log(\"[drawbridge] Before sendUserOperation:\", {\n    hasFactory: !!accountBeforeSend.factory,\n    hasFactoryData: !!accountBeforeSend.factoryData\n  })\n\n  if (accountBeforeSend.factory || accountBeforeSend.factoryData) {\n    console.warn(\"[drawbridge] Factory still present, attempting aggressive removal...\")\n\n    try {\n      Object.defineProperty(accountBeforeSend, \"factory\", {\n        value: undefined,\n        writable: true,\n        configurable: true\n      })\n      Object.defineProperty(accountBeforeSend, \"factoryData\", {\n        value: undefined,\n        writable: true,\n        configurable: true\n      })\n    } catch (err) {\n      console.error(\"[drawbridge] Could not remove factory (readonly property)\")\n    }\n  }\n\n  try {\n    const hash = await getAction(userClient, sendUserOperation, \"sendUserOperation\")({ calls })\n    console.log(\"[drawbridge] User operation sent:\", hash)\n\n    const receipt = await getAction(\n      userClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n\n    if (!receipt.success) {\n      throw new Error(\"User operation failed during session setup\")\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n    console.error(\"[drawbridge] User operation error:\", errorMessage)\n\n    if (errorMessage.includes(\"AA10\") || errorMessage.includes(\"already constructed\")) {\n      const helpfulError = new Error(\n        \"Smart wallet deployment conflict. Please try again - it should work on the second attempt.\"\n      )\n      onStatus?.({ type: \"error\", message: \"Please try again\", error: helpfulError })\n      throw helpfulError\n    }\n\n    onStatus?.({ type: \"error\", message: \"Session setup failed\", error: error as Error })\n    throw error\n  }\n\n  // Deploy session account if needed\n  await deploySessionAccount(sessionClient, onStatus)\n\n  console.log(\"[drawbridge] Smart Account setup complete\")\n  onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n}\n","import { Address, Chain, Client, Hex, OneOf, Transport, toHex } from \"viem\"\nimport { signTypedData } from \"viem/actions\"\nimport { callWithSignatureTypes } from \"@latticexyz/world-module-callwithsignature/internal\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport moduleConfig from \"@latticexyz/world-module-callwithsignature/mud.config\"\nimport { hexToResource } from \"@latticexyz/common\"\nimport { getAction } from \"viem/utils\"\nimport { ConnectedClient } from \"../../types\"\n\nexport type SignCallOptions<chain extends Chain = Chain> = {\n  userClient: ConnectedClient<chain>\n  worldAddress: Address\n  systemId: Hex\n  callData: Hex\n} & OneOf<{ nonce: bigint } | { client: Client<Transport, chain> }>\n\n/**\n * Sign a World system call using EIP-712 (for CallWithSignature pattern)\n *\n * This creates a signature that can be submitted by the session account to execute\n * a call on behalf of the user (EOA).\n *\n * Flow:\n * 1. **Fetch or use nonce** - Each user has a nonce in CallWithSignatureNonces table\n *    Prevents replay attacks\n *\n * 2. **Parse systemId** - MUD system IDs are resource IDs with namespace + name\n *    e.g., \"world:PlayerSystem\" → { namespace: \"world\", name: \"PlayerSystem\" }\n *\n * 3. **Sign EIP-712 message** - User signs typed data with:\n *    - Domain: World contract + chain ID\n *    - Message: signer, system, callData, nonce\n *\n * The resulting signature can be submitted to World.callWithSignature()\n * by the session account, which will validate and execute as the user.\n *\n * **Why this pattern?**\n * - EOAs can't pay gas via paymaster directly (not smart accounts)\n * - User signs message (free, no gas)\n * - Session account submits + pays gas via paymaster\n * - User gets gasless experience!\n *\n * @param options Sign options including user client and call details\n * @returns EIP-712 signature\n */\nexport async function signCall<chain extends Chain = Chain>({\n  userClient,\n  worldAddress,\n  systemId,\n  callData,\n  nonce: initialNonce,\n  client\n}: SignCallOptions<chain>) {\n  // Get nonce for replay protection\n  // Either use provided nonce or fetch from World contract\n  const nonce =\n    initialNonce ??\n    (client\n      ? (\n          await getRecord(client, {\n            address: worldAddress,\n            table: moduleConfig.tables.CallWithSignatureNonces,\n            key: { signer: userClient.account.address },\n            blockTag: \"pending\"\n          })\n        ).nonce\n      : 0n)\n\n  // Parse MUD system ID into namespace and name components\n  const { namespace: systemNamespace, name: systemName } = hexToResource(systemId)\n\n  // Sign EIP-712 typed data\n  // User signs this message, session account will submit it\n  return await getAction(\n    userClient,\n    signTypedData,\n    \"signTypedData\"\n  )({\n    account: userClient.account,\n    // EIP-712 domain bound to World contract and chain\n    domain: {\n      verifyingContract: worldAddress,\n      salt: toHex(userClient.chain.id, { size: 32 })\n    },\n    // MUD's CallWithSignature type definitions\n    types: callWithSignatureTypes,\n    primaryType: \"Call\",\n    // Message contains all call details + nonce\n    message: {\n      signer: userClient.account.address,\n      systemNamespace,\n      systemName,\n      callData,\n      nonce\n    }\n  })\n}\n","import { Chain, parseErc6492Signature } from \"viem\"\nimport { writeContract as viem_writeContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { SignCallOptions, signCall } from \"./eip712-signing\"\nimport CallWithSignatureAbi from \"@latticexyz/world-module-callwithsignature/out/CallWithSignatureSystem.sol/CallWithSignatureSystem.abi.json\"\nimport { ConnectedClient } from \"../../types\"\nimport { deployWalletIfNeeded } from \"./wallet-deployment\"\n\nexport type CallWithSignatureOptions<chain extends Chain = Chain> = SignCallOptions<chain> & {\n  sessionClient: ConnectedClient\n}\n\n/**\n * Call a World system using signature-based execution (for EOAs and smart wallets)\n *\n * MUD's CallWithSignature pattern allows EOAs and smart wallets to execute gasless transactions:\n *\n * 1. User signs an EIP-712 message (free, off-chain)\n * 2. Session account submits the signature + call to World\n * 3. World's CallWithSignatureSystem validates the signature\n * 4. If valid, executes the call as the user (with user's identity)\n *\n * This enables gasless transactions - the session account pays gas via paymaster,\n * but the call executes with the user's permissions/identity.\n *\n * For undeployed smart wallets (e.g., new Coinbase Smart Wallet), this function\n * automatically detects ERC-6492 wrapped signatures and deploys the wallet using\n * the session account before submitting the call.\n *\n * Flow:\n *   User → signs message → Session Account → (deploys wallet if needed) → submits to World\n *   → World validates signature → executes as User\n *\n * @param options Call parameters including user client and session client\n * @returns Transaction hash\n */\nexport async function callWithSignature<chain extends Chain = Chain>({\n  sessionClient,\n  ...opts\n}: CallWithSignatureOptions<chain>) {\n  const rawSignature = await signCall(opts)\n\n  // Check for ERC-6492 wrapped signatures\n  const {\n    address: factoryAddress,\n    data: factoryCalldata,\n    signature\n  } = parseErc6492Signature(rawSignature)\n\n  let finalSignature = signature ?? rawSignature\n\n  if (factoryAddress != null) {\n    // ERC-6492 signature detected - deploy wallet if needed\n    console.log(\"[callWithSignature] ERC-6492 signature detected\")\n\n    await deployWalletIfNeeded(\n      sessionClient,\n      opts.userClient.account.address,\n      factoryAddress,\n      factoryCalldata\n    )\n\n    finalSignature = signature\n  }\n\n  // Submit transaction to World\n  try {\n    return await getAction(\n      sessionClient,\n      viem_writeContract,\n      \"writeContract\"\n    )({\n      address: opts.worldAddress,\n      abi: CallWithSignatureAbi,\n      functionName: \"callWithSignature\",\n      args: [opts.userClient.account.address, opts.systemId, opts.callData, finalSignature]\n    } as never)\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n\n    if (errorMessage.includes(\"AA10\") || errorMessage.includes(\"already constructed\")) {\n      throw new Error(\"Smart wallet was just deployed. Please try again.\")\n    }\n\n    throw error\n  }\n}\n","import { Hex, encodeFunctionData, Client } from \"viem\"\nimport { waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport IBaseWorldAbi from \"@latticexyz/world/out/IBaseWorld.sol/IBaseWorld.abi.json\"\nimport { systemsConfig as worldSystemsConfig } from \"@latticexyz/world/mud.config\"\nimport { unlimitedDelegationControlId, ConnectedClient } from \"../../types\"\nimport { callWithSignature } from \"../patterns/call-with-signature\"\nimport { SetupSessionBaseParams, deploySessionAccount } from \"./shared\"\n\nexport type SetupSessionEOAParams = SetupSessionBaseParams & {\n  /** Public client for reading blockchain state */\n  client: Client\n  /** User's connected EOA wallet client */\n  userClient: ConnectedClient\n  /** Whether to register delegation (default: true) */\n  registerDelegation?: boolean\n}\n\n/**\n * Setup session for EOA wallets\n *\n * EOA Flow (CallWithSignature Pattern):\n * 1. User signs an EIP-712 message off-chain (free, no gas)\n * 2. Session account submits the signature + call to World\n * 3. World.callWithSignature() validates the signature\n * 4. If valid, World registers delegation as the user\n * 5. Deploy session account if needed\n *\n * This enables gasless transactions - the user only signs a message,\n * and the session account pays gas via paymaster to submit it.\n *\n * **Why this approach?**\n * EOAs can't use paymasters directly (they're not smart accounts), so we use\n * the CallWithSignature pattern to enable gasless transactions.\n *\n * @param params Setup parameters for EOA\n */\nexport async function setupSessionEOA({\n  client,\n  userClient,\n  sessionClient,\n  worldAddress,\n  registerDelegation = true,\n  onStatus\n}: SetupSessionEOAParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address\n  const userAddress = userClient.account.address\n\n  console.log(\"[drawbridge] EOA setup:\", { userAddress })\n\n  const txs: Hex[] = []\n\n  if (registerDelegation) {\n    const tx = await callWithSignature({\n      client: sessionClient,\n      userClient,\n      sessionClient,\n      worldAddress,\n      systemId: worldSystemsConfig.systems.RegistrationSystem.systemId,\n      callData: encodeFunctionData({\n        abi: IBaseWorldAbi,\n        functionName: \"registerDelegation\",\n        args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n      })\n    })\n    txs.push(tx)\n  }\n\n  if (!txs.length) {\n    // No delegation to register, just deploy session account\n    await deploySessionAccount(sessionClient, onStatus)\n    onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n    return\n  }\n\n  onStatus?.({ type: \"registering_delegation\", message: \"Setting up session...\" })\n\n  for (const hash of txs) {\n    const receipt = await getAction(\n      client,\n      waitForTransactionReceipt,\n      \"waitForTransactionReceipt\"\n    )({ hash })\n\n    if (receipt.status === \"reverted\") {\n      throw new Error(\"Delegation registration transaction reverted\")\n    }\n  }\n\n  // Deploy session account if needed\n  await deploySessionAccount(sessionClient, onStatus)\n\n  console.log(\"[drawbridge] EOA setup complete\")\n  onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n}\n","import { Hex, Client } from \"viem\"\nimport { SessionClient, ConnectedClient } from \"../../types\"\nimport { SetupSessionStatus } from \"./shared\"\nimport { setupSessionSmartAccount } from \"./smart-account\"\nimport { setupSessionEOA } from \"./eoa\"\n\n/**\n * Complete setup session parameters (supports both EOA and Smart Account)\n */\nexport type SetupSessionParams = {\n  /** Public client for reading blockchain state */\n  client: Client\n  /** User's connected wallet client (EOA or Smart Account) */\n  userClient: ConnectedClient\n  /** Session smart account client with MUD extensions */\n  sessionClient: SessionClient\n  /** MUD World contract address */\n  worldAddress: Hex\n  /** Whether to register delegation (default: true) */\n  registerDelegation?: boolean\n  /** Progress callback for status updates */\n  onStatus?: (status: SetupSessionStatus) => void\n}\n\n// Re-export SetupSessionStatus for convenience\nexport type { SetupSessionStatus }\n\n/**\n * Setup session by registering delegation and deploying session account\n *\n * This is the main entry point that automatically routes to the correct implementation\n * based on the user's wallet type.\n *\n * Flow differs based on wallet type:\n *\n * **Smart Account Wallet:**\n * - Checks and deploys user's wallet if needed\n * - Sends user operation to register delegation\n * - User's smart account submits the operation\n * - Uses bundler + paymaster infrastructure\n *\n * **EOA (Externally Owned Account):**\n * - Uses CallWithSignature pattern (gasless for user)\n * - User signs a message (EIP-712)\n * - Session account submits the signature + call\n * - World validates signature and executes as user\n *\n * **Finally:**\n * - Deploys session account if not yet deployed (via empty user operation)\n *\n * @param params Setup parameters\n */\nexport async function setupSession({\n  client,\n  userClient,\n  sessionClient,\n  worldAddress,\n  registerDelegation = true,\n  onStatus\n}: SetupSessionParams): Promise<void> {\n  console.log(\"[drawbridge] Setup session:\", {\n    userAddress: userClient.account.address,\n    accountType: userClient.account.type\n  })\n\n  // Route to appropriate implementation based on wallet type\n  if (userClient.account.type === \"smart\") {\n    return setupSessionSmartAccount({\n      userClient,\n      sessionClient,\n      worldAddress,\n      registerDelegation,\n      onStatus\n    })\n  } else {\n    return setupSessionEOA({\n      client,\n      userClient,\n      sessionClient,\n      worldAddress,\n      registerDelegation,\n      onStatus\n    })\n  }\n}\n","import { Chain, Transport } from \"viem\"\nimport { createConfig, createStorage, type Config, type CreateConnectorFn } from \"@wagmi/core\"\n\n/**\n * Configuration parameters for creating wagmi config\n */\nexport type WalletConfigParams = {\n  /** Supported chains */\n  chains: readonly [Chain, ...Chain[]]\n  /** Transport configuration per chain */\n  transports: Record<number, Transport>\n  /** Wallet connectors (injected, walletConnect, etc.) */\n  connectors: CreateConnectorFn[]\n  /** Optional polling interval in milliseconds */\n  pollingInterval?: number\n}\n\n/**\n * Create wagmi configuration for wallet connection\n *\n * Configures wagmi with:\n * - Chains and transports for RPC communication\n * - Wallet connectors (MetaMask, WalletConnect, Coinbase, etc.)\n * - localStorage persistence for connection state\n * - Optional polling interval for state updates\n *\n * @param params Configuration parameters\n * @returns Wagmi Config instance\n */\nexport function createWalletConfig({\n  chains,\n  transports,\n  connectors,\n  pollingInterval\n}: WalletConfigParams): Config {\n  return createConfig({\n    chains,\n    transports,\n    connectors,\n    pollingInterval,\n    storage: createStorage({\n      storage: typeof window !== \"undefined\" ? window.localStorage : undefined\n    })\n  })\n}\n","import { watchAccount, type Config } from \"@wagmi/core\"\nimport type { GetAccountReturnType } from \"@wagmi/core\"\n\n/**\n * Account change handler callback\n *\n * Called whenever the connected wallet account changes (connect, disconnect, switch).\n */\nexport type AccountChangeHandler = (account: GetAccountReturnType) => void | Promise<void>\n\n/**\n * Cleanup function returned by setupAccountWatcher\n *\n * Call this to stop watching for account changes.\n */\nexport type UnwatchAccount = () => void\n\n/**\n * Setup wagmi account watcher\n *\n * Watches for wallet connection state changes and calls the provided handler.\n *\n * Changes detected:\n * - Wallet connected\n * - Wallet disconnected\n * - Account switched\n * - Chain switched\n *\n * @param wagmiConfig Wagmi configuration instance\n * @param onChange Handler called on account changes\n * @returns Cleanup function to stop watching\n *\n * @example\n * ```typescript\n * const unwatch = setupAccountWatcher(wagmiConfig, async (account) => {\n *   if (account.isConnected) {\n *     console.log(\"Connected:\", account.address)\n *     await handleConnection(account)\n *   } else {\n *     console.log(\"Disconnected\")\n *     await handleDisconnection()\n *   }\n * })\n *\n * // Later, stop watching\n * unwatch()\n * ```\n */\nexport function setupAccountWatcher(\n  wagmiConfig: Config,\n  onChange: AccountChangeHandler\n): UnwatchAccount {\n  return watchAccount(wagmiConfig, {\n    onChange: account => {\n      console.log(\"[wallet] Account change:\", {\n        isConnected: account.isConnected,\n        address: account.address\n      })\n\n      // Call handler (may be async)\n      const result = onChange(account)\n      if (result instanceof Promise) {\n        result.catch(err => {\n          console.error(\"[wallet] Account change handler failed:\", err)\n        })\n      }\n    }\n  })\n}\n","import { Address } from \"viem\"\nimport { reconnect, connect, disconnect, getConnectors, getAccount, type Config } from \"@wagmi/core\"\n\n/**\n * Result of reconnection attempt\n */\nexport type ReconnectResult = {\n  /** Whether reconnection was successful */\n  reconnected: boolean\n  /** Connected account address if reconnected */\n  address?: Address\n}\n\n/**\n * Attempt to reconnect to previously connected wallet\n *\n * Checks localStorage for previous connection state and attempts to restore it.\n * This should be called during initialization.\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Reconnection result\n *\n * @example\n * ```typescript\n * const result = await attemptReconnect(wagmiConfig)\n * if (result.reconnected) {\n *   console.log(\"Reconnected to:\", result.address)\n *   // Handle reconnected state\n * } else {\n *   console.log(\"No previous connection\")\n *   // Start in disconnected state\n * }\n * ```\n */\nexport async function attemptReconnect(wagmiConfig: Config): Promise<ReconnectResult> {\n  try {\n    await reconnect(wagmiConfig)\n\n    const account = getAccount(wagmiConfig)\n    if (account.isConnected && account.address) {\n      console.log(\"[wallet] Reconnection successful:\", account.address)\n      return {\n        reconnected: true,\n        address: account.address\n      }\n    }\n\n    console.log(\"[wallet] Reconnected but no account\")\n    return { reconnected: false }\n  } catch (err) {\n    console.log(\"[wallet] No previous connection to restore\")\n    return { reconnected: false }\n  }\n}\n\n/**\n * Connect to a wallet by connector ID\n *\n * @param wagmiConfig Wagmi configuration instance\n * @param connectorId Connector ID to connect to\n * @param chainId Optional chain ID to connect on\n * @throws If connector not found or connection fails\n *\n * @example\n * ```typescript\n * try {\n *   await connectWallet(wagmiConfig, \"injected\", 8453)\n *   console.log(\"Connected successfully\")\n * } catch (err) {\n *   if (err.name === \"ConnectorAlreadyConnectedError\") {\n *     console.log(\"Already connected\")\n *   } else {\n *     console.error(\"Connection failed:\", err)\n *   }\n * }\n * ```\n */\nexport async function connectWallet(\n  wagmiConfig: Config,\n  connectorId: string,\n  chainId?: number\n): Promise<void> {\n  const connectors = getConnectors(wagmiConfig)\n  const connector = connectors.find(c => c.id === connectorId)\n\n  if (!connector) {\n    throw new Error(`Connector not found: ${connectorId}`)\n  }\n\n  console.log(\"[wallet] Connecting to wallet:\", connectorId)\n\n  await connect(wagmiConfig, {\n    connector,\n    chainId\n  })\n\n  console.log(\"[wallet] Connection initiated\")\n}\n\n/**\n * Disconnect the currently connected wallet\n *\n * Clears wagmi connection state and localStorage.\n *\n * @param wagmiConfig Wagmi configuration instance\n *\n * @example\n * ```typescript\n * await disconnectWallet(wagmiConfig)\n * console.log(\"Disconnected\")\n * ```\n */\nexport async function disconnectWallet(wagmiConfig: Config): Promise<void> {\n  console.log(\"[wallet] Disconnecting...\")\n\n  try {\n    await disconnect(wagmiConfig)\n    console.log(\"[wallet] Disconnected successfully\")\n  } catch (err) {\n    console.error(\"[wallet] Disconnect error:\", err)\n    throw err\n  }\n}\n\n/**\n * Get current account information\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Current account state\n *\n * @example\n * ```typescript\n * const account = getCurrentAccount(wagmiConfig)\n * if (account.isConnected) {\n *   console.log(\"Connected:\", account.address)\n * }\n * ```\n */\nexport function getCurrentAccount(wagmiConfig: Config) {\n  return getAccount(wagmiConfig)\n}\n\n/**\n * Get list of available wallet connectors\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Array of available connectors\n *\n * @example\n * ```typescript\n * const connectors = getAvailableConnectors(wagmiConfig)\n * console.log(\"Available wallets:\", connectors.map(c => c.name))\n * ```\n */\nexport function getAvailableConnectors(wagmiConfig: Config) {\n  return getConnectors(wagmiConfig)\n}\n","import { Address, Chain, Client, Transport, Account } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { SessionClient, DrawbridgeStatus } from \"./types\"\nimport { getSessionSigner } from \"./session/core/signer\"\nimport { getSessionAccount } from \"./session/core/account\"\nimport { getSessionClient } from \"./session/core/client\"\nimport { checkDelegation } from \"./session/delegation/check\"\nimport { setupSession, type SetupSessionStatus } from \"./session/delegation/setup\"\nimport { sessionStorage } from \"./session/core/storage\"\nimport { getConnectorClient, type Config, type CreateConnectorFn } from \"@wagmi/core\"\nimport {\n  createWalletConfig,\n  setupAccountWatcher,\n  attemptReconnect,\n  connectWallet as walletConnect,\n  disconnectWallet as walletDisconnect,\n  getAvailableConnectors as walletGetAvailableConnectors\n} from \"./wallet\"\n\n/**\n * Configuration for Drawbridge instance\n */\nexport type DrawbridgeConfig = {\n  /** Chain ID to operate on */\n  chainId: number\n  /** Supported chains */\n  chains: readonly [Chain, ...Chain[]]\n  /** Transport configuration per chain */\n  transports: Record<number, Transport>\n  /** Wallet connectors (injected, walletConnect, etc.) */\n  connectors: CreateConnectorFn[]\n  /** MUD World contract address (optional if skipSessionSetup is true) */\n  worldAddress?: Address\n  /** Optional paymaster client for sponsored transactions */\n  paymasterClient?: PaymasterClient\n  /** Optional polling interval for wagmi (in ms) */\n  pollingInterval?: number\n  /** Optional app name for wallet connectors */\n  appName?: string\n  /**\n   * Skip session setup entirely - wallet connection only mode\n   * Use this for apps that don't need MUD delegation/session accounts.\n   * When true:\n   * - No session account created\n   * - No delegation registration\n   * - Only provides connected wallet client via wagmi\n   * - worldAddress is optional\n   * @default false\n   */\n  skipSessionSetup?: boolean\n}\n\n/**\n * Current state of the Drawbridge instance\n * Updated reactively and broadcast to subscribers\n */\nexport type DrawbridgeState = {\n  /** Current status of Drawbridge - single source of truth */\n  status: DrawbridgeStatus\n  /** Session client with MUD World extensions, null if not connected */\n  sessionClient: SessionClient | null\n  /** Original user's wallet address, null if not connected */\n  userAddress: Address | null\n  /** Session smart account address, null if not connected */\n  sessionAddress: Address | null\n  /** Whether session has delegation registered and is ready to use */\n  isReady: boolean\n}\n\n/**\n * Result of checking session prerequisites\n */\nexport type PrerequisiteStatus = {\n  /** Whether delegation is registered in World contract */\n  hasDelegation: boolean\n  /** Whether session is fully ready (same as hasDelegation) */\n  isReady: boolean\n}\n\ntype StateListener = (state: DrawbridgeState) => void\ntype Unsubscribe = () => void\n\n/**\n * Connector info for UI display\n */\nexport type ConnectorInfo = {\n  id: string\n  name: string\n  type: string\n}\n\n/**\n * Drawbridge - Headless wallet connection and session management\n *\n * Based on @latticexyz/entrykit - a stripped down, headless version.\n *\n * Provides complete wallet connection and session management:\n * - Wagmi integration (connectors, account watching, reconnection)\n * - ERC-4337 session account creation\n * - MUD World delegation registration\n * - Reactive state management (framework-agnostic)\n * - Gasless transaction support via paymaster\n *\n * Usage:\n * ```typescript\n * const drawbridge = new Drawbridge({\n *   chainId: 8453,\n *   chains: [baseChain],\n *   transports: { 8453: http() },\n *   connectors: [injected()],\n *   worldAddress: \"0x...\"\n * });\n *\n * // Initialize (await reconnection, setup watchers)\n * await entrykit.initialize();\n *\n * // Get available wallets\n * const wallets = entrykit.getAvailableConnectors();\n *\n * // Connect to wallet\n * await entrykit.connectWallet(wallets[0].id);\n *\n * // Setup delegation if needed\n * if (!entrykit.isReady) {\n *   await entrykit.setupSession();\n * }\n *\n * // Disconnect\n * await entrykit.disconnectWallet();\n * ```\n */\nexport class Drawbridge {\n  private config: DrawbridgeConfig\n  private state: DrawbridgeState\n  private listeners = new Set<StateListener>()\n  private wagmiConfig: Config\n  private accountWatcherCleanup: (() => void) | null = null\n  private isConnecting = false\n  private isDisconnecting = false\n\n  constructor(config: DrawbridgeConfig) {\n    this.config = config\n    this.state = {\n      status: DrawbridgeStatus.UNINITIALIZED,\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false\n    }\n\n    // Create wagmi config\n    this.wagmiConfig = createWalletConfig({\n      chains: config.chains,\n      transports: config.transports,\n      connectors: config.connectors,\n      pollingInterval: config.pollingInterval\n    })\n  }\n\n  /**\n   * Initialize Drawbridge (await reconnection and setup account watcher)\n   *\n   * This should be called once after construction and awaited.\n   * It will attempt to reconnect to a previously connected wallet.\n   */\n  async initialize(): Promise<void> {\n    console.log(\"[drawbridge] Initializing...\")\n\n    // Attempt to reconnect to previously connected wallet\n    const result = await attemptReconnect(this.wagmiConfig)\n\n    if (!result.reconnected) {\n      // No reconnection - set status to DISCONNECTED\n      this.updateState({ status: DrawbridgeStatus.DISCONNECTED })\n    }\n\n    // Setup account watcher for future changes\n    this.setupAccountWatcher()\n\n    // If reconnection succeeded, manually handle the initial connection\n    // (the watcher won't fire for connections that happened before it was set up)\n    if (result.reconnected && result.address) {\n      console.log(\"[drawbridge] Processing reconnected wallet:\", result.address)\n      await this.handleWalletConnection()\n    }\n\n    console.log(\"[drawbridge] Initialization complete\")\n  }\n\n  // ===== Reactive State Management =====\n\n  /**\n   * Subscribe to state changes\n   *\n   * The listener will be called immediately with the current state,\n   * and again whenever the state changes.\n   *\n   * @param listener Function to call on state changes\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = entrykit.subscribe((state) => {\n   *   if (state.sessionClient) {\n   *     console.log(\"Session ready:\", state.sessionClient.account.address);\n   *   }\n   * });\n   *\n   * // Later, stop listening\n   * unsubscribe();\n   * ```\n   */\n  subscribe(listener: StateListener): Unsubscribe {\n    this.listeners.add(listener)\n    listener(this.state) // Immediate callback with current state\n    return () => this.listeners.delete(listener)\n  }\n\n  /**\n   * Get current state (non-reactive snapshot)\n   *\n   * For reactive updates, use subscribe() instead.\n   */\n  getState(): DrawbridgeState {\n    return { ...this.state }\n  }\n\n  private updateState(updates: Partial<DrawbridgeState>): void {\n    this.state = { ...this.state, ...updates }\n    this.notify()\n  }\n\n  private notify(): void {\n    this.listeners.forEach(listener => listener(this.state))\n  }\n\n  /**\n   * Setup wagmi account watcher to handle connection/disconnection\n   * Called automatically by initialize()\n   */\n  private setupAccountWatcher(): void {\n    const unwatch = setupAccountWatcher(this.wagmiConfig, async account => {\n      // Handle disconnection\n      if (!account.isConnected) {\n        console.log(\"[drawbridge] Wallet disconnected\")\n        this.updateState({\n          status: DrawbridgeStatus.DISCONNECTED,\n          sessionClient: null,\n          userAddress: null,\n          sessionAddress: null,\n          isReady: false\n        })\n        this.isConnecting = false\n        return\n      }\n\n      // Ignore connection attempts while disconnecting to prevent deadlock\n      if (this.isDisconnecting) {\n        console.log(\"[drawbridge] Ignoring connection attempt during disconnect\")\n        return\n      }\n\n      // Handle connection\n      if (this.isConnecting) {\n        console.log(\"[drawbridge] Already processing connection\")\n        return\n      }\n\n      if (!account.connector || !account.address) {\n        return\n      }\n\n      try {\n        this.isConnecting = true\n        await this.handleWalletConnection()\n      } catch (err) {\n        console.error(\"[drawbridge] Connection handler failed:\", err)\n      } finally {\n        this.isConnecting = false\n      }\n    })\n\n    this.accountWatcherCleanup = unwatch\n  }\n\n  /**\n   * Internal handler for wallet connection\n   * Called when wagmi detects a connected account\n   */\n  private async handleWalletConnection(): Promise<void> {\n    // Get wallet client from wagmi\n    let userClient: Client\n    try {\n      userClient = await getConnectorClient(this.wagmiConfig)\n    } catch (err) {\n      console.log(\"[drawbridge] Could not get connector client\")\n      return\n    }\n\n    if (!userClient.account || !userClient.chain) {\n      console.log(\"[drawbridge] Wallet client missing account or chain\")\n      return\n    }\n\n    const userAddress = userClient.account.address\n    console.log(\"[drawbridge] Wallet connected:\", userAddress)\n\n    // If skipSessionSetup is true, just store the user address and mark as READY\n    // No session account, no delegation - just wallet connection\n    if (this.config.skipSessionSetup) {\n      console.log(\"[drawbridge] Skipping session setup (wallet-only mode)\")\n      this.updateState({\n        status: DrawbridgeStatus.READY,\n        sessionClient: null,\n        userAddress,\n        sessionAddress: null,\n        isReady: true\n      })\n      return\n    }\n\n    // Full session setup flow (MUD delegation)\n    console.log(\"[drawbridge] Setting up session for address:\", userAddress)\n\n    // Get or create persistent session signer from localStorage\n    const signer = getSessionSigner(userAddress)\n\n    // Create ERC-4337 SimpleAccount smart wallet\n    // TypeScript: We've already checked chain exists on line 298, so cast is safe\n    const { account } = await getSessionAccount({\n      client: userClient as Client<Transport, Chain, Account>,\n      userAddress\n    })\n\n    // Create session client with MUD World callFrom/sendUserOperationFrom extensions\n    const sessionClient = await getSessionClient({\n      userAddress,\n      sessionAccount: account,\n      sessionSigner: signer,\n      worldAddress: this.config.worldAddress!,\n      paymasterOverride: this.config.paymasterClient\n    })\n\n    // Check if delegation already exists BEFORE notifying listeners\n    // This prevents UI flash where sessionClient exists but isReady is unknown\n    const hasDelegation = await checkDelegation({\n      client: sessionClient,\n      worldAddress: this.config.worldAddress!,\n      userAddress,\n      sessionAddress: account.address\n    })\n\n    // Update state once with complete information\n    // Set status to READY if delegation exists, CONNECTED if not\n    this.updateState({\n      status: hasDelegation ? DrawbridgeStatus.READY : DrawbridgeStatus.CONNECTED,\n      sessionClient,\n      userAddress,\n      sessionAddress: account.address,\n      isReady: hasDelegation\n    })\n\n    console.log(\"[drawbridge] Session connection complete, isReady:\", hasDelegation)\n  }\n\n  // ===== Public API =====\n\n  /**\n   * Get available wallet connectors for UI display\n   *\n   * @returns Array of connector info (id, name, type)\n   */\n  getAvailableConnectors(): ConnectorInfo[] {\n    const connectors = walletGetAvailableConnectors(this.wagmiConfig)\n    return connectors.map(c => ({\n      id: c.id,\n      name: c.name,\n      type: c.type\n    }))\n  }\n\n  /**\n   * Connect to a wallet by connector ID\n   *\n   * This will:\n   * 1. Connect via wagmi\n   * 2. Account watcher will automatically handle EntryKit session creation\n   *\n   * @param connectorId Connector ID (from getAvailableConnectors())\n   * @throws If connector not found or connection fails\n   */\n  async connectWallet(connectorId: string): Promise<void> {\n    console.log(\"[drawbridge] Connecting to wallet:\", connectorId)\n\n    // Set status to CONNECTING\n    this.updateState({ status: DrawbridgeStatus.CONNECTING })\n\n    try {\n      await walletConnect(this.wagmiConfig, connectorId, this.config.chainId)\n    } catch (err) {\n      // If already connected, that's fine\n      if (err instanceof Error && err.name === \"ConnectorAlreadyConnectedError\") {\n        console.log(\"[drawbridge] Already connected\")\n        return\n      }\n      // Reset to DISCONNECTED on error\n      this.updateState({ status: DrawbridgeStatus.DISCONNECTED })\n      throw err\n    }\n\n    // Account watcher will handle the rest and set appropriate status\n  }\n\n  /**\n   * Disconnect wallet and clear session\n   *\n   * This will:\n   * 1. Disconnect via wagmi\n   * 2. Account watcher will automatically clear EntryKit state\n   */\n  async disconnectWallet(): Promise<void> {\n    console.log(\"[drawbridge] disconnectWallet() called\")\n    console.log(\"[drawbridge] Current state:\", this.state)\n    console.log(\"[drawbridge] Calling wagmi disconnect()...\")\n\n    try {\n      this.isDisconnecting = true\n      await walletDisconnect(this.wagmiConfig)\n      console.log(\"[drawbridge] Wallet disconnected\")\n    } catch (err) {\n      console.error(\"[drawbridge] Disconnect error:\", err)\n      throw err\n    } finally {\n      this.isDisconnecting = false\n    }\n\n    console.log(\"[drawbridge] Disconnect complete\")\n  }\n\n  /**\n   * Check if session is ready to use\n   *\n   * Queries the MUD World contract to check if delegation is registered\n   * between the user's account and the session account.\n   *\n   * @returns Delegation status\n   */\n  async checkPrerequisites(): Promise<PrerequisiteStatus> {\n    if (!this.state.sessionClient) {\n      return { hasDelegation: false, isReady: false }\n    }\n\n    const hasDelegation = await checkDelegation({\n      client: this.state.sessionClient,\n      worldAddress: this.config.worldAddress!,\n      userAddress: this.state.userAddress!,\n      sessionAddress: this.state.sessionAddress!\n    })\n\n    this.updateState({ isReady: hasDelegation })\n\n    return { hasDelegation, isReady: hasDelegation }\n  }\n\n  /**\n   * Setup session by registering delegation and deploying account\n   *\n   * This will:\n   * 1. Get current wallet client from wagmi\n   * 2. Register delegation in MUD World contract (user delegates to session)\n   * 3. Deploy session smart account if not already deployed\n   *\n   * User will need to sign a transaction (EOA) or user operation (smart account).\n   *\n   * @throws If not connected (call connectWallet() first)\n   */\n  async setupSession(onStatus?: (status: SetupSessionStatus) => void): Promise<void> {\n    if (this.config.skipSessionSetup) {\n      throw new Error(\n        \"Cannot setup session when skipSessionSetup is true. This EntryKit instance is in wallet-only mode.\"\n      )\n    }\n\n    if (!this.state.sessionClient) {\n      throw new Error(\"Not connected. Call connectWallet() first.\")\n    }\n\n    console.log(\"[drawbridge] Setting up session (registering delegation)...\")\n\n    // Set status to SETTING_UP_SESSION\n    this.updateState({ status: DrawbridgeStatus.SETTING_UP_SESSION })\n\n    // Get current wallet client from wagmi\n    const userClient = await getConnectorClient(this.wagmiConfig)\n\n    try {\n      await setupSession({\n        client: userClient,\n        userClient,\n        sessionClient: this.state.sessionClient,\n        worldAddress: this.config.worldAddress!,\n        onStatus\n      })\n\n      // Session setup complete - set status to READY\n      this.updateState({ status: DrawbridgeStatus.READY, isReady: true })\n\n      console.log(\"[drawbridge] Session setup complete\")\n    } catch (err) {\n      // Reset to CONNECTED on error\n      this.updateState({ status: DrawbridgeStatus.CONNECTED })\n      throw err\n    }\n  }\n\n  /**\n   * Cleanup and destroy EntryKit instance\n   *\n   * This will:\n   * 1. Unwatch account changes\n   * 2. Clear session state (but NOT localStorage keys)\n   *\n   * Call this when unmounting your app.\n   */\n  destroy(): void {\n    console.log(\"[drawbridge] Destroying instance\")\n\n    // Cleanup account watcher\n    if (this.accountWatcherCleanup) {\n      this.accountWatcherCleanup()\n      this.accountWatcherCleanup = null\n    }\n\n    // Clear state\n    this.updateState({\n      status: DrawbridgeStatus.DISCONNECTED,\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false\n    })\n  }\n\n  /**\n   * Clear stored session keys from localStorage\n   *\n   * This permanently removes the session private key for the current user.\n   * Next time connect() is called, a new session account will be created.\n   */\n  clearStorage(): void {\n    if (this.state.userAddress) {\n      sessionStorage.removeSigner(this.state.userAddress)\n    }\n  }\n\n  // ===== Convenience Getters =====\n\n  /** Get current session client (null if not connected) */\n  get sessionClient(): SessionClient | null {\n    return this.state.sessionClient\n  }\n\n  /** Get current user address (null if not connected) */\n  get userAddress(): Address | null {\n    return this.state.userAddress\n  }\n\n  /** Get current session account address (null if not connected) */\n  get sessionAddress(): Address | null {\n    return this.state.sessionAddress\n  }\n\n  /** Check if session is ready (has delegation) */\n  get isReady(): boolean {\n    return this.state.isReady\n  }\n\n  /** Get wagmi config (for advanced use cases like transactions) */\n  getWagmiConfig(): Config {\n    return this.wagmiConfig\n  }\n}\n"]}