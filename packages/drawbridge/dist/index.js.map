{"version":3,"sources":["../src/types/state.ts","../src/types/mud.ts","../src/types/config.ts","../src/session/core/storage.ts","../src/session/core/signer.ts","../src/session/core/account.ts","../src/bundler/paymaster.ts","../src/bundler/tempDebugLogging.ts","../src/bundler/client.ts","../src/bundler/gasEstimator.ts","../src/bundler/transport.ts","../src/session/core/client.ts","../src/session/delegation/check.ts","../src/session/patterns/wallet-deployment.ts","../src/session/delegation/shared.ts","../src/session/delegation/smart-account.ts","../src/session/patterns/eip712-signing.ts","../src/session/patterns/call-with-signature.ts","../src/session/delegation/eoa.ts","../src/session/delegation/setup.ts","../src/wallet/config.ts","../src/wallet/watcher.ts","../src/wallet/connection.ts","../src/Drawbridge.ts"],"names":["DrawbridgeStatus","viem_createBundlerClient","formatGwei","getAction","sendUserOperation","waitForUserOperationReceipt","getRecord","viem_writeContract","worldSystemsConfig","waitForTransactionReceipt"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Drawbridge connection and setup status\n *\n * Provides a single source of truth for the current state of Drawbridge.\n * Transitions follow this flow:\n *\n * UNINITIALIZED → initialize() → DISCONNECTED\n *                                      ↓\n *                      connectWallet() ↓\n *                                      ↓\n *                                 CONNECTED\n *                                      ↓\n *                      setupSession()  ↓\n *                                      ↓\n *                             SETTING_UP_SESSION\n *                                      ↓\n *                                   READY\n *\n * Note: READY state can be reached directly from DISCONNECTED if reconnection succeeds.\n */\nexport enum DrawbridgeStatus {\n  /** Drawbridge not yet initialized - call initialize() */\n  UNINITIALIZED = \"uninitialized\",\n\n  /** Drawbridge initialized but no wallet connected */\n  DISCONNECTED = \"disconnected\",\n\n  /** Wallet connection in progress */\n  CONNECTING = \"connecting\",\n\n  /** Wallet connected, but session setup needed (delegation not registered) */\n  CONNECTED = \"connected\",\n\n  /** Session setup in progress (registering delegation) */\n  SETTING_UP_SESSION = \"setting_up_session\",\n\n  /** Fully ready - session client available and delegation registered */\n  READY = \"ready\",\n\n  /** An error occurred */\n  ERROR = \"error\"\n}\n","import { resourceToHex } from \"@latticexyz/common\"\nimport { parseAbi, ClientConfig } from \"viem\"\nimport worldConfig from \"@latticexyz/world/mud.config\"\n\n/**\n * Default viem client configuration\n * Polling interval for watching blockchain state and user operation receipts\n *\n * Note: This affects how often we poll for user operation receipts after sending.\n * Lower = faster confirmation detection but more RPC calls\n * Higher = slower confirmation detection but fewer RPC calls (better for rate limits)\n */\nexport const defaultClientConfig = {\n  pollingInterval: 2000 // Changed from 250ms to 2000ms to reduce rate limiting\n} as const satisfies Pick<ClientConfig, \"pollingInterval\">\n\n/**\n * MUD delegation control ID for \"unlimited\" delegation\n *\n * This is a resource ID that identifies the unlimited delegation control system.\n * When a user delegates to a session account with this ID, the session account\n * can call any system in the World on behalf of the user.\n *\n * Format: system resource with namespace=\"\" and name=\"unlimited\"\n */\nexport const unlimitedDelegationControlId = resourceToHex({\n  type: \"system\",\n  namespace: \"\",\n  name: \"unlimited\"\n})\n\n/**\n * MUD World table definitions from world config\n * Used to query World state (e.g., UserDelegationControl table)\n */\nexport const worldTables = worldConfig.namespaces.world.tables\n\n/**\n * Minimal World ABI for delegation registration\n * Full ABI is large, we only need this one function\n */\nexport const worldAbi = parseAbi([\n  \"function registerDelegation(address delegatee, bytes32 delegationControlId, bytes initCallData)\"\n])\n","/**\n * Deployment timeout and delay constants\n *\n * These values control timing for wallet and session deployment operations.\n * Adjust based on chain speed and network conditions.\n */\nexport const DEPLOYMENT_TIMEOUTS = {\n  /**\n   * Timeout for session account deployment (milliseconds)\n   *\n   * After this time, we give up waiting for the session account to deploy.\n   * Default: 30 seconds\n   *\n   * Increase for slower chains or congested networks.\n   */\n  SESSION_DEPLOYMENT: 30_000,\n\n  /**\n   * Delay after wallet deployment to allow bundler state synchronization (milliseconds)\n   *\n   * After deploying a counterfactual wallet, bundlers cache the account state\n   * and need time to refresh their internal state before accepting operations.\n   *\n   * Default: 2 seconds\n   *\n   * This prevents \"AA10\" errors on the next user operation.\n   * See: https://github.com/eth-infinitism/account-abstraction/discussions\n   */\n  BUNDLER_STATE_SYNC: 2_000\n} as const\n","import { Address, Hex } from \"viem\"\n\ntype SessionStore = {\n  signers: Record<string, string> // lowercase address → private key\n}\n\n/**\n * Session key storage using localStorage\n *\n * Manages persistent session private keys for each user address.\n * Keys are stored in localStorage and survive page refreshes.\n *\n * Storage format: { signers: { \"0xabc...\": \"0x123...\" } }\n * Storage key: \"drawbridge:session-signers\"\n *\n * Migration: Automatically migrates from legacy \"entrykit:session-signers\" key\n * to maintain backwards compatibility.\n */\nexport class SessionStorage {\n  private cache: SessionStore\n  private readonly STORAGE_KEY = \"drawbridge:session-signers\"\n  private readonly LEGACY_STORAGE_KEY = \"entrykit:session-signers\"\n\n  constructor() {\n    this.cache = this.load()\n  }\n\n  /**\n   * Load session store from localStorage\n   *\n   * Attempts to load from new key first, then falls back to legacy key\n   * for backwards compatibility with existing installations.\n   */\n  private load(): SessionStore {\n    if (typeof localStorage === \"undefined\") {\n      return { signers: {} }\n    }\n\n    // Try new key first\n    let stored = localStorage.getItem(this.STORAGE_KEY)\n\n    // Fall back to legacy key for existing users\n    if (!stored) {\n      stored = localStorage.getItem(this.LEGACY_STORAGE_KEY)\n      if (stored) {\n        console.log(\"[drawbridge] Migrating session storage from legacy key\")\n      }\n    }\n\n    if (!stored) {\n      return { signers: {} }\n    }\n\n    try {\n      const parsed = JSON.parse(stored)\n\n      // Validate structure\n      if (!parsed.signers || typeof parsed.signers !== \"object\") {\n        console.warn(\"[drawbridge] Session storage corrupted - invalid structure, resetting\")\n        return { signers: {} }\n      }\n\n      return parsed\n    } catch (err) {\n      console.error(\n        \"[drawbridge] Failed to parse session storage:\",\n        err instanceof Error ? err.message : String(err)\n      )\n      console.warn(\"[drawbridge] Session storage will be reset\")\n      return { signers: {} }\n    }\n  }\n\n  /**\n   * Save session store to localStorage\n   *\n   * Saves to new key and removes legacy key to complete migration.\n   */\n  private save(): void {\n    if (typeof localStorage === \"undefined\") return\n\n    // Save to new key\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.cache))\n\n    // Remove legacy key if it exists (cleanup after migration)\n    if (localStorage.getItem(this.LEGACY_STORAGE_KEY)) {\n      localStorage.removeItem(this.LEGACY_STORAGE_KEY)\n      console.log(\"[drawbridge] Removed legacy storage key after migration\")\n    }\n  }\n\n  /**\n   * Get session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @returns Private key if exists, undefined otherwise\n   */\n  getSigner(address: Address): Hex | undefined {\n    const key = address.toLowerCase()\n    return this.cache.signers[key] as Hex | undefined\n  }\n\n  /**\n   * Store session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @param privateKey Session private key to store\n   */\n  setSigner(address: Address, privateKey: Hex): void {\n    const key = address.toLowerCase()\n    this.cache.signers[key] = privateKey\n    this.save()\n  }\n\n  /**\n   * Remove session signer for a user address\n   *\n   * @param address User's wallet address\n   */\n  removeSigner(address: Address): void {\n    const key = address.toLowerCase()\n    delete this.cache.signers[key]\n    this.save()\n  }\n\n  /**\n   * Clear all session signers\n   */\n  clear(): void {\n    this.cache = { signers: {} }\n    this.save()\n  }\n}\n\n/**\n * Singleton session storage instance\n */\nexport const sessionStorage = new SessionStorage()\n","import { Address, Hex, isHex } from \"viem\"\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\"\nimport { sessionStorage } from \"./storage\"\n\n/**\n * Get or create session signer for a user address\n *\n * Session signers are persistent private keys stored in localStorage.\n * They're used as the owner of the session smart account.\n *\n * If no signer exists for this user:\n * - Attempts to migrate from old MUD AccountKit storage format\n * - Otherwise generates a fresh random private key\n * - Stores the key for future use\n *\n * @param userAddress User's wallet address\n * @returns LocalAccount (viem account from private key)\n */\nexport function getSessionSigner(userAddress: Address) {\n  let privateKey = sessionStorage.getSigner(userAddress)\n\n  if (!privateKey) {\n    // Attempt to migrate from legacy MUD AccountKit storage format\n    // This allows existing users to keep their session accounts\n    const deprecatedKey =\n      typeof localStorage !== \"undefined\"\n        ? localStorage\n            .getItem(`mud:appSigner:privateKey:${userAddress.toLowerCase()}`)\n            ?.replace(/^\"(.*)\"$/, \"$1\") // Remove JSON quotes if present\n        : null\n\n    // Use migrated key if valid, otherwise generate new random key\n    privateKey = (isHex(deprecatedKey) ? deprecatedKey : generatePrivateKey()) as Hex\n    sessionStorage.setSigner(userAddress, privateKey)\n  }\n\n  return privateKeyToAccount(privateKey)\n}\n","import { Address, Chain, Client, LocalAccount, Transport } from \"viem\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { toSimpleSmartAccount } from \"permissionless/accounts\"\nimport { getSessionSigner } from \"./signer\"\n\nexport type GetSessionAccountReturnType = {\n  readonly account: SmartAccount\n  readonly signer: LocalAccount\n}\n\nexport async function getSessionAccount<chain extends Chain>({\n  client,\n  userAddress\n}: {\n  client: Client<Transport, chain>\n  userAddress: Address\n}): Promise<GetSessionAccountReturnType> {\n  const signer = getSessionSigner(userAddress)\n  const account = await toSimpleSmartAccount({ client, owner: signer })\n  return { account, signer }\n}\n","import { Chain, Hex } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\n\n/**\n * Paymaster configuration\n *\n * Paymasters sponsor gas for user operations (ERC-4337).\n * Two types supported:\n *\n * - **simple**: Basic paymaster with just an address\n *   Returns paymaster address with empty data\n *\n * - **custom**: Advanced paymaster with client\n *   Uses provided PaymasterClient for dynamic sponsorship logic\n *   (e.g., Coinbase Paymaster, Pimlico, etc.)\n */\nexport type Paymaster =\n  | {\n      readonly type: \"simple\"\n      readonly address: Hex\n    }\n  | {\n      readonly type: \"custom\"\n      readonly address?: Hex\n      readonly paymasterClient: PaymasterClient\n    }\n\n/**\n * Get paymaster configuration for a chain\n *\n * Priority:\n * 1. Use paymasterOverride if provided (custom paymaster client)\n * 2. Check chain.contracts.paymaster for simple paymaster address\n * 3. Return undefined if no paymaster configured (user pays own gas)\n *\n * @param chain Chain configuration\n * @param paymasterOverride Optional custom paymaster client\n * @returns Paymaster config or undefined\n */\nexport function getPaymaster(\n  chain: Chain,\n  paymasterOverride?: PaymasterClient\n): Paymaster | undefined {\n  const contracts = chain.contracts ?? {}\n\n  // Use custom paymaster if provided (e.g., Coinbase Paymaster)\n  if (paymasterOverride) {\n    console.log(\n      `[Drawbridge/Paymaster] Using custom paymaster client for chain ${chain.name} (${chain.id})`\n    )\n    return {\n      type: \"custom\",\n      paymasterClient: paymasterOverride\n    }\n  }\n\n  // Check for simple paymaster in chain config\n  if (\"paymaster\" in contracts && contracts.paymaster != null) {\n    if (\"address\" in contracts.paymaster) {\n      console.log(\n        `[Drawbridge/Paymaster] Using simple paymaster at ${contracts.paymaster.address} for chain ${chain.name} (${chain.id})`\n      )\n      return {\n        type: \"simple\",\n        address: contracts.paymaster.address\n      }\n    }\n  }\n\n  // No paymaster configured - user pays own gas\n  console.log(\n    `[Drawbridge/Paymaster] No paymaster configured for chain ${chain.name} (${chain.id}) - user will pay gas`\n  )\n  return undefined\n}\n","/**\n * TEMPORARY DEBUG LOGGING\n *\n * This file contains all debug logging for gas handling development.\n * Once gas handling is stable, this entire file can be deleted and all\n * imports/calls to these functions removed.\n */\n\nimport { formatGwei } from \"viem\"\n\n/**\n * Log bundler client configuration\n */\nexport function logBundlerClientConfig(config: {\n  pollingInterval: number\n  hasPaymaster: boolean\n  paymasterType?: string\n}): void {\n  console.log(\"[Drawbridge/BundlerClient] Config:\", {\n    pollingInterval: config.pollingInterval,\n    hasPaymaster: config.hasPaymaster,\n    paymasterType: config.paymasterType\n  })\n}\n\n/**\n * Log fee estimation start for Base chains\n */\nexport function logFeeEstimationStart(): void {\n  console.log(\"[Fee Estimator] Estimating fees for Base chain...\")\n}\n\n/**\n * Log fee estimation results\n */\nexport function logFeeEstimationResult(data: {\n  networkMaxFee: bigint\n  adjustedMaxFee: bigint\n  cappedMaxFee: bigint\n  maxPriorityFeePerGas: bigint\n  maxTotalFee: bigint\n  minPriorityFee: bigint\n}): void {\n  const wasAdjusted = data.adjustedMaxFee > data.networkMaxFee\n  const wasCapped = data.cappedMaxFee < data.adjustedMaxFee\n\n  console.log(\"┌─ Fee Estimation Result ────────────────────────────\")\n  console.log(\"│\")\n  console.log(\"│ Network estimate:\")\n  console.log(\n    \"│   maxFeePerGas:         \",\n    formatGwei(data.networkMaxFee),\n    \"gwei\",\n    `(${data.networkMaxFee} wei)`\n  )\n  console.log(\"│\")\n  console.log(\"│ Our configuration:\")\n  console.log(\n    \"│   minPriorityFee:       \",\n    formatGwei(data.minPriorityFee),\n    \"gwei\",\n    `(${data.minPriorityFee} wei)`,\n    \"← Coinbase requirement\"\n  )\n  console.log(\n    \"│   maxTotalFee cap:      \",\n    formatGwei(data.maxTotalFee),\n    \"gwei\",\n    `(${data.maxTotalFee} wei)`\n  )\n  console.log(\"│\")\n  if (wasAdjusted) {\n    console.log(\"│ ⚠️  Adjustment needed:\")\n    console.log(\"│   Network's maxFeePerGas was too low for priority fee!\")\n    console.log(\n      \"│   Adjusted maxFeePerGas:\",\n      formatGwei(data.adjustedMaxFee),\n      \"gwei\",\n      `(${data.adjustedMaxFee} wei)`,\n      \"← Increased to match priority\"\n    )\n    console.log(\"│\")\n  }\n  console.log(\"│ Final values sent:\")\n  console.log(\n    \"│   maxFeePerGas:         \",\n    formatGwei(data.cappedMaxFee),\n    \"gwei\",\n    `(${data.cappedMaxFee} wei)`,\n    wasCapped ? \"← CAPPED\" : \"\"\n  )\n  console.log(\n    \"│   maxPriorityFeePerGas: \",\n    formatGwei(data.maxPriorityFeePerGas),\n    \"gwei\",\n    `(${data.maxPriorityFeePerGas} wei)`\n  )\n  console.log(\"│\")\n  if (data.cappedMaxFee < data.maxPriorityFeePerGas) {\n    console.log(\"│ ❌ ERROR: maxFeePerGas < maxPriorityFeePerGas!\")\n    console.log(\"│    This violates EIP-1559 rules and will fail!\")\n    console.log(\"│\")\n  }\n  console.log(\"└────────────────────────────────────────────────────\")\n}\n\n/**\n * Log fee estimation fallback\n */\nexport function logFeeEstimationFallback(error: unknown): void {\n  console.warn(\n    \"[Fee Estimator] Estimation failed, using defaults:\",\n    error instanceof Error ? error.message : String(error)\n  )\n}\n\n/**\n * Log bundler RPC method calls\n */\nexport function logBundlerRpcMethod(method: string): void {\n  console.log(`[Bundler RPC] ${method}`)\n}\n\n/**\n * Log user operation gas details when sending\n */\nexport function logUserOperationGas(userOp: {\n  callGasLimit: string | bigint\n  verificationGasLimit: string | bigint\n  preVerificationGas: string | bigint\n  maxFeePerGas: string | bigint\n  maxPriorityFeePerGas: string | bigint\n}): void {\n  const callGas = BigInt(userOp.callGasLimit)\n  const verifyGas = BigInt(userOp.verificationGasLimit)\n  const preVerifyGas = BigInt(userOp.preVerificationGas)\n  const maxFee = BigInt(userOp.maxFeePerGas)\n  const priorityFee = BigInt(userOp.maxPriorityFeePerGas)\n\n  console.log(\"[Bundler] Sending user operation with gas:\", {\n    callGasLimit: callGas.toString(),\n    verificationGasLimit: verifyGas.toString(),\n    preVerificationGas: preVerifyGas.toString(),\n    maxFeePerGas: formatGwei(maxFee) + \" gwei\",\n    maxPriorityFeePerGas: formatGwei(priorityFee) + \" gwei\"\n  })\n}\n\n/**\n * Log gas estimator RPC interception\n */\nexport function logGasEstimatorRpcMethod(method: string): void {\n  console.log(\"[Gas Estimator] RPC Method:\", method)\n}\n\n/**\n * Log smart account execute() unwrapping\n */\nexport function logSmartAccountUnwrap(): void {\n  console.log(\"[Gas Estimator] Unwrapping smart account execute()\")\n}\n\n/**\n * Log smart account unwrap result\n */\nexport function logSmartAccountUnwrapResult(selector: string): void {\n  console.log(\"[Gas Estimator] After unwrap, selector:\", selector)\n}\n\n/**\n * Log MUD callFrom() unwrapping\n */\nexport function logMudCallFromUnwrap(): void {\n  console.log(\"[Gas Estimator] Unwrapping MUD callFrom()\")\n}\n\n/**\n * Log MUD callFrom() unwrap result\n */\nexport function logMudCallFromUnwrapResult(selector: string): void {\n  console.log(\"[Gas Estimator] Final selector:\", selector)\n}\n\n/**\n * Log detailed gas estimate breakdown\n */\nexport function logGasEstimateBreakdown(data: {\n  selector: string | null\n  callGasLimit: bigint\n  verificationGasLimit: bigint\n  preVerificationGas: bigint\n  paymasterVerificationGasLimit: bigint\n  paymasterPostOpGasLimit: bigint\n  totalGas: bigint\n  gasPrice: number | null\n}): void {\n  console.log(\"┌─ User Operation Gas Estimate ─────────────────────\")\n  console.log(\"│ Function selector:\", data.selector)\n  console.log(\"│\")\n  console.log(\"│ Gas Breakdown:\")\n  console.log(\n    \"│   callGasLimit:               \",\n    data.callGasLimit.toString().padStart(7),\n    \"gas (CUSTOM)\"\n  )\n  console.log(\n    \"│   verificationGasLimit:       \",\n    data.verificationGasLimit.toString().padStart(7),\n    \"gas (viem default)\"\n  )\n  console.log(\n    \"│   preVerificationGas:         \",\n    data.preVerificationGas.toString().padStart(7),\n    \"gas (viem default)\"\n  )\n  console.log(\n    \"│   paymasterVerificationGasLimit:\",\n    data.paymasterVerificationGasLimit.toString().padStart(5),\n    \"gas (viem default)\"\n  )\n  console.log(\n    \"│   paymasterPostOpGasLimit:    \",\n    data.paymasterPostOpGasLimit.toString().padStart(7),\n    \"gas (viem default)\"\n  )\n  console.log(\"│   ─────────────────────────────────────────────\")\n  console.log(\"│   Total gas limit:            \", data.totalGas.toString().padStart(7), \"gas\")\n  console.log(\"│\")\n  if (data.gasPrice !== null) {\n    console.log(\"│ Current gas price:\", data.gasPrice.toFixed(3), \"gwei\")\n    const costInWei = data.totalGas * BigInt(Math.floor(data.gasPrice * 1e9))\n    console.log(\"│ Estimated max cost:\", (Number(costInWei) / 1e18).toFixed(6), \"ETH\")\n    console.log(\"│ (To get USD: multiply ETH cost × ETH price)\")\n  }\n  console.log(\"│\")\n  console.log(\"│ Source: Custom callGasLimit + viem defaults for verification\")\n  console.log(\"└───────────────────────────────────────────────────\")\n}\n\n/**\n * Log when no custom gas estimates are configured\n */\nexport function logNoCustomGasEstimates(): void {\n  console.log(\"[Gas Estimator] No custom gas estimates configured - using viem default\")\n}\n\n/**\n * Log when no measurement exists for a selector\n */\nexport function logNoMeasurementForSelector(selector: string | null): void {\n  console.log(\"[Gas Estimator] No measurement for\", selector, \"- using viem default\")\n}\n\n/**\n * Log gas estimator error\n */\nexport function logGasEstimatorError(error: unknown): void {\n  console.error(\"[Gas Estimator] Failed to get default estimate from bundler:\", error)\n}\n\n/**\n * Log comparison between bundler's default callGasLimit and our measured value\n */\nexport function logCallGasLimitComparison(data: {\n  selector: string | null\n  bundlerDefault: bigint\n  measured: bigint\n}): void {\n  const diff = Number(data.measured) - Number(data.bundlerDefault)\n  const percentDiff = (diff / Number(data.bundlerDefault)) * 100\n\n  console.log(\"[Gas Estimator] callGasLimit Comparison:\")\n  console.log(\"  Selector:\", data.selector)\n  console.log(\"  Bundler default:\", data.bundlerDefault.toString())\n  console.log(\"  Our measured:   \", data.measured.toString())\n  console.log(\n    \"  Difference:     \",\n    diff > 0 ? \"+\" + diff : diff,\n    `(${percentDiff > 0 ? \"+\" : \"\"}${percentDiff.toFixed(1)}%)`\n  )\n}\n","import { Transport, Chain, Client, RpcSchema, EstimateFeesPerGasReturnType, parseGwei } from \"viem\"\nimport { estimateFeesPerGas } from \"viem/actions\"\nimport {\n  BundlerClient,\n  BundlerClientConfig,\n  SmartAccount,\n  PaymasterClient,\n  createBundlerClient as viem_createBundlerClient\n} from \"viem/account-abstraction\"\nimport { defaultClientConfig } from \"../types\"\nimport { getPaymaster } from \"./paymaster\"\nimport { type GasEstimates } from \"./gasEstimator\"\nimport {\n  logBundlerClientConfig,\n  logFeeEstimationStart,\n  logFeeEstimationResult,\n  logFeeEstimationFallback\n} from \"./tempDebugLogging\"\n\n/**\n * Create a bundler client for submitting ERC-4337 user operations\n *\n * A bundler client is a specialized viem client that:\n * - Submits user operations to the bundler RPC\n * - Handles gas estimation for user operations (via transport wrapper)\n * - Integrates paymaster for gas sponsorship\n * - Manages smart account interactions\n *\n * This function wraps viem's createBundlerClient with:\n * - Automatic paymaster configuration from chain or override\n * - Custom fee estimation for specific chains\n * - Default polling interval\n *\n * Gas estimation is handled by the transport layer (see gasEstimator.ts).\n *\n * @param config Bundler client configuration\n * @param gasEstimates Optional custom gas estimates for specific functions\n * @returns Configured bundler client\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain = Chain,\n  account extends SmartAccount = SmartAccount,\n  client extends Client = Client,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  config: BundlerClientConfig<transport, chain, account, client, rpcSchema>,\n  gasEstimates?: GasEstimates\n): BundlerClient<transport, chain, account, client, rpcSchema> {\n  const client = config.client\n  if (!client) throw new Error(\"No `client` provided to `createBundlerClient`.\")\n\n  const chain = config.chain ?? client.chain\n  const paymaster = chain\n    ? getPaymaster(chain, config.paymaster as PaymasterClient | undefined)\n    : undefined\n\n  if (paymaster) {\n    console.log(\n      `[Drawbridge/BundlerClient] Bundler client configured with ${paymaster.type} paymaster`\n    )\n  } else {\n    console.log(`[Drawbridge/BundlerClient] Bundler client configured without paymaster`)\n  }\n\n  logBundlerClientConfig({\n    pollingInterval: defaultClientConfig.pollingInterval,\n    hasPaymaster: !!paymaster,\n    paymasterType: paymaster?.type\n  })\n\n  return viem_createBundlerClient({\n    ...defaultClientConfig,\n    // Configure paymaster for gas sponsorship\n    paymaster: paymaster\n      ? paymaster.type === \"custom\"\n        ? paymaster.paymasterClient // Use custom paymaster client (e.g., Coinbase)\n        : {\n            // Simple paymaster - just return address with empty data\n            getPaymasterData: async () => ({\n              paymaster: paymaster.address,\n              paymasterData: \"0x\"\n            })\n          }\n      : undefined,\n    // Custom fee estimation for specific chains\n    userOperation: {\n      estimateFeesPerGas: createFeeEstimator(client)\n    },\n    ...config\n  })\n}\n\n/**\n * Create custom fee estimator for specific chains\n *\n * Some chains need special handling for fee estimation:\n *\n * - **Anvil (31337)**: Hardcoded fees because Anvil's eth_maxPriorityFeePerGas\n *   returns a fixed value that doesn't match real chains\n *\n * - **Base (8453) & Base Sepolia (84532)**: Enforce minimum maxPriorityFeePerGas\n *   of 1 gwei (1,000,000 wei) as required by Coinbase bundler\n *\n * - **Other chains**: Use viem's default fee estimation (works well)\n *\n * @param client Viem client\n * @returns Fee estimator function or undefined for default behavior\n */\nfunction createFeeEstimator(\n  client: Client\n): undefined | (() => Promise<EstimateFeesPerGasReturnType<\"eip1559\">>) {\n  if (!client.chain) return\n\n  // Anvil (local development) - use fixed fees\n  // See: https://github.com/foundry-rs/foundry/pull/8081#issuecomment-2402002485\n  if (client.chain.id === 31337) {\n    return async () => ({ maxFeePerGas: 100_000n, maxPriorityFeePerGas: 0n })\n  }\n\n  // Base chains (8453 = Base, 84532 = Base Sepolia)\n  // Coinbase bundler requires minimum maxPriorityFeePerGas of 1 gwei\n  if (client.chain.id === 8453 || client.chain.id === 84532) {\n    return async () => {\n      logFeeEstimationStart()\n      try {\n        const fees = await estimateFeesPerGas(client)\n\n        // Coinbase bundler appears to require minimum 1 gwei priority fee\n        // Based on empirical testing: operations with lower fees are silently rejected\n        // See ERC-4337 spec: bundlers have \"configurable minimum\" for maxPriorityFeePerGas\n        // https://eips.ethereum.org/EIPS/eip-4337#specification (Required fields section)\n        const minPriorityFee = parseGwei(\"1\")\n\n        // Cap total fee to prevent exceeding paymaster budget during gas spikes\n        // At 750k gas × 10 gwei × $3000 ETH = $22.50 (well under reasonable limits)\n        const maxTotalFee = parseGwei(\"10\")\n\n        // Determine the priority fee (must meet Coinbase's 1 gwei minimum)\n        const priorityFee =\n          fees.maxPriorityFeePerGas > minPriorityFee ? fees.maxPriorityFeePerGas : minPriorityFee\n\n        // EIP-1559 constraint: maxFeePerGas MUST be >= maxPriorityFeePerGas\n        // If network's maxFeePerGas is too low, increase it to accommodate the priority fee\n        const adjustedMaxFee = fees.maxFeePerGas < priorityFee ? priorityFee : fees.maxFeePerGas\n\n        // Cap maxFeePerGas to prevent exceeding paymaster budget during gas spikes\n        const cappedMaxFee = adjustedMaxFee > maxTotalFee ? maxTotalFee : adjustedMaxFee\n\n        const result = {\n          maxFeePerGas: cappedMaxFee,\n          maxPriorityFeePerGas: priorityFee\n        }\n\n        logFeeEstimationResult({\n          networkMaxFee: fees.maxFeePerGas,\n          adjustedMaxFee,\n          cappedMaxFee: result.maxFeePerGas,\n          maxPriorityFeePerGas: result.maxPriorityFeePerGas,\n          maxTotalFee,\n          minPriorityFee\n        })\n\n        return result\n      } catch (error) {\n        // If eth_maxPriorityFeePerGas is not supported by the RPC provider, use safe defaults\n        // This can happen with some wallet providers or RPC endpoints\n        logFeeEstimationFallback(error)\n        return {\n          maxFeePerGas: parseGwei(\"10\"),\n          maxPriorityFeePerGas: parseGwei(\"1\") // Coinbase minimum\n        }\n      }\n    }\n  }\n\n  // All other chains - use viem's default fee estimation\n  return undefined\n}\n","import { BundlerRpcSchema, Transport, Hex, formatGwei } from \"viem\"\nimport { formatUserOperationRequest } from \"viem/account-abstraction\"\nimport {\n  logGasEstimatorRpcMethod,\n  logSmartAccountUnwrap,\n  logSmartAccountUnwrapResult,\n  logMudCallFromUnwrap,\n  logMudCallFromUnwrapResult,\n  logGasEstimateBreakdown,\n  logNoCustomGasEstimates,\n  logNoMeasurementForSelector,\n  logGasEstimatorError,\n  logCallGasLimitComparison\n} from \"./tempDebugLogging\"\n\n/**\n * Gas estimation configuration for user operations\n * Maps function selectors (4-byte hex) to gas limits\n */\nexport type GasEstimates = {\n  [selector: string]: bigint\n}\n\n/**\n * Response from eth_estimateUserOperationGas RPC call\n * All fields are returned as hex strings from the bundler\n */\ntype UserOperationGasEstimate = {\n  callGasLimit: Hex\n  verificationGasLimit: Hex\n  preVerificationGas: Hex\n  paymasterVerificationGasLimit?: Hex\n  paymasterPostOpGasLimit?: Hex\n}\n\n/**\n * Extract function selector from callData\n * Handles smart account execute wrapper and MUD callFrom wrapper\n */\nfunction extractFunctionSelector(callData: Hex): string | null {\n  if (!callData || callData.length < 10) return null\n\n  let data = callData\n\n  // Smart account's execute(address,uint256,bytes) wrapper (0xb61d27f6)\n  // Structure: selector(4) + target(32) + value(32) + dataOffset(32) + dataLength(32) + actualData\n  if (data.startsWith(\"0xb61d27f6\")) {\n    logSmartAccountUnwrap()\n    // Skip: \"0x\" + selector(8) + target(64) + value(64) + offset(64) + length(64) = 266 chars\n    const offset = 2 + 8 + 64 + 64 + 64 + 64\n    if (data.length > offset) {\n      data = (\"0x\" + data.slice(offset)) as Hex\n      logSmartAccountUnwrapResult(data.slice(0, 10))\n    }\n  }\n\n  // MUD's callFrom wraps the actual call (0xdd2bcbae)\n  // Structure: selector(4) + delegator(32) + systemId(32) + offset(32) + length(32) + actualCallData\n  if (data.startsWith(\"0xdd2bcbae\")) {\n    logMudCallFromUnwrap()\n    const offset = 2 + 8 + 64 + 64 + 64 + 64\n    if (data.length > offset + 8) {\n      data = data.slice(offset, offset + 10) as Hex\n      logMudCallFromUnwrapResult(data)\n      return data\n    }\n  }\n\n  // Direct call - first 4 bytes (8 hex chars after 0x)\n  return data.slice(0, 10) as Hex\n}\n\n/**\n * Gas estimator transport wrapper\n * Intercepts eth_estimateUserOperationGas RPC calls and returns precise estimates\n * based on provided gas measurements\n *\n * @param gasEstimates Optional map of function selectors to gas limits\n * @param getTransport The transport to wrap\n */\nexport function gasEstimator<const transport extends Transport>(\n  gasEstimates: GasEstimates | undefined,\n  getTransport: transport\n): transport {\n  return ((opts: any) => {\n    const { request: originalRequest, ...rest } = getTransport(opts)\n\n    const request = async ({ method, params }: any, options?: any) => {\n      logGasEstimatorRpcMethod(method)\n\n      if (method === \"eth_estimateUserOperationGas\") {\n        const [userOp] = params\n        const selector = extractFunctionSelector(userOp.callData)\n        const measuredGas = selector && gasEstimates ? gasEstimates[selector] : null\n\n        if (measuredGas) {\n          // First, get viem's default estimation for the other gas fields\n          let defaultEstimate: UserOperationGasEstimate\n          try {\n            defaultEstimate = await originalRequest({ method, params }, options)\n          } catch (error) {\n            logGasEstimatorError(error)\n            throw error\n          }\n\n          // Log comparison between bundler's default and our measured value\n          const bundlerDefaultCallGas = BigInt(defaultEstimate.callGasLimit)\n          logCallGasLimitComparison({\n            selector,\n            bundlerDefault: bundlerDefaultCallGas,\n            measured: measuredGas\n          })\n\n          // Override only callGasLimit with our measured value\n          // Convert hex strings to BigInt for other fields\n          // Use safe defaults if bundler doesn't provide paymaster gas values\n          const estimate = {\n            callGasLimit: measuredGas,\n            verificationGasLimit: BigInt(defaultEstimate.verificationGasLimit),\n            preVerificationGas: BigInt(defaultEstimate.preVerificationGas),\n            paymasterVerificationGasLimit: BigInt(\n              defaultEstimate.paymasterVerificationGasLimit || \"0x6978\"\n            ), // 27000 default\n            paymasterPostOpGasLimit: BigInt(defaultEstimate.paymasterPostOpGasLimit || \"0x6978\") // 27000 default\n          }\n\n          const totalGas =\n            estimate.callGasLimit +\n            estimate.verificationGasLimit +\n            estimate.preVerificationGas +\n            estimate.paymasterVerificationGasLimit +\n            estimate.paymasterPostOpGasLimit\n\n          // Try to get gas price from the user operation if available\n          const maxFeePerGas = userOp.maxFeePerGas ? BigInt(userOp.maxFeePerGas) : null\n          const gasPrice = maxFeePerGas ? Number(formatGwei(maxFeePerGas)) : null\n\n          logGasEstimateBreakdown({\n            selector,\n            callGasLimit: estimate.callGasLimit,\n            verificationGasLimit: estimate.verificationGasLimit,\n            preVerificationGas: estimate.preVerificationGas,\n            paymasterVerificationGasLimit: estimate.paymasterVerificationGasLimit,\n            paymasterPostOpGasLimit: estimate.paymasterPostOpGasLimit,\n            totalGas,\n            gasPrice\n          })\n\n          return formatUserOperationRequest(estimate)\n        }\n\n        if (!gasEstimates) {\n          logNoCustomGasEstimates()\n        } else {\n          logNoMeasurementForSelector(selector)\n        }\n      }\n\n      return originalRequest({ method, params }, options)\n    }\n\n    return { request, ...rest }\n  }) as transport\n}\n","import { Chain, http } from \"viem\"\nimport { gasEstimator, type GasEstimates } from \"./gasEstimator\"\nimport { logBundlerRpcMethod, logUserOperationGas } from \"./tempDebugLogging\"\n\n/**\n * Get bundler RPC transport for a chain\n *\n * Bundlers are special RPC endpoints that handle ERC-4337 user operations.\n * They submit user operations to the EntryPoint contract and handle gas sponsorship.\n *\n * The bundler URL must be configured in the chain's rpcUrls.bundler.http array.\n *\n * This transport is wrapped with a gas estimator that provides precise gas estimates\n * based on measured contract usage.\n *\n * @param chain Chain configuration with bundler RPC URL\n * @param gasEstimates Optional custom gas estimates for specific functions\n * @returns HTTP transport for the bundler with gas estimation\n * @throws If chain doesn't have a bundler RPC URL configured\n */\nexport function getBundlerTransport(chain: Chain, gasEstimates?: GasEstimates) {\n  const bundlerHttpUrl = chain.rpcUrls.bundler?.http[0]\n\n  if (bundlerHttpUrl) {\n    // Wrap HTTP transport with gas estimator for precise gas estimation\n    return gasEstimator(\n      gasEstimates,\n      http(bundlerHttpUrl, {\n        onFetchRequest: async request => {\n          try {\n            if (request.body) {\n              const clonedRequest = request.clone()\n              const text = await clonedRequest.text()\n              const body = JSON.parse(text)\n\n              if (body?.method) {\n                logBundlerRpcMethod(body.method)\n              }\n\n              if (body?.method === \"eth_sendUserOperation\") {\n                const userOp = body?.params?.[0]\n                if (userOp) {\n                  logUserOperationGas(userOp)\n                }\n              }\n            }\n          } catch (e) {\n            // Silently ignore parsing errors\n          }\n        }\n      })\n    )\n  }\n\n  throw new Error(`Chain ${chain.id} config did not include a bundler RPC URL.`)\n}\n","import { Account, Address, Chain, Client, LocalAccount, RpcSchema, Transport } from \"viem\"\nimport { smartAccountActions } from \"permissionless\"\nimport { callFrom, sendUserOperationFrom } from \"@latticexyz/world/internal\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { createBundlerClient } from \"../../bundler/client\"\nimport { SessionClient } from \"../../types\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { getBundlerTransport, type GasEstimates } from \"../../bundler/transport\"\n\n/**\n * Create session client with MUD World extensions\n *\n * Takes a standard ERC-4337 smart account and extends it with MUD-specific functionality:\n *\n * 1. **smartAccountActions** - Standard AA operations (sendUserOperation, etc.)\n * 2. **callFrom** - Routes writeContract calls through World.callFrom()\n *    - Automatically adds delegator context\n *    - World validates delegation before executing\n * 3. **sendUserOperationFrom** - Routes user operations through World\n * 4. **Context properties** - Adds userAddress, worldAddress, internal_signer\n *\n * The resulting SessionClient can call World systems on behalf of the user,\n * as long as delegation is registered.\n *\n * @param params Session client parameters\n * @returns SessionClient with MUD World extensions\n */\nexport async function getSessionClient({\n  userAddress,\n  sessionAccount,\n  sessionSigner,\n  worldAddress,\n  paymasterOverride,\n  gasEstimates\n}: {\n  userAddress: Address\n  sessionAccount: SmartAccount\n  sessionSigner: LocalAccount\n  worldAddress: Address\n  paymasterOverride?: PaymasterClient\n  gasEstimates?: GasEstimates\n}): Promise<SessionClient> {\n  const client = sessionAccount.client\n  if (!clientHasChain(client)) {\n    throw new Error(\"Session account client had no associated chain.\")\n  }\n\n  if (paymasterOverride) {\n    console.log(`[Drawbridge/SessionClient] Creating session client with paymaster override`)\n  }\n\n  // Create bundler client for submitting user operations\n  const bundlerClient = createBundlerClient(\n    {\n      transport: getBundlerTransport(client.chain, gasEstimates),\n      client,\n      account: sessionAccount,\n      paymaster: paymasterOverride\n    },\n    gasEstimates\n  )\n\n  // Extend with standard ERC-4337 smart account actions\n  const sessionClient = bundlerClient\n    .extend(smartAccountActions)\n    // Extend with MUD World delegation routing\n    // This intercepts writeContract calls and routes them through World.callFrom()\n    .extend(\n      callFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    // Extend with MUD World user operation routing\n    .extend(\n      sendUserOperationFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    // Add context properties for reference\n    .extend(() => ({ userAddress, worldAddress, internal_signer: sessionSigner }))\n\n  return sessionClient\n}\n\n/**\n * Type guard to ensure client has a chain\n */\nfunction clientHasChain<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  client: Client<transport, chain, account, rpcSchema>\n): client is Client<transport, Exclude<chain, undefined>, account, rpcSchema> {\n  return client.chain != null\n}\n","import { Address, Client } from \"viem\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport { unlimitedDelegationControlId, worldTables } from \"../../types\"\n\nexport type CheckDelegationParams = {\n  client: Client\n  worldAddress: Address\n  userAddress: Address\n  sessionAddress: Address\n  blockTag?: \"pending\" | \"latest\"\n}\n\n/**\n * Check if delegation exists in MUD World contract\n *\n * MUD World stores delegations in the UserDelegationControl table.\n * A delegation allows the session account (delegatee) to call World systems\n * on behalf of the user account (delegator).\n *\n * This function queries that table and checks if \"unlimited\" delegation exists,\n * which grants the session account full access to all systems.\n *\n * @param params Delegation check parameters\n * @returns true if unlimited delegation is registered, false otherwise\n */\nexport async function checkDelegation({\n  client,\n  worldAddress,\n  userAddress,\n  sessionAddress,\n  blockTag = \"pending\"\n}: CheckDelegationParams): Promise<boolean> {\n  // Query MUD Store table: UserDelegationControl[delegator][delegatee]\n  const record = await getRecord(client, {\n    address: worldAddress,\n    table: worldTables.UserDelegationControl,\n    key: { delegator: userAddress, delegatee: sessionAddress },\n    blockTag\n  })\n\n  // Check if the delegation type is \"unlimited\" (full system access)\n  return record.delegationControlId === unlimitedDelegationControlId\n}\n","import { Address, Client } from \"viem\"\nimport { getCode, sendTransaction, waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { DEPLOYMENT_TIMEOUTS } from \"../../types\"\n\n/**\n * Smart wallet deployment utilities\n *\n * Handles counterfactual smart wallets (e.g., Coinbase Smart Wallet) that use\n * CREATE2 and exist at a deterministic address before deployment.\n */\n\n/**\n * Check if an error indicates a wallet is already deployed\n *\n * ERC-4337 bundlers and smart wallets return specific error codes when\n * attempting to deploy an already-deployed wallet:\n * - AA10: Account already deployed (ERC-4337 bundler error code)\n * - \"already constructed\": Some wallet implementations\n * - \"already deployed\": Generic message from some bundlers\n * - \"is an existing contract, but initCode is nonempty\": Bundler precheck error for deployed accounts with factory data\n *\n * @param errorMessage Error message to check\n * @returns True if error indicates wallet is already deployed\n */\nexport function isAlreadyDeployedError(errorMessage: string): boolean {\n  return (\n    errorMessage.includes(\"AA10\") ||\n    errorMessage.includes(\"already constructed\") ||\n    errorMessage.includes(\"already deployed\") ||\n    errorMessage.includes(\"is an existing contract, but initCode is nonempty\")\n  )\n}\n\n/**\n * Check if a smart wallet is deployed on-chain\n *\n * @param client Client to use for checking\n * @param address Wallet address to check\n * @returns True if deployed, false otherwise\n */\nexport async function isWalletDeployed(client: Client, address: Address): Promise<boolean> {\n  const code = await getAction(\n    client,\n    getCode,\n    \"getCode\"\n  )({\n    address\n  })\n\n  return code !== undefined && code !== \"0x\"\n}\n\n/**\n * Deploy a smart wallet using a factory contract\n *\n * This handles the deployment of counterfactual smart wallets. The wallet address\n * already exists (can receive funds) but needs on-chain deployment before it can\n * validate signatures or execute transactions.\n *\n * @param client Client to use for deployment transaction (usually session client with paymaster)\n * @param factoryAddress Factory contract address that can deploy the wallet\n * @param factoryCalldata Deployment calldata for the factory\n */\nexport async function deployWallet(\n  client: Client,\n  factoryAddress: Address,\n  factoryCalldata: Address\n): Promise<void> {\n  if (!client.account) {\n    throw new Error(\"Client must have an account to deploy wallet\")\n  }\n\n  try {\n    const txHash = await getAction(\n      client,\n      sendTransaction,\n      \"sendTransaction\"\n    )({\n      account: client.account,\n      chain: client.chain,\n      to: factoryAddress,\n      data: factoryCalldata\n    })\n\n    // Wait for deployment confirmation\n    await getAction(\n      client,\n      waitForTransactionReceipt,\n      \"waitForTransactionReceipt\"\n    )({\n      hash: txHash\n    })\n\n    // Add delay for bundler/paymaster state to update\n    // After deployment, bundlers cache account state and need time to refresh\n    await new Promise(resolve => setTimeout(resolve, DEPLOYMENT_TIMEOUTS.BUNDLER_STATE_SYNC))\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n\n    // If already deployed, that's fine - not an error\n    if (isAlreadyDeployedError(errorMessage)) {\n      console.log(\"[drawbridge] Wallet already deployed, continuing\")\n      return\n    }\n\n    throw new Error(`Failed to deploy smart wallet: ${errorMessage}`)\n  }\n}\n","import { zeroAddress, Hex, Address } from \"viem\"\nimport {\n  sendUserOperation,\n  waitForUserOperationReceipt,\n  SmartAccount,\n  UserOperationReceipt\n} from \"viem/account-abstraction\"\nimport { getAction } from \"viem/utils\"\nimport { SessionClient, DEPLOYMENT_TIMEOUTS } from \"../../types\"\nimport { isAlreadyDeployedError } from \"../patterns/wallet-deployment\"\n\n/**\n * Smart account with optional factory properties (internal use only)\n * Some smart account implementations add these properties dynamically\n */\nexport type SmartAccountWithFactory = SmartAccount & {\n  factory?: Address\n  factoryData?: Hex\n}\n\n/**\n * Clear factory and factoryData properties from a smart account\n *\n * After deploying a counterfactual smart wallet, the factory properties should be\n * removed to prevent the bundler from trying to deploy again on subsequent operations.\n *\n * This function tries multiple strategies because some account implementations\n * make these properties read-only:\n * 1. Direct delete + assignment\n * 2. Object.defineProperty (for read-only properties)\n *\n * @param account Smart account to clear factory data from\n */\nexport function clearFactoryData(account: SmartAccountWithFactory): void {\n  try {\n    // Try direct deletion first\n    delete account.factory\n    delete account.factoryData\n    account.factory = undefined\n    account.factoryData = undefined\n\n    console.log(\"[drawbridge] Factory data cleared:\", {\n      stillHasFactory: !!account.factory,\n      stillHasFactoryData: !!account.factoryData\n    })\n  } catch (err) {\n    // Fall back to Object.defineProperty for read-only properties\n    console.warn(\"[drawbridge] Direct deletion failed, trying Object.defineProperty\")\n\n    try {\n      Object.defineProperty(account, \"factory\", {\n        value: undefined,\n        writable: true,\n        configurable: true\n      })\n      Object.defineProperty(account, \"factoryData\", {\n        value: undefined,\n        writable: true,\n        configurable: true\n      })\n\n      console.log(\"[drawbridge] Factory data cleared via defineProperty\")\n    } catch (fallbackErr) {\n      console.error(\"[drawbridge] Could not remove factory (readonly property)\")\n    }\n  }\n}\n\n/**\n * Setup session status updates for progress tracking\n */\nexport type SetupSessionStatus =\n  | { type: \"checking_wallet\"; message: string }\n  | { type: \"deploying_wallet\"; message: string }\n  | { type: \"wallet_deployed\"; message: string }\n  | { type: \"registering_delegation\"; message: string }\n  | { type: \"deploying_session\"; message: string }\n  | { type: \"complete\"; message: string }\n  | { type: \"error\"; message: string; error?: Error }\n\n/**\n * Common parameters for session setup (both EOA and Smart Account)\n */\nexport type SetupSessionBaseParams = {\n  /** Session smart account client with MUD extensions */\n  sessionClient: SessionClient\n  /** MUD World contract address */\n  worldAddress: Hex\n  /** Progress callback for status updates */\n  onStatus?: (status: SetupSessionStatus) => void\n}\n\n/**\n * Deploy session account if not already deployed\n *\n * This function is shared by both EOA and Smart Account setup flows.\n * It deploys the session account (ERC-4337 smart account) by sending\n * an empty user operation.\n *\n * @param sessionClient Session smart account client\n * @param onStatus Optional status callback\n */\nexport async function deploySessionAccount(\n  sessionClient: SessionClient,\n  onStatus?: (status: SetupSessionStatus) => void\n): Promise<void> {\n  const sessionDeployed = await sessionClient.account.isDeployed?.()\n  console.log(\"[drawbridge] Session account deployed:\", sessionDeployed)\n\n  if (sessionDeployed) {\n    console.log(\"[drawbridge] Session account already deployed\")\n    return\n  }\n\n  onStatus?.({ type: \"deploying_session\", message: \"Finalizing session setup...\" })\n\n  try {\n    const hash = await getAction(\n      sessionClient,\n      sendUserOperation,\n      \"sendUserOperation\"\n    )({\n      calls: [{ to: zeroAddress }]\n    })\n\n    console.log(\"[drawbridge] Session deploy tx:\", hash)\n\n    // Add timeout\n    const receiptPromise = getAction(\n      sessionClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n\n    const timeoutPromise = new Promise((_, reject) =>\n      setTimeout(\n        () =>\n          reject(\n            new Error(\n              `Session deployment timeout after ${DEPLOYMENT_TIMEOUTS.SESSION_DEPLOYMENT}ms`\n            )\n          ),\n        DEPLOYMENT_TIMEOUTS.SESSION_DEPLOYMENT\n      )\n    )\n\n    const receipt = (await Promise.race([receiptPromise, timeoutPromise])) as UserOperationReceipt\n\n    if (!receipt.success) {\n      throw new Error(\"Failed to deploy session account\")\n    }\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error)\n    console.error(\"[drawbridge] Session deployment error:\", errorMsg)\n\n    // Check if timeout but actually deployed\n    if (errorMsg.includes(\"timeout\")) {\n      const nowDeployed = await sessionClient.account.isDeployed?.()\n      if (nowDeployed) {\n        console.log(\"[drawbridge] Session deployed despite timeout\")\n        onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n        return\n      }\n    }\n\n    // Check if \"already deployed\" error (RPC cache inconsistency)\n    if (isAlreadyDeployedError(errorMsg)) {\n      console.log(\"[drawbridge] Session account already deployed (bundler confirmed)\")\n      console.log(\"[drawbridge] Waiting for RPC cache to update...\")\n\n      // Wait for RPC cache to update before re-checking\n      await new Promise(resolve => setTimeout(resolve, DEPLOYMENT_TIMEOUTS.BUNDLER_STATE_SYNC))\n\n      const nowDeployed = await sessionClient.account.isDeployed?.()\n      if (nowDeployed) {\n        console.log(\"[drawbridge] Session deployment verified after cache update\")\n        onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n        return\n      }\n\n      console.warn(\"[drawbridge] Cache still stale after delay - treating as deployed anyway\")\n      // Bundler has authoritative view - if it says deployed, trust it\n      onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n      return\n    }\n\n    onStatus?.({ type: \"error\", message: \"Session deployment failed\", error: error as Error })\n    throw error\n  }\n}\n","import { sendUserOperation, waitForUserOperationReceipt } from \"viem/account-abstraction\"\nimport { getAction } from \"viem/utils\"\nimport { unlimitedDelegationControlId, worldAbi, ConnectedClient } from \"../../types\"\nimport {\n  deployWallet,\n  isWalletDeployed,\n  isAlreadyDeployedError\n} from \"../patterns/wallet-deployment\"\nimport {\n  SetupSessionBaseParams,\n  SmartAccountWithFactory,\n  deploySessionAccount,\n  clearFactoryData\n} from \"./shared\"\n\nexport type SetupSessionSmartAccountParams = SetupSessionBaseParams & {\n  /** User's connected smart wallet client */\n  userClient: ConnectedClient\n}\n\n/**\n * Setup session for Smart Account wallets\n *\n * Smart Account Flow:\n * 1. Check if user's smart wallet is deployed on-chain\n * 2. Deploy wallet via factory if needed (counterfactual → deployed)\n * 3. Remove factory data from account to prevent deployment conflicts\n * 4. Submit user operation to register delegation in World contract\n * 5. Deploy session account if needed\n *\n * Smart accounts can use ERC-4337 user operations with paymaster sponsorship.\n * However, they may be counterfactual (not yet deployed), requiring deployment first.\n *\n * @param params Setup parameters for smart account\n */\nexport async function setupSessionSmartAccount({\n  userClient,\n  sessionClient,\n  worldAddress,\n  onStatus\n}: SetupSessionSmartAccountParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address\n  const userAddress = userClient.account.address\n\n  console.log(\"[drawbridge] Smart Account setup:\", { userAddress })\n\n  onStatus?.({ type: \"checking_wallet\", message: \"Checking wallet status...\" })\n\n  // Check and deploy user's wallet if needed\n  const account = userClient.account as SmartAccountWithFactory\n  const factoryArgs = await account.getFactoryArgs()\n  const hasFactoryData = factoryArgs.factory && factoryArgs.factoryData\n\n  console.log(\"[drawbridge] Smart wallet check:\", { hasFactoryData, userAddress })\n\n  const alreadyDeployed = await isWalletDeployed(sessionClient, userAddress)\n\n  console.log(\"[drawbridge] Wallet deployed:\", alreadyDeployed)\n\n  if (alreadyDeployed && hasFactoryData) {\n    console.log(\"[drawbridge] CASE 1: Wallet deployed and has factory data\")\n    // Wallet deployed but has factory data - remove it\n    console.log(\"[drawbridge] Removing factory data from deployed wallet\")\n    onStatus?.({ type: \"wallet_deployed\", message: \"Wallet ready\" })\n    clearFactoryData(account)\n  } else if (!alreadyDeployed && hasFactoryData) {\n    console.log(\"[drawbridge] CASE 2: Wallet not deployed and has factory data\")\n    // Wallet not deployed - deploy it\n    console.log(\"[drawbridge] Deploying user wallet...\")\n    onStatus?.({ type: \"deploying_wallet\", message: \"Deploying wallet (one-time setup)...\" })\n\n    await deployWallet(sessionClient, factoryArgs.factory!, factoryArgs.factoryData!)\n\n    // Verify deployment succeeded\n    const nowDeployed = await isWalletDeployed(sessionClient, userAddress)\n    if (!nowDeployed) {\n      throw new Error(\n        `Wallet deployment appeared to succeed but contract code not found at ${userAddress}`\n      )\n    }\n\n    onStatus?.({ type: \"wallet_deployed\", message: \"Wallet deployed successfully!\" })\n\n    // Remove factory/factoryData after deployment\n    clearFactoryData(account)\n  } else {\n    onStatus?.({ type: \"wallet_deployed\", message: \"Wallet ready\" })\n  }\n\n  // Proceed with delegation registration\n  onStatus?.({ type: \"registering_delegation\", message: \"Setting up session...\" })\n\n  const calls = [\n    {\n      to: worldAddress,\n      abi: worldAbi,\n      functionName: \"registerDelegation\",\n      args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n    }\n  ]\n\n  // Final check: if factory/factoryData still present, try removal again\n  const accountBeforeSend = userClient.account as SmartAccountWithFactory\n  if (accountBeforeSend.factory || accountBeforeSend.factoryData) {\n    console.warn(\"[drawbridge] Factory still present, attempting removal again...\")\n    clearFactoryData(accountBeforeSend)\n  }\n\n  try {\n    const hash = await getAction(userClient, sendUserOperation, \"sendUserOperation\")({ calls })\n    console.log(\"[drawbridge] User operation sent:\", hash)\n\n    const receipt = await getAction(\n      userClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n\n    if (!receipt.success) {\n      throw new Error(\"User operation failed during session setup\")\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n    console.error(\"[drawbridge] User operation error:\", errorMessage)\n\n    if (isAlreadyDeployedError(errorMessage)) {\n      const helpfulError = new Error(\n        \"Smart wallet deployment conflict. Please try again - it should work on the second attempt.\"\n      )\n      onStatus?.({ type: \"error\", message: \"Please try again\", error: helpfulError })\n      throw helpfulError\n    }\n\n    onStatus?.({ type: \"error\", message: \"Session setup failed\", error: error as Error })\n    throw error\n  }\n\n  // Deploy session account if needed\n  await deploySessionAccount(sessionClient, onStatus)\n\n  console.log(\"[drawbridge] Smart Account setup complete\")\n  onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n}\n","import { Address, Chain, Client, Hex, OneOf, Transport, toHex } from \"viem\"\nimport { signTypedData } from \"viem/actions\"\nimport { callWithSignatureTypes } from \"@latticexyz/world-module-callwithsignature/internal\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport moduleConfig from \"@latticexyz/world-module-callwithsignature/mud.config\"\nimport { hexToResource } from \"@latticexyz/common\"\nimport { getAction } from \"viem/utils\"\nimport { ConnectedClient } from \"../../types\"\n\nexport type SignCallOptions<chain extends Chain = Chain> = {\n  userClient: ConnectedClient<chain>\n  worldAddress: Address\n  systemId: Hex\n  callData: Hex\n} & OneOf<{ nonce: bigint } | { client: Client<Transport, chain> }>\n\n/**\n * Sign a World system call using EIP-712 (for CallWithSignature pattern)\n *\n * This creates a signature that can be submitted by the session account to execute\n * a call on behalf of the user (EOA).\n *\n * Flow:\n * 1. **Fetch or use nonce** - Each user has a nonce in CallWithSignatureNonces table\n *    Prevents replay attacks\n *\n * 2. **Parse systemId** - MUD system IDs are resource IDs with namespace + name\n *    e.g., \"world:PlayerSystem\" → { namespace: \"world\", name: \"PlayerSystem\" }\n *\n * 3. **Sign EIP-712 message** - User signs typed data with:\n *    - Domain: World contract + chain ID\n *    - Message: signer, system, callData, nonce\n *\n * The resulting signature can be submitted to World.callWithSignature()\n * by the session account, which will validate and execute as the user.\n *\n * **Why this pattern?**\n * - EOAs can't pay gas via paymaster directly (not smart accounts)\n * - User signs message (free, no gas)\n * - Session account submits + pays gas via paymaster\n * - User gets gasless experience!\n *\n * @param options Sign options including user client and call details\n * @returns EIP-712 signature\n */\nexport async function signCall<chain extends Chain = Chain>({\n  userClient,\n  worldAddress,\n  systemId,\n  callData,\n  nonce: initialNonce,\n  client\n}: SignCallOptions<chain>) {\n  // Get nonce for replay protection\n  // Either use provided nonce or fetch from World contract\n  const nonce =\n    initialNonce ??\n    (client\n      ? (\n          await getRecord(client, {\n            address: worldAddress,\n            table: moduleConfig.tables.CallWithSignatureNonces,\n            key: { signer: userClient.account.address },\n            blockTag: \"pending\"\n          })\n        ).nonce\n      : 0n)\n\n  // Parse MUD system ID into namespace and name components\n  const { namespace: systemNamespace, name: systemName } = hexToResource(systemId)\n\n  // Sign EIP-712 typed data\n  // User signs this message, session account will submit it\n  return await getAction(\n    userClient,\n    signTypedData,\n    \"signTypedData\"\n  )({\n    account: userClient.account,\n    // EIP-712 domain bound to World contract and chain\n    domain: {\n      verifyingContract: worldAddress,\n      salt: toHex(userClient.chain.id, { size: 32 })\n    },\n    // MUD's CallWithSignature type definitions\n    types: callWithSignatureTypes,\n    primaryType: \"Call\",\n    // Message contains all call details + nonce\n    message: {\n      signer: userClient.account.address,\n      systemNamespace,\n      systemName,\n      callData,\n      nonce\n    }\n  })\n}\n","import { Chain } from \"viem\"\nimport { writeContract as viem_writeContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { SignCallOptions, signCall } from \"./eip712-signing\"\nimport CallWithSignatureAbi from \"@latticexyz/world-module-callwithsignature/out/CallWithSignatureSystem.sol/CallWithSignatureSystem.abi.json\"\nimport { ConnectedClient } from \"../../types\"\n\nexport type CallWithSignatureOptions<chain extends Chain = Chain> = SignCallOptions<chain> & {\n  sessionClient: ConnectedClient\n}\n\n/**\n * Call a World system using signature-based execution (for EOAs)\n *\n * MUD's CallWithSignature pattern allows EOAs to execute gasless transactions:\n *\n * 1. User signs an EIP-712 message (free, off-chain)\n * 2. Session account submits the signature + call to World\n * 3. World's CallWithSignatureSystem validates the signature\n * 4. If valid, executes the call as the user (with user's identity)\n *\n * This enables gasless transactions - the session account pays gas via paymaster,\n * but the call executes with the user's permissions/identity.\n *\n * Flow:\n *   User (EOA) → signs message → Session Account → submits to World\n *   → World validates signature → executes as User\n *\n * @param options Call parameters including user client and session client\n * @returns Transaction hash\n */\nexport async function callWithSignature<chain extends Chain = Chain>({\n  sessionClient,\n  ...opts\n}: CallWithSignatureOptions<chain>) {\n  const signature = await signCall(opts)\n\n  // Submit transaction to World\n  // TypeScript workaround: viem's writeContract has complex type inference that\n  // doesn't perfectly match the CallWithSignatureAbi args structure.\n  // The runtime types are correct - we're calling:\n  // callWithSignature(address signer, bytes32 systemId, bytes callData, bytes signature)\n  // This cast is safe because we're manually constructing the correct args array.\n  return await getAction(\n    sessionClient,\n    viem_writeContract,\n    \"writeContract\"\n  )({\n    address: opts.worldAddress,\n    abi: CallWithSignatureAbi,\n    functionName: \"callWithSignature\",\n    args: [opts.userClient.account.address, opts.systemId, opts.callData, signature]\n  } as never)\n}\n","import { encodeFunctionData, Client } from \"viem\"\nimport { waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport IBaseWorldAbi from \"@latticexyz/world/out/IBaseWorld.sol/IBaseWorld.abi.json\"\nimport { systemsConfig as worldSystemsConfig } from \"@latticexyz/world/mud.config\"\nimport { unlimitedDelegationControlId, ConnectedClient } from \"../../types\"\nimport { callWithSignature } from \"../patterns/call-with-signature\"\nimport { SetupSessionBaseParams, deploySessionAccount } from \"./shared\"\n\nexport type SetupSessionEOAParams = SetupSessionBaseParams & {\n  /** Public client for reading blockchain state */\n  publicClient: Client\n  /** User's connected EOA wallet client */\n  userClient: ConnectedClient\n}\n\n/**\n * Setup session for EOA wallets\n *\n * EOA Flow (CallWithSignature Pattern):\n * 1. User signs an EIP-712 message off-chain (free, no gas)\n * 2. Session account submits the signature + call to World\n * 3. World.callWithSignature() validates the signature\n * 4. If valid, World registers delegation as the user\n * 5. Deploy session account\n *\n * @param params Setup parameters for EOA\n */\nexport async function setupSessionEOA({\n  publicClient,\n  userClient,\n  sessionClient,\n  worldAddress,\n  onStatus\n}: SetupSessionEOAParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address\n  const userAddress = userClient.account.address\n\n  console.log(\"[drawbridge] EOA setup:\", { userAddress })\n\n  onStatus?.({ type: \"registering_delegation\", message: \"Setting up session...\" })\n\n  const hash = await callWithSignature({\n    client: sessionClient,\n    userClient,\n    sessionClient,\n    worldAddress,\n    systemId: worldSystemsConfig.systems.RegistrationSystem.systemId,\n    callData: encodeFunctionData({\n      abi: IBaseWorldAbi,\n      functionName: \"registerDelegation\",\n      args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n    })\n  })\n\n  const receipt = await getAction(\n    publicClient,\n    waitForTransactionReceipt,\n    \"waitForTransactionReceipt\"\n  )({ hash })\n\n  if (receipt.status === \"reverted\") {\n    throw new Error(\"Delegation registration transaction reverted\")\n  }\n\n  // Deploy session account if needed\n  await deploySessionAccount(sessionClient, onStatus)\n\n  console.log(\"[drawbridge] EOA setup complete\")\n  onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n}\n","import { Hex, Client } from \"viem\"\nimport { SessionClient, ConnectedClient } from \"../../types\"\nimport { SetupSessionStatus } from \"./shared\"\nimport { setupSessionSmartAccount } from \"./smart-account\"\nimport { setupSessionEOA } from \"./eoa\"\nimport { checkDelegation } from \"./check\"\n\n/**\n * Complete setup session parameters (supports both EOA and Smart Account)\n */\nexport type SetupSessionParams = {\n  /** Public client for reading blockchain state */\n  publicClient: Client\n  /** User's connected wallet client (EOA or Smart Account) */\n  userClient: ConnectedClient\n  /** Session smart account client with MUD extensions */\n  sessionClient: SessionClient\n  /** MUD World contract address */\n  worldAddress: Hex\n  /** Progress callback for status updates */\n  onStatus?: (status: SetupSessionStatus) => void\n}\n\n// Re-export SetupSessionStatus for convenience\nexport type { SetupSessionStatus }\n\n/**\n * Setup session by registering delegation and deploying session account\n *\n * This is the main entry point that automatically routes to the correct implementation\n * based on the user's wallet type.\n *\n * Returns early if session is already fully set up.\n *\n * Flow differs based on wallet type:\n *\n * **Smart Account Wallet:**\n * - Checks and deploys user's wallet if needed\n * - Sends user operation to register delegation\n * - User's smart account submits the operation\n * - Uses bundler + paymaster infrastructure\n *\n * **EOA (Externally Owned Account):**\n * - Uses CallWithSignature pattern (gasless for user)\n * - User signs a message (EIP-712)\n * - Session account submits the signature + call\n * - World validates signature and executes as user\n *\n * @param params Setup parameters\n */\nexport async function setupSession({\n  publicClient,\n  userClient,\n  sessionClient,\n  worldAddress,\n  onStatus\n}: SetupSessionParams): Promise<void> {\n  const userAddress = userClient.account.address\n  const sessionAddress = sessionClient.account.address\n\n  console.log(\"[drawbridge] Setup session:\", {\n    userAddress,\n    accountType: userClient.account.type\n  })\n\n  // Check if session is already fully set up\n  const hasDelegation = await checkDelegation({\n    client: publicClient,\n    worldAddress,\n    userAddress,\n    sessionAddress\n  })\n\n  const sessionDeployed = await sessionClient.account.isDeployed?.()\n\n  if (hasDelegation && sessionDeployed) {\n    console.log(\"[drawbridge] Session already fully set up, skipping\")\n    onStatus?.({ type: \"complete\", message: \"Session already set up!\" })\n    return\n  }\n\n  console.log(\"[drawbridge] Session setup required:\", { hasDelegation, sessionDeployed })\n\n  // Route to appropriate implementation based on wallet type\n  if (userClient.account.type === \"smart\") {\n    return setupSessionSmartAccount({\n      userClient,\n      sessionClient,\n      worldAddress,\n      onStatus\n    })\n  } else {\n    return setupSessionEOA({\n      publicClient,\n      userClient,\n      sessionClient,\n      worldAddress,\n      onStatus\n    })\n  }\n}\n","import { Chain, Transport } from \"viem\"\nimport { createConfig, createStorage, type Config, type CreateConnectorFn } from \"@wagmi/core\"\n\n/**\n * Configuration parameters for creating wagmi config\n */\nexport type WalletConfigParams = {\n  /** Supported chains */\n  chains: readonly [Chain, ...Chain[]]\n  /** Transport configuration per chain */\n  transports: Record<number, Transport>\n  /** Wallet connectors (injected, walletConnect, etc.) */\n  connectors: CreateConnectorFn[]\n  /** Optional polling interval in milliseconds */\n  pollingInterval?: number\n}\n\n/**\n * Create wagmi configuration for wallet connection\n *\n * Configures wagmi with:\n * - Chains and transports for RPC communication\n * - Wallet connectors (MetaMask, WalletConnect, Coinbase, etc.)\n * - localStorage persistence for connection state\n * - Optional polling interval for state updates\n *\n * @param params Configuration parameters\n * @returns Wagmi Config instance\n */\nexport function createWalletConfig({\n  chains,\n  transports,\n  connectors,\n  pollingInterval\n}: WalletConfigParams): Config {\n  return createConfig({\n    chains,\n    transports,\n    connectors,\n    pollingInterval,\n    storage: createStorage({\n      storage: typeof window !== \"undefined\" ? window.localStorage : undefined\n    })\n  })\n}\n","import { watchAccount, type Config } from \"@wagmi/core\"\nimport type { GetAccountReturnType } from \"@wagmi/core\"\n\n/**\n * Account change handler callback\n *\n * Called whenever the connected wallet account changes (connect, disconnect, switch).\n */\nexport type AccountChangeHandler = (account: GetAccountReturnType) => void | Promise<void>\n\n/**\n * Cleanup function returned by setupAccountWatcher\n *\n * Call this to stop watching for account changes.\n */\nexport type UnwatchAccount = () => void\n\n/**\n * Setup wagmi account watcher\n *\n * Watches for wallet connection state changes and calls the provided handler.\n *\n * Changes detected:\n * - Wallet connected\n * - Wallet disconnected\n * - Account switched\n * - Chain switched\n *\n * @param wagmiConfig Wagmi configuration instance\n * @param onChange Handler called on account changes\n * @returns Cleanup function to stop watching\n *\n * @example\n * ```typescript\n * const unwatch = setupAccountWatcher(wagmiConfig, async (account) => {\n *   if (account.isConnected) {\n *     console.log(\"Connected:\", account.address)\n *     await handleConnection(account)\n *   } else {\n *     console.log(\"Disconnected\")\n *     await handleDisconnection()\n *   }\n * })\n *\n * // Later, stop watching\n * unwatch()\n * ```\n */\nexport function setupAccountWatcher(\n  wagmiConfig: Config,\n  onChange: AccountChangeHandler\n): UnwatchAccount {\n  return watchAccount(wagmiConfig, {\n    onChange: account => {\n      console.log(\"[wallet] Account change:\", {\n        isConnected: account.isConnected,\n        address: account.address\n      })\n\n      // Call handler (may be async)\n      const result = onChange(account)\n      if (result instanceof Promise) {\n        result.catch(err => {\n          console.error(\"[wallet] Account change handler failed:\", err)\n        })\n      }\n    }\n  })\n}\n","import { Address } from \"viem\"\nimport { reconnect, connect, disconnect, getConnectors, getAccount, type Config } from \"@wagmi/core\"\n\n/**\n * Result of reconnection attempt\n */\nexport type ReconnectResult = {\n  /** Whether reconnection was successful */\n  reconnected: boolean\n  /** Connected account address if reconnected */\n  address?: Address\n}\n\n/**\n * Attempt to reconnect to previously connected wallet\n *\n * Checks localStorage for previous connection state and attempts to restore it.\n * This should be called during initialization.\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Reconnection result\n *\n * @example\n * ```typescript\n * const result = await attemptReconnect(wagmiConfig)\n * if (result.reconnected) {\n *   console.log(\"Reconnected to:\", result.address)\n *   // Handle reconnected state\n * } else {\n *   console.log(\"No previous connection\")\n *   // Start in disconnected state\n * }\n * ```\n */\nexport async function attemptReconnect(wagmiConfig: Config): Promise<ReconnectResult> {\n  try {\n    await reconnect(wagmiConfig)\n\n    const account = getAccount(wagmiConfig)\n    if (account.isConnected && account.address) {\n      console.log(\"[wallet] Reconnection successful:\", account.address)\n      return {\n        reconnected: true,\n        address: account.address\n      }\n    }\n\n    console.log(\"[wallet] Reconnected but no account\")\n    return { reconnected: false }\n  } catch (err) {\n    console.log(\"[wallet] No previous connection to restore\")\n    return { reconnected: false }\n  }\n}\n\n/**\n * Connect to a wallet by connector ID\n *\n * @param wagmiConfig Wagmi configuration instance\n * @param connectorId Connector ID to connect to\n * @param chainId Optional chain ID to connect on\n * @throws If connector not found or connection fails\n *\n * @example\n * ```typescript\n * try {\n *   await connectWallet(wagmiConfig, \"injected\", 8453)\n *   console.log(\"Connected successfully\")\n * } catch (err) {\n *   if (err.name === \"ConnectorAlreadyConnectedError\") {\n *     console.log(\"Already connected\")\n *   } else {\n *     console.error(\"Connection failed:\", err)\n *   }\n * }\n * ```\n */\nexport async function connectWallet(\n  wagmiConfig: Config,\n  connectorId: string,\n  chainId?: number\n): Promise<void> {\n  const connectors = getConnectors(wagmiConfig)\n  const connector = connectors.find(c => c.id === connectorId)\n\n  if (!connector) {\n    throw new Error(`Connector not found: ${connectorId}`)\n  }\n\n  console.log(\"[wallet] Connecting to wallet:\", connectorId)\n\n  await connect(wagmiConfig, {\n    connector,\n    chainId\n  })\n\n  console.log(\"[wallet] Connection initiated\")\n}\n\n/**\n * Disconnect the currently connected wallet\n *\n * Clears wagmi connection state and localStorage.\n *\n * @param wagmiConfig Wagmi configuration instance\n *\n * @example\n * ```typescript\n * await disconnectWallet(wagmiConfig)\n * console.log(\"Disconnected\")\n * ```\n */\nexport async function disconnectWallet(wagmiConfig: Config): Promise<void> {\n  console.log(\"[wallet] Disconnecting...\")\n\n  try {\n    await disconnect(wagmiConfig)\n    console.log(\"[wallet] Disconnected successfully\")\n  } catch (err) {\n    console.error(\"[wallet] Disconnect error:\", err)\n    throw err\n  }\n}\n\n/**\n * Get current account information\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Current account state\n *\n * @example\n * ```typescript\n * const account = getCurrentAccount(wagmiConfig)\n * if (account.isConnected) {\n *   console.log(\"Connected:\", account.address)\n * }\n * ```\n */\nexport function getCurrentAccount(wagmiConfig: Config) {\n  return getAccount(wagmiConfig)\n}\n\n/**\n * Get list of available wallet connectors\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Array of available connectors\n *\n * @example\n * ```typescript\n * const connectors = getAvailableConnectors(wagmiConfig)\n * console.log(\"Available wallets:\", connectors.map(c => c.name))\n * ```\n */\nexport function getAvailableConnectors(wagmiConfig: Config) {\n  return getConnectors(wagmiConfig)\n}\n","import { Address, Chain, Client, Transport, Account } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { SessionClient, DrawbridgeStatus } from \"./types\"\nimport { getSessionSigner } from \"./session/core/signer\"\nimport { getSessionAccount } from \"./session/core/account\"\nimport { getSessionClient } from \"./session/core/client\"\nimport { checkDelegation } from \"./session/delegation/check\"\nimport { setupSession, type SetupSessionStatus } from \"./session/delegation/setup\"\nimport { sessionStorage } from \"./session/core/storage\"\nimport { getConnectorClient, type Config, type CreateConnectorFn } from \"@wagmi/core\"\nimport {\n  createWalletConfig,\n  setupAccountWatcher,\n  attemptReconnect,\n  connectWallet as walletConnect,\n  disconnectWallet as walletDisconnect,\n  getAvailableConnectors as walletGetAvailableConnectors\n} from \"./wallet\"\n\n/**\n * Gas estimation configuration for user operations\n * Maps function selectors (4-byte hex) to gas limits\n */\nexport type GasEstimates = {\n  /** Maps function selector (e.g., \"0x4575ab44\") to callGasLimit */\n  [selector: string]: bigint\n}\n\n/**\n * Configuration for Drawbridge instance\n */\nexport type DrawbridgeConfig = {\n  /** Chain ID to operate on */\n  chainId: number\n  /** Supported chains */\n  chains: readonly [Chain, ...Chain[]]\n  /** Transport configuration per chain */\n  transports: Record<number, Transport>\n  /** Wallet connectors (injected, walletConnect, etc.) */\n  connectors: CreateConnectorFn[]\n  /** MUD World contract address (optional if skipSessionSetup is true) */\n  worldAddress?: Address\n  /** Optional paymaster client for sponsored transactions */\n  paymasterClient?: PaymasterClient\n  /** Optional polling interval for wagmi (in ms) */\n  pollingInterval?: number\n  /** Optional app name for wallet connectors */\n  appName?: string\n  /**\n   * Optional custom gas estimates for user operations\n   * Maps function selectors to callGasLimit values\n   * If not provided, uses viem's default estimation\n   * @example\n   * gasEstimates: {\n   *   \"0x4575ab44\": 528000n, // liquidateRat\n   *   \"0x894ecc58\": 587500n  // createRat\n   * }\n   */\n  gasEstimates?: GasEstimates\n  /**\n   * Skip session setup entirely - wallet connection only mode\n   * Use this for apps that don't need MUD delegation/session accounts.\n   * When true:\n   * - No session account created\n   * - No delegation registration\n   * - Only provides connected wallet client via wagmi\n   * - worldAddress is optional\n   * @default false\n   */\n  skipSessionSetup?: boolean\n}\n\n/**\n * Current state of the Drawbridge instance\n * Updated reactively and broadcast to subscribers\n */\nexport type DrawbridgeState = {\n  /** Current status of Drawbridge - single source of truth */\n  status: DrawbridgeStatus\n  /** Session client with MUD World extensions, null if not connected */\n  sessionClient: SessionClient | null\n  /** Original user's wallet address, null if not connected */\n  userAddress: Address | null\n  /** Session smart account address, null if not connected */\n  sessionAddress: Address | null\n  /** Whether session has delegation registered and is ready to use */\n  isReady: boolean\n  /** Error that occurred during connection or session setup, null if no error */\n  error: Error | null\n}\n\n/**\n * Result of checking session prerequisites\n */\nexport type PrerequisiteStatus = {\n  /** Whether delegation is registered in World contract */\n  hasDelegation: boolean\n  /** Whether session is fully ready (same as hasDelegation) */\n  isReady: boolean\n}\n\ntype StateListener = (state: DrawbridgeState) => void\ntype Unsubscribe = () => void\n\n/**\n * Connector info for UI display\n */\nexport type ConnectorInfo = {\n  id: string\n  name: string\n  type: string\n}\n\n/**\n * Drawbridge - Headless wallet connection and session management\n *\n * Based on @latticexyz/drawbridge - a stripped down, headless version.\n *\n * Provides complete wallet connection and session management:\n * - Wagmi integration (connectors, account watching, reconnection)\n * - ERC-4337 session account creation\n * - MUD World delegation registration\n * - Reactive state management (framework-agnostic)\n * - Gasless transaction support via paymaster\n *\n * Usage:\n * ```typescript\n * const drawbridge = new Drawbridge({\n *   chainId: 8453,\n *   chains: [baseChain],\n *   transports: { 8453: http() },\n *   connectors: [injected()],\n *   worldAddress: \"0x...\"\n * });\n *\n * // Initialize (await reconnection, setup watchers)\n * await drawbridge.initialize();\n *\n * // Get available wallets\n * const wallets = drawbridge.getAvailableConnectors();\n *\n * // Connect to wallet\n * await drawbridge.connectWallet(wallets[0].id);\n *\n * // Setup delegation if needed\n * if (!drawbridge.isReady) {\n *   await drawbridge.setupSession();\n * }\n *\n * // Disconnect\n * await drawbridge.disconnectWallet();\n * ```\n */\nexport class Drawbridge {\n  private config: DrawbridgeConfig\n  private state: DrawbridgeState\n  private listeners = new Set<StateListener>()\n  private wagmiConfig: Config\n  private accountWatcherCleanup: (() => void) | null = null\n  private isConnecting = false\n  private isDisconnecting = false\n\n  constructor(config: DrawbridgeConfig) {\n    // Validate configuration\n    this.validateConfig(config)\n\n    this.config = config\n    this.state = {\n      status: DrawbridgeStatus.UNINITIALIZED,\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false,\n      error: null\n    }\n\n    // Create wagmi config\n    this.wagmiConfig = createWalletConfig({\n      chains: config.chains,\n      transports: config.transports,\n      connectors: config.connectors,\n      pollingInterval: config.pollingInterval\n    })\n  }\n\n  /**\n   * Validate configuration parameters\n   *\n   * Throws errors for invalid configuration to help developers catch issues early.\n   * @private\n   */\n  private validateConfig(config: DrawbridgeConfig): void {\n    // Validate chains\n    if (!config.chains || config.chains.length === 0) {\n      throw new Error(\n        \"Drawbridge configuration error: At least one chain must be configured. \" +\n          \"Provide chains in the 'chains' parameter.\"\n      )\n    }\n\n    // Validate connectors\n    if (!config.connectors || config.connectors.length === 0) {\n      throw new Error(\n        \"Drawbridge configuration error: At least one wallet connector must be configured. \" +\n          \"Add connectors like injected(), coinbaseWallet(), or walletConnect().\"\n      )\n    }\n\n    // Validate transports\n    if (!config.transports || Object.keys(config.transports).length === 0) {\n      throw new Error(\n        \"Drawbridge configuration error: Transports configuration is required. \" +\n          \"Provide an RPC transport for each chain.\"\n      )\n    }\n\n    // Check all chains have transports\n    for (const chain of config.chains) {\n      if (!(chain.id in config.transports)) {\n        throw new Error(\n          `Drawbridge configuration error: No transport configured for chain ${chain.id} (${chain.name}). ` +\n            `Add it to the transports parameter: { ${chain.id}: http(\"https://...\") }`\n        )\n      }\n    }\n\n    // Check chainId is in chains array\n    const chainIdValid = config.chains.some(chain => chain.id === config.chainId)\n    if (!chainIdValid) {\n      throw new Error(\n        `Drawbridge configuration error: chainId ${config.chainId} is not in the chains array. ` +\n          `Provide a chain with id ${config.chainId} in the chains parameter.`\n      )\n    }\n\n    // Warn if worldAddress missing with session setup enabled\n    if (!config.skipSessionSetup && !config.worldAddress) {\n      console.warn(\n        \"[drawbridge] Configuration warning: worldAddress not provided but session setup is enabled. \" +\n          \"Session creation will work, but delegation checks will fail. \" +\n          \"Did you forget to pass worldAddress, or did you mean to set skipSessionSetup: true?\"\n      )\n    }\n\n    // Validate worldAddress if session setup is enabled\n    if (!config.skipSessionSetup && config.worldAddress) {\n      // Check that worldAddress is a valid hex address\n      if (!/^0x[a-fA-F0-9]{40}$/.test(config.worldAddress)) {\n        throw new Error(\n          `Drawbridge configuration error: worldAddress \"${config.worldAddress}\" is not a valid Ethereum address. ` +\n            `Expected format: 0x followed by 40 hexadecimal characters.`\n        )\n      }\n    }\n  }\n\n  /**\n   * Initialize Drawbridge (await reconnection and setup account watcher)\n   *\n   * This should be called once after construction and awaited.\n   * It will attempt to reconnect to a previously connected wallet.\n   */\n  async initialize(): Promise<void> {\n    console.log(\"[drawbridge] Initializing...\")\n\n    // Attempt to reconnect to previously connected wallet\n    const result = await attemptReconnect(this.wagmiConfig)\n\n    if (!result.reconnected) {\n      // No reconnection - set status to DISCONNECTED\n      this.updateState({ status: DrawbridgeStatus.DISCONNECTED })\n    }\n\n    // Setup account watcher for future changes\n    this.setupAccountWatcher()\n\n    // If reconnection succeeded, manually handle the initial connection\n    // (the watcher won't fire for connections that happened before it was set up)\n    if (result.reconnected && result.address) {\n      console.log(\"[drawbridge] Processing reconnected wallet:\", result.address)\n      await this.handleWalletConnection()\n    }\n\n    console.log(\"[drawbridge] Initialization complete\")\n  }\n\n  // ===== Reactive State Management =====\n\n  /**\n   * Subscribe to state changes\n   *\n   * The listener will be called immediately with the current state,\n   * and again whenever the state changes.\n   *\n   * @param listener Function to call on state changes\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = drawbridge.subscribe((state) => {\n   *   if (state.sessionClient) {\n   *     console.log(\"Session ready:\", state.sessionClient.account.address);\n   *   }\n   * });\n   *\n   * // Later, stop listening\n   * unsubscribe();\n   * ```\n   */\n  subscribe(listener: StateListener): Unsubscribe {\n    this.listeners.add(listener)\n    listener(this.state) // Immediate callback with current state\n    return () => this.listeners.delete(listener)\n  }\n\n  /**\n   * Get current state (non-reactive snapshot)\n   *\n   * For reactive updates, use subscribe() instead.\n   */\n  getState(): DrawbridgeState {\n    return { ...this.state }\n  }\n\n  private updateState(updates: Partial<DrawbridgeState>): void {\n    this.state = { ...this.state, ...updates }\n    this.notify()\n  }\n\n  private notify(): void {\n    this.listeners.forEach(listener => listener(this.state))\n  }\n\n  /**\n   * Setup wagmi account watcher to handle connection/disconnection\n   * Called automatically by initialize()\n   */\n  private setupAccountWatcher(): void {\n    const unwatch = setupAccountWatcher(this.wagmiConfig, async account => {\n      // Handle disconnection\n      if (!account.isConnected) {\n        console.log(\"[drawbridge] Wallet disconnected\")\n        this.updateState({\n          status: DrawbridgeStatus.DISCONNECTED,\n          sessionClient: null,\n          userAddress: null,\n          sessionAddress: null,\n          isReady: false,\n          error: null\n        })\n        this.isConnecting = false\n        return\n      }\n\n      // Ignore connection attempts while disconnecting to prevent deadlock\n      if (this.isDisconnecting) {\n        console.log(\"[drawbridge] Ignoring connection attempt during disconnect\")\n        return\n      }\n\n      // Handle connection\n      if (this.isConnecting) {\n        console.log(\"[drawbridge] Already processing connection\")\n        return\n      }\n\n      if (!account.connector || !account.address) {\n        return\n      }\n\n      try {\n        this.isConnecting = true\n        await this.handleWalletConnection()\n      } catch (err) {\n        console.error(\"[drawbridge] Connection handler failed:\", err)\n        // Propagate error through state so UI can handle it\n        this.updateState({\n          status: DrawbridgeStatus.ERROR,\n          error: err instanceof Error ? err : new Error(String(err))\n        })\n      } finally {\n        this.isConnecting = false\n      }\n    })\n\n    this.accountWatcherCleanup = unwatch\n  }\n\n  /**\n   * Internal handler for wallet connection\n   * Called when wagmi detects a connected account\n   */\n  private async handleWalletConnection(): Promise<void> {\n    // Get wallet client from wagmi\n    let userClient: Client\n    try {\n      userClient = await getConnectorClient(this.wagmiConfig)\n    } catch (err) {\n      console.log(\"[drawbridge] Could not get connector client\")\n      return\n    }\n\n    if (!userClient.account || !userClient.chain) {\n      console.log(\"[drawbridge] Wallet client missing account or chain\")\n      return\n    }\n\n    const userAddress = userClient.account.address\n    console.log(\"[drawbridge] Wallet connected:\", userAddress)\n\n    // Validate wallet is on the correct chain\n    if (userClient.chain.id !== this.config.chainId) {\n      const error = new Error(\n        `Chain mismatch: wallet on chain ${userClient.chain.id}, expected ${this.config.chainId}`\n      )\n      console.error(\"[drawbridge]\", error.message)\n      throw error\n    }\n\n    // If skipSessionSetup is true, just store the user address and mark as READY\n    // No session account, no delegation - just wallet connection\n    if (this.config.skipSessionSetup) {\n      console.log(\"[drawbridge] Skipping session setup (wallet-only mode)\")\n      this.updateState({\n        status: DrawbridgeStatus.READY,\n        sessionClient: null,\n        userAddress,\n        sessionAddress: null,\n        isReady: true,\n        error: null\n      })\n      return\n    }\n\n    // Full session setup flow (MUD delegation)\n    console.log(\"[drawbridge] Setting up session for address:\", userAddress)\n\n    // Get or create persistent session signer from localStorage\n    const signer = getSessionSigner(userAddress)\n\n    // Create ERC-4337 SimpleAccount smart wallet\n    // TypeScript: We've already checked chain exists on line 298, so cast is safe\n    const { account } = await getSessionAccount({\n      client: userClient as Client<Transport, Chain, Account>,\n      userAddress\n    })\n\n    // Create session client with MUD World callFrom/sendUserOperationFrom extensions\n    const sessionClient = await getSessionClient({\n      userAddress,\n      sessionAccount: account,\n      sessionSigner: signer,\n      worldAddress: this.config.worldAddress!,\n      paymasterOverride: this.config.paymasterClient,\n      gasEstimates: this.config.gasEstimates\n    })\n\n    // Check if delegation already exists BEFORE notifying listeners\n    // This prevents UI flash where sessionClient exists but isReady is unknown\n    let hasDelegation = false\n    try {\n      hasDelegation = await checkDelegation({\n        client: sessionClient,\n        worldAddress: this.config.worldAddress!,\n        userAddress,\n        sessionAddress: account.address\n      })\n    } catch (err) {\n      console.error(\"[drawbridge] Failed to check delegation:\", err)\n      throw new Error(\n        `Failed to check delegation: ${err instanceof Error ? err.message : String(err)}`\n      )\n    }\n\n    // Update state once with complete information\n    // Set status to READY if delegation exists, CONNECTED if not\n    // Clear any previous errors on successful connection\n    this.updateState({\n      status: hasDelegation ? DrawbridgeStatus.READY : DrawbridgeStatus.CONNECTED,\n      sessionClient,\n      userAddress,\n      sessionAddress: account.address,\n      isReady: hasDelegation,\n      error: null\n    })\n\n    console.log(\"[drawbridge] Session connection complete, isReady:\", hasDelegation)\n  }\n\n  // ===== Public API =====\n\n  /**\n   * Get available wallet connectors for UI display\n   *\n   * @returns Array of connector info (id, name, type)\n   */\n  getAvailableConnectors(): ConnectorInfo[] {\n    const connectors = walletGetAvailableConnectors(this.wagmiConfig)\n    return connectors.map(c => ({\n      id: c.id,\n      name: c.name,\n      type: c.type\n    }))\n  }\n\n  /**\n   * Connect to a wallet by connector ID\n   *\n   * This will:\n   * 1. Connect via wagmi\n   * 2. Account watcher will automatically handle drawbridge session creation\n   *\n   * @param connectorId Connector ID (from getAvailableConnectors())\n   * @throws If connector not found or connection fails\n   */\n  async connectWallet(connectorId: string): Promise<void> {\n    console.log(\"[drawbridge] Connecting to wallet:\", connectorId)\n\n    // Set status to CONNECTING\n    this.updateState({ status: DrawbridgeStatus.CONNECTING })\n\n    try {\n      await walletConnect(this.wagmiConfig, connectorId, this.config.chainId)\n    } catch (err) {\n      // If already connected, that's fine\n      if (err instanceof Error && err.name === \"ConnectorAlreadyConnectedError\") {\n        console.log(\"[drawbridge] Already connected\")\n        return\n      }\n      // Reset to DISCONNECTED on error\n      this.updateState({ status: DrawbridgeStatus.DISCONNECTED })\n      throw err\n    }\n\n    // Account watcher will handle the rest and set appropriate status\n  }\n\n  /**\n   * Disconnect wallet and clear session\n   *\n   * This will:\n   * 1. Disconnect via wagmi\n   * 2. Account watcher will automatically clear drawbridge state\n   */\n  async disconnectWallet(): Promise<void> {\n    console.log(\"[drawbridge] disconnectWallet() called\")\n    console.log(\"[drawbridge] Current state:\", this.state)\n    console.log(\"[drawbridge] Calling wagmi disconnect()...\")\n\n    try {\n      this.isDisconnecting = true\n      await walletDisconnect(this.wagmiConfig)\n      console.log(\"[drawbridge] Wallet disconnected\")\n    } catch (err) {\n      console.error(\"[drawbridge] Disconnect error:\", err)\n      throw err\n    } finally {\n      this.isDisconnecting = false\n    }\n\n    console.log(\"[drawbridge] Disconnect complete\")\n  }\n\n  /**\n   * Check if session is ready to use\n   *\n   * Queries the MUD World contract to check if delegation is registered\n   * between the user's account and the session account.\n   *\n   * @returns Delegation status\n   */\n  async checkPrerequisites(): Promise<PrerequisiteStatus> {\n    if (!this.state.sessionClient) {\n      return { hasDelegation: false, isReady: false }\n    }\n\n    const hasDelegation = await checkDelegation({\n      client: this.state.sessionClient,\n      worldAddress: this.config.worldAddress!,\n      userAddress: this.state.userAddress!,\n      sessionAddress: this.state.sessionAddress!\n    })\n\n    this.updateState({ isReady: hasDelegation })\n\n    return { hasDelegation, isReady: hasDelegation }\n  }\n\n  /**\n   * Setup session by registering delegation and deploying account\n   *\n   * This will:\n   * 1. Get current wallet client from wagmi\n   * 2. Register delegation in MUD World contract (user delegates to session)\n   * 3. Deploy session smart account if not already deployed\n   *\n   * User will need to sign a transaction (EOA) or user operation (smart account).\n   *\n   * @throws If not connected (call connectWallet() first)\n   */\n  async setupSession(onStatus?: (status: SetupSessionStatus) => void): Promise<void> {\n    if (this.config.skipSessionSetup) {\n      throw new Error(\n        \"Cannot setup session when skipSessionSetup is true. This drawbridge instance is in wallet-only mode.\"\n      )\n    }\n\n    if (!this.state.sessionClient) {\n      throw new Error(\"Not connected. Call connectWallet() first.\")\n    }\n\n    console.log(\"[drawbridge] Setting up session (registering delegation)...\")\n\n    // Set status to SETTING_UP_SESSION\n    this.updateState({ status: DrawbridgeStatus.SETTING_UP_SESSION })\n\n    // Get current wallet client from wagmi\n    const userClient = await getConnectorClient(this.wagmiConfig)\n\n    try {\n      await setupSession({\n        publicClient: userClient,\n        userClient,\n        sessionClient: this.state.sessionClient,\n        worldAddress: this.config.worldAddress!,\n        onStatus\n      })\n\n      // Session setup complete - set status to READY and clear any errors\n      this.updateState({ status: DrawbridgeStatus.READY, isReady: true, error: null })\n\n      console.log(\"[drawbridge] Session setup complete\")\n    } catch (err) {\n      // Reset to CONNECTED on error\n      this.updateState({ status: DrawbridgeStatus.CONNECTED })\n      throw err\n    }\n  }\n\n  /**\n   * Cleanup and destroy drawbridge instance\n   *\n   * This will:\n   * 1. Unwatch account changes\n   * 2. Clear session state (but NOT localStorage keys)\n   *\n   * Call this when unmounting your app.\n   */\n  destroy(): void {\n    console.log(\"[drawbridge] Destroying instance\")\n\n    // Cleanup account watcher\n    if (this.accountWatcherCleanup) {\n      this.accountWatcherCleanup()\n      this.accountWatcherCleanup = null\n    }\n\n    // Clear state\n    this.updateState({\n      status: DrawbridgeStatus.DISCONNECTED,\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false,\n      error: null\n    })\n  }\n\n  /**\n   * Clear stored session keys from localStorage\n   *\n   * This permanently removes the session private key for the current user.\n   * Next time connect() is called, a new session account will be created.\n   */\n  clearStorage(): void {\n    if (this.state.userAddress) {\n      sessionStorage.removeSigner(this.state.userAddress)\n    }\n  }\n\n  // ===== Convenience Getters =====\n\n  /** Get current session client (null if not connected) */\n  get sessionClient(): SessionClient | null {\n    return this.state.sessionClient\n  }\n\n  /** Get current user address (null if not connected) */\n  get userAddress(): Address | null {\n    return this.state.userAddress\n  }\n\n  /** Get current session account address (null if not connected) */\n  get sessionAddress(): Address | null {\n    return this.state.sessionAddress\n  }\n\n  /** Check if session is ready (has delegation) */\n  get isReady(): boolean {\n    return this.state.isReady\n  }\n\n  /** Get wagmi config (for advanced use cases like transactions) */\n  getWagmiConfig(): Config {\n    return this.wagmiConfig\n  }\n}\n"]}