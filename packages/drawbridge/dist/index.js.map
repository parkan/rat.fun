{"version":3,"sources":["../src/types/state.ts","../src/types/mud.ts","../src/types/config.ts","../src/logger.ts","../src/session/core/storage.ts","../src/session/core/signer.ts","../src/session/core/account.ts","../src/bundler/paymaster.ts","../src/bundler/client.ts","../src/bundler/logging.ts","../src/bundler/transport.ts","../src/session/core/callFromWithAlt.ts","../src/session/core/client.ts","../src/session/delegation/check.ts","../src/session/patterns/wallet-deployment.ts","../src/session/delegation/shared.ts","../src/session/delegation/smart-account.ts","../src/session/patterns/eip712-signing.ts","../src/session/patterns/call-with-signature.ts","../src/session/delegation/eoa.ts","../src/session/delegation/setup.ts","../src/wallet/config.ts","../src/wallet/watcher.ts","../src/wallet/connection.ts","../src/Drawbridge.ts"],"names":["DrawbridgeStatus","viem_createBundlerClient","DEFAULT_ETH_PRICE","viem_writeContract","mud_callFrom","getAction","sendUserOperation","waitForUserOperationReceipt","getRecord","worldSystemsConfig","waitForTransactionReceipt"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Drawbridge connection and setup status\n *\n * Provides a single source of truth for the current state of Drawbridge.\n * Transitions follow this flow:\n *\n * UNINITIALIZED → initialize() → DISCONNECTED\n *                                      ↓\n *                      connectWallet() ↓\n *                                      ↓\n *                                 CONNECTED\n *                                      ↓\n *                      setupSession()  ↓\n *                                      ↓\n *                             SETTING_UP_SESSION\n *                                      ↓\n *                                   READY\n *\n * Note: READY state can be reached directly from DISCONNECTED if reconnection succeeds.\n */\nexport enum DrawbridgeStatus {\n  /** Drawbridge not yet initialized - call initialize() */\n  UNINITIALIZED = \"uninitialized\",\n\n  /** Drawbridge initialized but no wallet connected */\n  DISCONNECTED = \"disconnected\",\n\n  /** Wallet connection in progress */\n  CONNECTING = \"connecting\",\n\n  /** Wallet connected, but session setup needed (delegation not registered) */\n  CONNECTED = \"connected\",\n\n  /** Session setup in progress (registering delegation) */\n  SETTING_UP_SESSION = \"setting_up_session\",\n\n  /** Fully ready - session client available and delegation registered */\n  READY = \"ready\",\n\n  /** An error occurred */\n  ERROR = \"error\"\n}\n","import { resourceToHex } from \"@latticexyz/common\"\nimport { parseAbi, ClientConfig } from \"viem\"\nimport worldConfig from \"@latticexyz/world/mud.config\"\n\n/**\n * Default viem client configuration\n * Polling interval for watching blockchain state and user operation receipts\n *\n * Note: This affects how often we poll for user operation receipts after sending.\n * Lower = faster confirmation detection but more RPC calls\n * Higher = slower confirmation detection but fewer RPC calls (better for rate limits)\n */\nexport const defaultClientConfig = {\n  pollingInterval: 2000 // Changed from 250ms to 2000ms to reduce rate limiting\n} as const satisfies Pick<ClientConfig, \"pollingInterval\">\n\n/**\n * MUD delegation control ID for \"unlimited\" delegation\n *\n * This is a resource ID that identifies the unlimited delegation control system.\n * When a user delegates to a session account with this ID, the session account\n * can call any system in the World on behalf of the user.\n *\n * Format: system resource with namespace=\"\" and name=\"unlimited\"\n */\nexport const unlimitedDelegationControlId = resourceToHex({\n  type: \"system\",\n  namespace: \"\",\n  name: \"unlimited\"\n})\n\n/**\n * MUD World table definitions from world config\n * Used to query World state (e.g., UserDelegationControl table)\n */\nexport const worldTables = worldConfig.namespaces.world.tables\n\n/**\n * Minimal World ABI for delegation registration\n * Full ABI is large, we only need this one function\n */\nexport const worldAbi = parseAbi([\n  \"function registerDelegation(address delegatee, bytes32 delegationControlId, bytes initCallData)\"\n])\n","/**\n * Deployment timeout and delay constants\n *\n * These values control timing for wallet and session deployment operations.\n * Adjust based on chain speed and network conditions.\n */\nexport const DEPLOYMENT_TIMEOUTS = {\n  /**\n   * Timeout for session account deployment (milliseconds)\n   *\n   * After this time, we give up waiting for the session account to deploy.\n   * Default: 30 seconds\n   *\n   * Increase for slower chains or congested networks.\n   */\n  SESSION_DEPLOYMENT: 30_000,\n\n  /**\n   * Delay after wallet deployment to allow bundler state synchronization (milliseconds)\n   *\n   * After deploying a counterfactual wallet, bundlers cache the account state\n   * and need time to refresh their internal state before accepting operations.\n   *\n   * Default: 2 seconds\n   *\n   * This prevents \"AA10\" errors on the next user operation.\n   * See: https://github.com/eth-infinitism/account-abstraction/discussions\n   */\n  BUNDLER_STATE_SYNC: 2_000\n} as const\n","/**\n * Drawbridge logger\n *\n * A simple conditional logger that can be toggled on/off via configuration.\n * All logging is disabled by default.\n */\n\nlet loggingEnabled = false\n\n/**\n * Set whether logging is enabled\n * Called during Drawbridge initialization\n */\nexport function setLoggingEnabled(enabled: boolean): void {\n  loggingEnabled = enabled\n}\n\n/**\n * Check if logging is enabled\n */\nexport function isLoggingEnabled(): boolean {\n  return loggingEnabled\n}\n\n/**\n * Logger with conditional output\n * Only logs when logging is enabled\n */\nexport const logger = {\n  log: (...args: unknown[]): void => {\n    if (loggingEnabled) {\n      console.log(...args)\n    }\n  },\n  warn: (...args: unknown[]): void => {\n    if (loggingEnabled) {\n      console.warn(...args)\n    }\n  },\n  error: (...args: unknown[]): void => {\n    // Errors are always logged regardless of logging setting\n    console.error(...args)\n  }\n}\n","import { Address, Hex } from \"viem\"\nimport { logger } from \"../../logger\"\n\ntype SessionStore = {\n  signers: Record<string, string> // lowercase address → private key\n}\n\n/**\n * Session key storage using localStorage\n *\n * Manages persistent session private keys for each user address.\n * Keys are stored in localStorage and survive page refreshes.\n *\n * Storage format: { signers: { \"0xabc...\": \"0x123...\" } }\n * Storage key: \"drawbridge:session-signers\"\n *\n * Migration: Automatically migrates from legacy \"entrykit:session-signers\" key\n * to maintain backwards compatibility.\n */\nexport class SessionStorage {\n  private cache: SessionStore\n  private readonly STORAGE_KEY = \"drawbridge:session-signers\"\n  private readonly LEGACY_STORAGE_KEY = \"entrykit:session-signers\"\n\n  constructor() {\n    this.cache = this.load()\n  }\n\n  /**\n   * Load session store from localStorage\n   *\n   * Attempts to load from new key first, then falls back to legacy key\n   * for backwards compatibility with existing installations.\n   */\n  private load(): SessionStore {\n    if (typeof localStorage === \"undefined\") {\n      return { signers: {} }\n    }\n\n    // Try new key first\n    let stored = localStorage.getItem(this.STORAGE_KEY)\n\n    // Fall back to legacy key for existing users\n    if (!stored) {\n      stored = localStorage.getItem(this.LEGACY_STORAGE_KEY)\n      if (stored) {\n        logger.log(\"[drawbridge] Migrating session storage from legacy key\")\n      }\n    }\n\n    if (!stored) {\n      return { signers: {} }\n    }\n\n    try {\n      const parsed = JSON.parse(stored)\n\n      // Validate structure\n      if (!parsed.signers || typeof parsed.signers !== \"object\") {\n        logger.warn(\"[drawbridge] Session storage corrupted - invalid structure, resetting\")\n        return { signers: {} }\n      }\n\n      return parsed\n    } catch (err) {\n      logger.error(\n        \"[drawbridge] Failed to parse session storage:\",\n        err instanceof Error ? err.message : String(err)\n      )\n      logger.warn(\"[drawbridge] Session storage will be reset\")\n      return { signers: {} }\n    }\n  }\n\n  /**\n   * Save session store to localStorage\n   *\n   * Saves to new key and removes legacy key to complete migration.\n   */\n  private save(): void {\n    if (typeof localStorage === \"undefined\") return\n\n    // Save to new key\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.cache))\n\n    // Remove legacy key if it exists (cleanup after migration)\n    if (localStorage.getItem(this.LEGACY_STORAGE_KEY)) {\n      localStorage.removeItem(this.LEGACY_STORAGE_KEY)\n      logger.log(\"[drawbridge] Removed legacy storage key after migration\")\n    }\n  }\n\n  /**\n   * Get session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @returns Private key if exists, undefined otherwise\n   */\n  getSigner(address: Address): Hex | undefined {\n    const key = address.toLowerCase()\n    return this.cache.signers[key] as Hex | undefined\n  }\n\n  /**\n   * Store session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @param privateKey Session private key to store\n   */\n  setSigner(address: Address, privateKey: Hex): void {\n    const key = address.toLowerCase()\n    this.cache.signers[key] = privateKey\n    this.save()\n  }\n\n  /**\n   * Remove session signer for a user address\n   *\n   * @param address User's wallet address\n   */\n  removeSigner(address: Address): void {\n    const key = address.toLowerCase()\n    delete this.cache.signers[key]\n    this.save()\n  }\n\n  /**\n   * Clear all session signers\n   */\n  clear(): void {\n    this.cache = { signers: {} }\n    this.save()\n  }\n}\n\n/**\n * Singleton session storage instance\n */\nexport const sessionStorage = new SessionStorage()\n","import { Address, Hex, isHex } from \"viem\"\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\"\nimport { sessionStorage } from \"./storage\"\n\n/**\n * Get or create session signer for a user address\n *\n * Session signers are persistent private keys stored in localStorage.\n * They're used as the owner of the session smart account.\n *\n * If no signer exists for this user:\n * - Attempts to migrate from old MUD AccountKit storage format\n * - Otherwise generates a fresh random private key\n * - Stores the key for future use\n *\n * @param userAddress User's wallet address\n * @returns LocalAccount (viem account from private key)\n */\nexport function getSessionSigner(userAddress: Address) {\n  let privateKey = sessionStorage.getSigner(userAddress)\n\n  if (!privateKey) {\n    // Attempt to migrate from legacy MUD AccountKit storage format\n    // This allows existing users to keep their session accounts\n    const deprecatedKey =\n      typeof localStorage !== \"undefined\"\n        ? localStorage\n            .getItem(`mud:appSigner:privateKey:${userAddress.toLowerCase()}`)\n            ?.replace(/^\"(.*)\"$/, \"$1\") // Remove JSON quotes if present\n        : null\n\n    // Use migrated key if valid, otherwise generate new random key\n    privateKey = (isHex(deprecatedKey) ? deprecatedKey : generatePrivateKey()) as Hex\n    sessionStorage.setSigner(userAddress, privateKey)\n  }\n\n  return privateKeyToAccount(privateKey)\n}\n","import { Address, LocalAccount } from \"viem\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { toSimpleSmartAccount } from \"permissionless/accounts\"\nimport { getSessionSigner } from \"./signer\"\nimport { PublicClient } from \"../../types\"\nimport { logger } from \"../../logger\"\n\nexport type GetSessionAccountReturnType = {\n  readonly account: SmartAccount\n  readonly signer: LocalAccount\n}\n\n/**\n * Create an ERC-4337 session smart account.\n *\n * @param publicClient - Public client for chain reads (used by toSimpleSmartAccount)\n * @param userAddress - The user's wallet address (used to derive session signer)\n */\nexport async function getSessionAccount({\n  publicClient,\n  userAddress\n}: {\n  publicClient: PublicClient\n  userAddress: Address\n}): Promise<GetSessionAccountReturnType> {\n  const signer = getSessionSigner(userAddress)\n\n  logger.log(\"[getSessionAccount] Creating session account:\", {\n    userAddress,\n    signerAddress: signer.address,\n    chainId: publicClient.chain?.id,\n    chainName: publicClient.chain?.name\n  })\n\n  try {\n    const account = await toSimpleSmartAccount({\n      client: publicClient,\n      owner: signer\n    })\n\n    logger.log(\"[getSessionAccount] Session account created:\", account.address)\n    return { account, signer }\n  } catch (error) {\n    logger.error(\"[getSessionAccount] Failed to create session account:\", {\n      error: error instanceof Error ? error.message : String(error),\n      userAddress,\n      signerAddress: signer.address,\n      chainId: publicClient.chain?.id\n    })\n    throw error\n  }\n}\n","import { Chain, Hex } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { logger } from \"../logger\"\n\n/**\n * Paymaster configuration\n *\n * Paymasters sponsor gas for user operations (ERC-4337).\n * Two types supported:\n *\n * - **simple**: Basic paymaster with just an address\n *   Returns paymaster address with empty data\n *\n * - **custom**: Advanced paymaster with client\n *   Uses provided PaymasterClient for dynamic sponsorship logic\n *   (e.g., Coinbase Paymaster, Pimlico, etc.)\n */\nexport type Paymaster =\n  | {\n      readonly type: \"simple\"\n      readonly address: Hex\n    }\n  | {\n      readonly type: \"custom\"\n      readonly address?: Hex\n      readonly paymasterClient: PaymasterClient\n    }\n\n/**\n * Get paymaster configuration for a chain\n *\n * Priority:\n * 1. Use paymasterOverride if provided (custom paymaster client)\n * 2. Check chain.contracts.paymaster for simple paymaster address\n * 3. Return undefined if no paymaster configured (user pays own gas)\n *\n * @param chain Chain configuration\n * @param paymasterOverride Optional custom paymaster client\n * @returns Paymaster config or undefined\n */\nexport function getPaymaster(\n  chain: Chain,\n  paymasterOverride?: PaymasterClient\n): Paymaster | undefined {\n  const contracts = chain.contracts ?? {}\n\n  // Use custom paymaster if provided (e.g., Coinbase Paymaster)\n  if (paymasterOverride) {\n    logger.log(\n      `[Drawbridge/Paymaster] Using custom paymaster client for chain ${chain.name} (${chain.id})`\n    )\n    return {\n      type: \"custom\",\n      paymasterClient: paymasterOverride\n    }\n  }\n\n  // Check for simple paymaster in chain config\n  if (\"paymaster\" in contracts && contracts.paymaster != null) {\n    if (\"address\" in contracts.paymaster) {\n      logger.log(\n        `[Drawbridge/Paymaster] Using simple paymaster at ${contracts.paymaster.address} for chain ${chain.name} (${chain.id})`\n      )\n      return {\n        type: \"simple\",\n        address: contracts.paymaster.address\n      }\n    }\n  }\n\n  // No paymaster configured - user pays own gas\n  logger.log(\n    `[Drawbridge/Paymaster] No paymaster configured for chain ${chain.name} (${chain.id}) - user will pay gas`\n  )\n  return undefined\n}\n","import { Transport, Chain, Client, RpcSchema, EstimateFeesPerGasReturnType } from \"viem\"\nimport {\n  BundlerClient,\n  BundlerClientConfig,\n  SmartAccount,\n  PaymasterClient,\n  createBundlerClient as viem_createBundlerClient\n} from \"viem/account-abstraction\"\nimport { defaultClientConfig } from \"../types\"\nimport { getPaymaster } from \"./paymaster\"\nimport { logger } from \"../logger\"\n\n/**\n * Create a bundler client for submitting ERC-4337 user operations\n *\n * A bundler client is a specialized viem client that:\n * - Submits user operations to the bundler RPC\n * - Handles gas estimation for user operations\n * - Integrates paymaster for gas sponsorship\n * - Manages smart account interactions\n *\n * This function wraps viem's createBundlerClient with:\n * - Automatic paymaster configuration from chain or override\n * - Custom fee estimation for Anvil (local dev)\n * - Default polling interval\n *\n * @param config Bundler client configuration\n * @returns Configured bundler client\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain = Chain,\n  account extends SmartAccount = SmartAccount,\n  client extends Client = Client,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  config: BundlerClientConfig<transport, chain, account, client, rpcSchema>\n): BundlerClient<transport, chain, account, client, rpcSchema> {\n  const client = config.client\n  if (!client) throw new Error(\"No `client` provided to `createBundlerClient`.\")\n\n  const chain = config.chain ?? client.chain\n  const paymaster = chain\n    ? getPaymaster(chain, config.paymaster as PaymasterClient | undefined)\n    : undefined\n\n  if (paymaster) {\n    logger.log(\n      `[Drawbridge/BundlerClient] Bundler client configured with ${paymaster.type} paymaster`\n    )\n  } else {\n    logger.log(`[Drawbridge/BundlerClient] Bundler client configured without paymaster`)\n  }\n\n  return viem_createBundlerClient({\n    ...defaultClientConfig,\n    // Configure paymaster for gas sponsorship\n    paymaster: paymaster\n      ? paymaster.type === \"custom\"\n        ? paymaster.paymasterClient // Use custom paymaster client (e.g., Coinbase)\n        : {\n            // Simple paymaster - just return address with empty data\n            getPaymasterData: async () => ({\n              paymaster: paymaster.address,\n              paymasterData: \"0x\"\n            })\n          }\n      : undefined,\n    ...config\n  })\n}\n","/**\n * Logging for user operation gas and cost tracking\n */\n\nimport { formatGwei, formatEther } from \"viem\"\nimport { logger } from \"../logger\"\n\nconst DEFAULT_ETH_PRICE = 2800\n\n/**\n * Log user operation gas estimates and USD cost\n *\n * @param userOp User operation with gas and fee parameters\n * @param ethPriceUSD Current ETH price in USD (defaults to $2,800)\n */\nexport function logUserOperationCost(\n  userOp: {\n    callGasLimit: string | bigint\n    verificationGasLimit: string | bigint\n    preVerificationGas: string | bigint\n    paymasterVerificationGasLimit?: string | bigint\n    paymasterPostOpGasLimit?: string | bigint\n    maxFeePerGas: string | bigint\n    maxPriorityFeePerGas: string | bigint\n  },\n  ethPriceUSD?: number\n): void {\n  const ETH_PRICE = ethPriceUSD || DEFAULT_ETH_PRICE\n  const callGas = BigInt(userOp.callGasLimit)\n  const verificationGas = BigInt(userOp.verificationGasLimit)\n  const preVerificationGas = BigInt(userOp.preVerificationGas)\n  const paymasterVerificationGas = BigInt(userOp.paymasterVerificationGasLimit || 0)\n  const paymasterPostOpGas = BigInt(userOp.paymasterPostOpGasLimit || 0)\n  const maxFeePerGas = BigInt(userOp.maxFeePerGas)\n  const maxPriorityFeePerGas = BigInt(userOp.maxPriorityFeePerGas)\n\n  const totalGas =\n    callGas + verificationGas + preVerificationGas + paymasterVerificationGas + paymasterPostOpGas\n\n  // Calculate max cost in ETH and USD\n  const maxCostWei = totalGas * maxFeePerGas\n  const maxCostETH = formatEther(maxCostWei)\n  const maxCostUSD = Number(maxCostETH) * ETH_PRICE\n\n  logger.log(\"┌─ User Operation Gas & Cost ────────────────────────\")\n  logger.log(\"│\")\n  logger.log(\"│ Gas Estimates:\")\n  logger.log(\"│   callGasLimit:                \", callGas.toString().padStart(7), \"gas\")\n  logger.log(\"│   verificationGasLimit:        \", verificationGas.toString().padStart(7), \"gas\")\n  logger.log(\"│   preVerificationGas:          \", preVerificationGas.toString().padStart(7), \"gas\")\n  if (paymasterVerificationGas > 0n) {\n    logger.log(\n      \"│   paymasterVerificationGasLimit:\",\n      paymasterVerificationGas.toString().padStart(7),\n      \"gas\"\n    )\n  }\n  if (paymasterPostOpGas > 0n) {\n    logger.log(\n      \"│   paymasterPostOpGasLimit:     \",\n      paymasterPostOpGas.toString().padStart(7),\n      \"gas\"\n    )\n  }\n  logger.log(\"│   ─────────────────────────────────────────────\")\n  logger.log(\"│   Total gas:                   \", totalGas.toString().padStart(7), \"gas\")\n  logger.log(\"│\")\n  logger.log(\"│ Fee Parameters:\")\n  logger.log(\"│   maxFeePerGas:                \", formatGwei(maxFeePerGas), \"gwei\")\n  logger.log(\"│   maxPriorityFeePerGas:        \", formatGwei(maxPriorityFeePerGas), \"gwei\")\n  logger.log(\"│\")\n  logger.log(\"│ Estimated Max Cost:\")\n  logger.log(\"│   ETH:  \", maxCostETH, \"ETH\")\n  logger.log(\"│   USD:  $\" + maxCostUSD.toFixed(2), \"(at $\" + ETH_PRICE + \" ETH)\")\n  logger.log(\"│\")\n  logger.log(\"└────────────────────────────────────────────────────\")\n}\n\n/**\n * Log when fee cap is applied due to budget constraints\n */\nexport function logFeeCapApplied(data: {\n  totalGas: bigint\n  originalMaxFee: bigint\n  originalPriorityFee: bigint\n  cappedMaxFee: bigint\n  cappedPriorityFee: bigint\n  maxBudgetUSD: number\n  ethPrice: number\n}): void {\n  const originalCost = (Number(data.totalGas) * Number(formatGwei(data.originalMaxFee))) / 1e9\n  const cappedCost = (Number(data.totalGas) * Number(formatGwei(data.cappedMaxFee))) / 1e9\n  const originalCostUSD = originalCost * data.ethPrice\n  const cappedCostUSD = cappedCost * data.ethPrice\n\n  const priorityWasReduced = data.cappedPriorityFee < data.originalPriorityFee\n\n  logger.log(\"┌─ ⚠️  GAS PRICE SPIKE - FEE CAP APPLIED ────────────\")\n  logger.log(\"│\")\n  logger.log(\"│ 🛡️  Budget Protection: Capping fees to stay under $\" + data.maxBudgetUSD)\n  logger.log(\"│\")\n  logger.log(\"│ This operation:\")\n  logger.log(\"│   Total gas:            \", data.totalGas.toString(), \"gas\")\n  logger.log(\"│\")\n  logger.log(\"│ Network fees would cost:\")\n  logger.log(\"│   maxFeePerGas:         \", formatGwei(data.originalMaxFee), \"gwei\")\n  logger.log(\"│   maxPriorityFeePerGas: \", formatGwei(data.originalPriorityFee), \"gwei\")\n  logger.log(\"│   Estimated cost:       \", originalCost.toFixed(8), \"ETH\")\n  logger.log(\"│   USD cost:              $\" + originalCostUSD.toFixed(2), \"← OVER BUDGET!\")\n  logger.log(\"│\")\n  logger.log(\"│ Capped to:\")\n  logger.log(\"│   maxFeePerGas:         \", formatGwei(data.cappedMaxFee), \"gwei\", \"← CAPPED\")\n  if (priorityWasReduced) {\n    logger.log(\n      \"│   maxPriorityFeePerGas: \",\n      formatGwei(data.cappedPriorityFee),\n      \"gwei\",\n      \"← REDUCED (EIP-1559)\"\n    )\n  } else {\n    logger.log(\"│   maxPriorityFeePerGas: \", formatGwei(data.cappedPriorityFee), \"gwei\")\n  }\n  logger.log(\"│   Estimated cost:       \", cappedCost.toFixed(8), \"ETH\")\n  logger.log(\"│   USD cost:              $\" + cappedCostUSD.toFixed(2), \"✅\")\n  logger.log(\"│\")\n  logger.log(\n    \"│ ⏳ Transaction will wait in mempool until gas drops below\",\n    formatGwei(data.cappedMaxFee),\n    \"gwei\"\n  )\n  logger.log(\"│\")\n  logger.log(\"└────────────────────────────────────────────────────\")\n}\n","import { Chain, http, parseEther } from \"viem\"\nimport { logUserOperationCost, logFeeCapApplied } from \"./logging\"\nimport { logger } from \"../logger\"\n\n/**\n * Retry configuration for rate limiting\n */\nconst RETRY_CONFIG = {\n  maxRetries: 4, // Total of 5 attempts (1 initial + 4 retries)\n  baseDelayMs: 1000, // Start with 1 second\n  maxDelayMs: 16000 // Cap at 16 seconds\n} as const\n\n/**\n * Sleep utility for retry delays\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\n/**\n * Calculate exponential backoff delay\n * @param attempt Retry attempt number (0-based)\n * @returns Delay in milliseconds\n */\nfunction getRetryDelay(attempt: number): number {\n  const delay = RETRY_CONFIG.baseDelayMs * Math.pow(2, attempt)\n  return Math.min(delay, RETRY_CONFIG.maxDelayMs)\n}\n\n/**\n * Check if response contains a paymaster cost rejection\n */\nasync function isPaymasterCostRejection(response: Response): Promise<boolean> {\n  if (response.status !== 200) return false\n\n  try {\n    const clonedResponse = response.clone()\n    const body = await clonedResponse.json()\n\n    // Check for Coinbase paymaster cost rejection\n    // Error code -32002 with \"max sponsorship cost\" message\n    if (body?.error?.code === -32002) {\n      const details = body.error.details || body.error.message || \"\"\n      return details.toLowerCase().includes(\"max sponsorship cost\")\n    }\n\n    return false\n  } catch {\n    return false\n  }\n}\n\n/**\n * Fetch with exponential backoff retry logic\n * Automatically retries on:\n * - 429 HTTP rate limit errors\n * - Network errors\n * - Paymaster cost rejections (RPC error -32002)\n */\nasync function fetchWithRetry(\n  input: string | URL | Request,\n  init?: RequestInit\n): Promise<Response> {\n  let lastError: Error | null = null\n\n  for (let attempt = 0; attempt <= RETRY_CONFIG.maxRetries; attempt++) {\n    try {\n      const response = await fetch(input, init)\n\n      // Check for HTTP rate limit error (429)\n      if (response.status === 429) {\n        const isLastAttempt = attempt === RETRY_CONFIG.maxRetries\n\n        if (isLastAttempt) {\n          let errorMessage = \"Rate limit exceeded\"\n          try {\n            const errorBody = await response.json()\n            if (errorBody?.errorMessage) {\n              errorMessage = errorBody.errorMessage\n            }\n          } catch {\n            // Ignore JSON parse errors\n          }\n\n          throw new Error(\n            `${errorMessage}. All ${RETRY_CONFIG.maxRetries + 1} retry attempts exhausted.`\n          )\n        }\n\n        const delayMs = getRetryDelay(attempt)\n        logger.warn(\n          `[Drawbridge/Transport] Rate limit hit (429). Retrying in ${delayMs}ms (attempt ${attempt + 1}/${RETRY_CONFIG.maxRetries + 1})...`\n        )\n\n        await sleep(delayMs)\n        continue\n      }\n\n      // Check for paymaster cost rejection (RPC error in response body)\n      if (await isPaymasterCostRejection(response)) {\n        const isLastAttempt = attempt === RETRY_CONFIG.maxRetries\n\n        if (isLastAttempt) {\n          // Don't throw - let the error propagate naturally\n          // This allows the original error message to reach the user\n          return response\n        }\n\n        const delayMs = getRetryDelay(attempt)\n        logger.warn(\n          `[Drawbridge/Transport] Paymaster cost limit exceeded. Retrying in ${delayMs}ms (attempt ${attempt + 1}/${RETRY_CONFIG.maxRetries + 1})...`\n        )\n\n        await sleep(delayMs)\n        continue\n      }\n\n      // Success or non-retryable error\n      return response\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error))\n\n      // If it's a network error on the last attempt, throw it\n      if (attempt === RETRY_CONFIG.maxRetries) {\n        throw lastError\n      }\n\n      // For network errors, also apply exponential backoff\n      const delayMs = getRetryDelay(attempt)\n      logger.warn(\n        `[Drawbridge/Transport] Network error. Retrying in ${delayMs}ms (attempt ${attempt + 1}/${RETRY_CONFIG.maxRetries + 1})...`,\n        error\n      )\n      await sleep(delayMs)\n    }\n  }\n\n  // This should never be reached, but TypeScript needs it\n  throw lastError || new Error(\"Unexpected error in fetchWithRetry\")\n}\n\n/**\n * Get bundler RPC transport for a chain\n *\n * Bundlers are special RPC endpoints that handle ERC-4337 user operations.\n * They submit user operations to the EntryPoint contract and handle gas sponsorship.\n *\n * For Base chains, this transport applies dynamic fee capping to keep costs under\n * the Coinbase paymaster's $1 limit.\n *\n * The bundler URL must be configured in the chain's rpcUrls.bundler.http array.\n *\n * @param chain Chain configuration with bundler RPC URL\n * @param ethPriceUSD Current ETH price in USD (used for fee cap calculation)\n * @returns HTTP transport for the bundler\n * @throws If chain doesn't have a bundler RPC URL configured\n */\nexport function getBundlerTransport(chain: Chain, ethPriceUSD?: number) {\n  const bundlerHttpUrl = chain.rpcUrls.bundler?.http[0]\n\n  if (bundlerHttpUrl) {\n    // Apply fee capping only for Base chains (Coinbase paymaster budget protection)\n    const shouldApplyFeeCap = chain.id === 8453 || chain.id === 84532\n\n    return http(bundlerHttpUrl, {\n      // Use custom fetch with retry logic\n      fetchFn: fetchWithRetry,\n      onFetchRequest: async request => {\n        try {\n          if (request.body) {\n            const clonedRequest = request.clone()\n            const text = await clonedRequest.text()\n            const body = JSON.parse(text)\n\n            // Apply fee cap to any method that includes a user operation\n            // This includes both pm_getPaymasterData (paymaster call) and eth_sendUserOperation (actual send)\n            // Fee capping MUST happen before paymaster sees the operation to stay under $1 limit\n            if (\n              body?.method === \"pm_getPaymasterData\" ||\n              body?.method === \"eth_sendUserOperation\" ||\n              body?.method === \"eth_estimateUserOperationGas\"\n            ) {\n              const userOp = body?.params?.[0]\n              if (userOp && shouldApplyFeeCap) {\n                applyFeeCap(userOp, ethPriceUSD)\n              }\n\n              // Log costs for send operations\n              if (body?.method === \"eth_sendUserOperation\" && userOp) {\n                logUserOperationCost(userOp, ethPriceUSD)\n              }\n            }\n          }\n        } catch (e) {\n          // Silently ignore parsing errors\n        }\n      }\n    })\n  }\n\n  throw new Error(`Chain ${chain.id} config did not include a bundler RPC URL.`)\n}\n\n/**\n * Apply dynamic fee cap to user operation to stay under $0.90\n *\n * Budget protection for Coinbase paymaster's $1 limit:\n * - Calculates max fee based on actual total gas\n * - Caps maxFeePerGas to keep cost under $0.90 (10% safety margin)\n * - Also caps maxPriorityFeePerGas if needed (EIP-1559 compliance)\n * - Modifies userOp in-place\n *\n * @param userOp User operation to modify\n * @param ethPriceUSD Current ETH price in USD (adds $500 margin for safety)\n */\nfunction applyFeeCap(userOp: any, ethPriceUSD?: number): void {\n  // Budget constraints\n  const MAX_COST_USD = 0.9 // $0.90 (10% margin under $1 paymaster limit)\n  const DEFAULT_ETH_PRICE = 3000\n  const PRICE_MARGIN = 500 // Add $500 margin for safety\n  const ETH_PRICE_USD = (ethPriceUSD || DEFAULT_ETH_PRICE) + PRICE_MARGIN\n\n  // Calculate total gas for this specific operation\n  const totalGas =\n    BigInt(userOp.callGasLimit || 0) +\n    BigInt(userOp.verificationGasLimit || 0) +\n    BigInt(userOp.preVerificationGas || 0) +\n    BigInt(userOp.paymasterVerificationGasLimit || 0) +\n    BigInt(userOp.paymasterPostOpGasLimit || 0)\n\n  // Calculate maximum fee per gas to stay under budget\n  // Formula: maxFeePerGas = ($0.90 / $3,500) / totalGas\n  const maxBudgetETH = parseEther((MAX_COST_USD / ETH_PRICE_USD).toString())\n  const maxFeePerGasCap = maxBudgetETH / totalGas\n\n  const originalMaxFee = BigInt(userOp.maxFeePerGas)\n  const originalPriorityFee = BigInt(userOp.maxPriorityFeePerGas)\n\n  // Track if we applied any caps for logging\n  let maxFeeWasCapped = false\n  let cappedMaxFee = originalMaxFee\n  let cappedPriorityFee = originalPriorityFee\n\n  // Apply cap if network's maxFeePerGas would exceed budget\n  if (originalMaxFee > maxFeePerGasCap) {\n    userOp.maxFeePerGas = \"0x\" + maxFeePerGasCap.toString(16)\n    cappedMaxFee = maxFeePerGasCap\n    maxFeeWasCapped = true\n  }\n\n  // ALWAYS enforce EIP-1559 constraint: maxPriorityFeePerGas must be <= maxFeePerGas\n  // This must run independently of whether maxFee was capped above\n  const currentMaxFee = BigInt(userOp.maxFeePerGas)\n  if (originalPriorityFee > currentMaxFee) {\n    userOp.maxPriorityFeePerGas = \"0x\" + currentMaxFee.toString(16)\n    cappedPriorityFee = currentMaxFee\n  }\n\n  // Log if any capping was applied\n  if (maxFeeWasCapped || cappedPriorityFee !== originalPriorityFee) {\n    logFeeCapApplied({\n      totalGas,\n      originalMaxFee,\n      originalPriorityFee,\n      cappedMaxFee,\n      cappedPriorityFee,\n      maxBudgetUSD: MAX_COST_USD,\n      ethPrice: ETH_PRICE_USD\n    })\n  }\n}\n","import type { Transport, Chain, Account, Hex, WalletActions, Client } from \"viem\"\nimport { getAction } from \"viem/utils\"\nimport { writeContract as viem_writeContract } from \"viem/actions\"\n\nimport { callFrom as mud_callFrom } from \"@latticexyz/world/internal\"\n\ntype SystemFunction = { systemId: Hex; systemFunctionSelector: Hex }\n\ntype CallFromParameters = {\n  worldAddress: Hex\n  delegatorAddress: Hex\n  worldFunctionToSystemFunction?: (worldFunctionSelector: Hex) => Promise<SystemFunction>\n  publicClient?: Client\n}\n\n// Different from MUD's callFrom only in that it reconginizes `callWithSignatureAlt` as well as `callWithSignature`\nexport function callFromWithAlt(\n  params: CallFromParameters\n): <chain extends Chain, account extends Account | undefined>(\n  client: Client<Transport, chain, account>\n) => Pick<WalletActions<chain, account>, \"writeContract\"> {\n  return client => ({\n    async writeContract(writeArgs) {\n      const _writeContract = getAction(client, viem_writeContract, \"writeContract\")\n\n      // Skip for alternative callWithSignature\n      if (writeArgs.functionName === \"callWithSignatureAlt\") {\n        return _writeContract(writeArgs)\n      }\n\n      // Fall back to MUD's callFrom for other functions\n      return mud_callFrom(params)(client).writeContract(writeArgs)\n    }\n  })\n}\n","import { Address, LocalAccount } from \"viem\"\nimport { smartAccountActions } from \"permissionless\"\nimport { sendUserOperationFrom } from \"@latticexyz/world/internal\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { createBundlerClient } from \"../../bundler/client\"\nimport { SessionClient, PublicClient } from \"../../types\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { getBundlerTransport } from \"../../bundler/transport\"\nimport { logger } from \"../../logger\"\nimport { callFromWithAlt } from \"./callFromWithAlt\"\n\n/**\n * Create session client with MUD World extensions\n *\n * Takes a standard ERC-4337 smart account and extends it with MUD-specific functionality:\n *\n * 1. **smartAccountActions** - Standard AA operations (sendUserOperation, etc.)\n * 2. **callFrom** - Routes writeContract calls through World.callFrom()\n *    - Automatically adds delegator context\n *    - World validates delegation before executing\n * 3. **sendUserOperationFrom** - Routes user operations through World\n * 4. **Context properties** - Adds userAddress, worldAddress, internal_signer\n *\n * The resulting SessionClient can call World systems on behalf of the user,\n * as long as delegation is registered.\n *\n * @param params Session client parameters\n * @returns SessionClient with MUD World extensions\n */\nexport async function getSessionClient({\n  publicClient,\n  userAddress,\n  sessionAccount,\n  sessionSigner,\n  worldAddress,\n  paymasterOverride,\n  ethPriceUSD\n}: {\n  /** Public client for read operations (used by MUD callFrom/sendUserOperationFrom extensions) */\n  publicClient: PublicClient\n  userAddress: Address\n  sessionAccount: SmartAccount\n  sessionSigner: LocalAccount\n  worldAddress: Address\n  paymasterOverride?: PaymasterClient\n  ethPriceUSD?: number\n}): Promise<SessionClient> {\n  const chain = publicClient.chain\n  if (!chain) {\n    throw new Error(\"Public client had no associated chain.\")\n  }\n\n  if (paymasterOverride) {\n    logger.log(`[Drawbridge/SessionClient] Creating session client with paymaster override`)\n  }\n\n  // Create bundler client for submitting user operations\n  const bundlerClient = createBundlerClient({\n    transport: getBundlerTransport(chain, ethPriceUSD),\n    client: publicClient,\n    account: sessionAccount,\n    paymaster: paymasterOverride\n  })\n\n  // Extend with standard ERC-4337 smart account actions\n  const sessionClient = bundlerClient\n    .extend(smartAccountActions)\n    // Extend with MUD World delegation routing\n    // This intercepts writeContract calls and routes them through World.callFrom()\n    .extend(\n      callFromWithAlt({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient\n      })\n    )\n    // Extend with MUD World user operation routing\n    .extend(\n      sendUserOperationFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient\n      })\n    )\n    // Add context properties for reference\n    .extend(() => ({ userAddress, worldAddress, internal_signer: sessionSigner }))\n\n  return sessionClient\n}\n","import { Address, Client } from \"viem\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport { unlimitedDelegationControlId, worldTables, PublicClient } from \"../../types\"\n\nexport type CheckDelegationParams = {\n  /** Public client for reading blockchain state */\n  client: Client | PublicClient\n  worldAddress: Address\n  userAddress: Address\n  sessionAddress: Address\n  blockTag?: \"pending\" | \"latest\"\n}\n\n/**\n * Check if delegation exists in MUD World contract\n *\n * MUD World stores delegations in the UserDelegationControl table.\n * A delegation allows the session account (delegatee) to call World systems\n * on behalf of the user account (delegator).\n *\n * This function queries that table and checks if \"unlimited\" delegation exists,\n * which grants the session account full access to all systems.\n *\n * @param params Delegation check parameters\n * @returns true if unlimited delegation is registered, false otherwise\n */\nexport async function checkDelegation({\n  client,\n  worldAddress,\n  userAddress,\n  sessionAddress,\n  blockTag = \"pending\"\n}: CheckDelegationParams): Promise<boolean> {\n  // Query MUD Store table: UserDelegationControl[delegator][delegatee]\n  const record = await getRecord(client, {\n    address: worldAddress,\n    table: worldTables.UserDelegationControl,\n    key: { delegator: userAddress, delegatee: sessionAddress },\n    blockTag\n  })\n\n  // Check if the delegation type is \"unlimited\" (full system access)\n  return record.delegationControlId === unlimitedDelegationControlId\n}\n","import { Address, Client } from \"viem\"\nimport { getCode, sendTransaction, waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { DEPLOYMENT_TIMEOUTS } from \"../../types\"\nimport { logger } from \"../../logger\"\n\n/**\n * Smart wallet deployment utilities\n *\n * Handles counterfactual smart wallets (e.g., Coinbase Smart Wallet) that use\n * CREATE2 and exist at a deterministic address before deployment.\n */\n\n/**\n * Check if an error indicates a wallet is already deployed\n *\n * ERC-4337 bundlers and smart wallets return specific error codes when\n * attempting to deploy an already-deployed wallet:\n * - AA10: Account already deployed (ERC-4337 bundler error code)\n * - \"already constructed\": Some wallet implementations\n * - \"already deployed\": Generic message from some bundlers\n * - \"is an existing contract, but initCode is nonempty\": Bundler precheck error for deployed accounts with factory data\n *\n * @param errorMessage Error message to check\n * @returns True if error indicates wallet is already deployed\n */\nexport function isAlreadyDeployedError(errorMessage: string): boolean {\n  return (\n    errorMessage.includes(\"AA10\") ||\n    errorMessage.includes(\"already constructed\") ||\n    errorMessage.includes(\"already deployed\") ||\n    errorMessage.includes(\"is an existing contract, but initCode is nonempty\")\n  )\n}\n\n/**\n * Check if a smart wallet is deployed on-chain\n *\n * @param client Client to use for checking\n * @param address Wallet address to check\n * @returns True if deployed, false otherwise\n */\nexport async function isWalletDeployed(client: Client, address: Address): Promise<boolean> {\n  const code = await getAction(\n    client,\n    getCode,\n    \"getCode\"\n  )({\n    address\n  })\n\n  return code !== undefined && code !== \"0x\"\n}\n\n/**\n * Deploy a smart wallet using a factory contract\n *\n * This handles the deployment of counterfactual smart wallets. The wallet address\n * already exists (can receive funds) but needs on-chain deployment before it can\n * validate signatures or execute transactions.\n *\n * @param client Client to use for deployment transaction (usually session client with paymaster)\n * @param factoryAddress Factory contract address that can deploy the wallet\n * @param factoryCalldata Deployment calldata for the factory\n */\nexport async function deployWallet(\n  client: Client,\n  factoryAddress: Address,\n  factoryCalldata: Address\n): Promise<void> {\n  if (!client.account) {\n    throw new Error(\"Client must have an account to deploy wallet\")\n  }\n\n  try {\n    const txHash = await getAction(\n      client,\n      sendTransaction,\n      \"sendTransaction\"\n    )({\n      account: client.account,\n      chain: client.chain,\n      to: factoryAddress,\n      data: factoryCalldata\n    })\n\n    // Wait for deployment confirmation\n    await getAction(\n      client,\n      waitForTransactionReceipt,\n      \"waitForTransactionReceipt\"\n    )({\n      hash: txHash\n    })\n\n    // Add delay for bundler/paymaster state to update\n    // After deployment, bundlers cache account state and need time to refresh\n    await new Promise(resolve => setTimeout(resolve, DEPLOYMENT_TIMEOUTS.BUNDLER_STATE_SYNC))\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n\n    // If already deployed, that's fine - not an error\n    if (isAlreadyDeployedError(errorMessage)) {\n      logger.log(\"[drawbridge] Wallet already deployed, continuing\")\n      return\n    }\n\n    throw new Error(`Failed to deploy smart wallet: ${errorMessage}`)\n  }\n}\n","import { zeroAddress, Hex, Address } from \"viem\"\nimport {\n  sendUserOperation,\n  waitForUserOperationReceipt,\n  SmartAccount,\n  UserOperationReceipt\n} from \"viem/account-abstraction\"\nimport { getAction } from \"viem/utils\"\nimport { SessionClient, DEPLOYMENT_TIMEOUTS } from \"../../types\"\nimport { isAlreadyDeployedError } from \"../patterns/wallet-deployment\"\nimport { logger } from \"../../logger\"\n\n/**\n * Smart account with optional factory properties (internal use only)\n * Some smart account implementations add these properties dynamically\n */\nexport type SmartAccountWithFactory = SmartAccount & {\n  factory?: Address\n  factoryData?: Hex\n}\n\n/**\n * Clear factory and factoryData properties from a smart account\n *\n * After deploying a counterfactual smart wallet, the factory properties should be\n * removed to prevent the bundler from trying to deploy again on subsequent operations.\n *\n * This function tries multiple strategies because some account implementations\n * make these properties read-only:\n * 1. Direct delete + assignment\n * 2. Object.defineProperty (for read-only properties)\n *\n * @param account Smart account to clear factory data from\n */\nexport function clearFactoryData(account: SmartAccountWithFactory): void {\n  try {\n    // Try direct deletion first\n    delete account.factory\n    delete account.factoryData\n    account.factory = undefined\n    account.factoryData = undefined\n\n    logger.log(\"[drawbridge] Factory data cleared:\", {\n      stillHasFactory: !!account.factory,\n      stillHasFactoryData: !!account.factoryData\n    })\n  } catch (err) {\n    // Fall back to Object.defineProperty for read-only properties\n    logger.warn(\"[drawbridge] Direct deletion failed, trying Object.defineProperty\")\n\n    try {\n      Object.defineProperty(account, \"factory\", {\n        value: undefined,\n        writable: true,\n        configurable: true\n      })\n      Object.defineProperty(account, \"factoryData\", {\n        value: undefined,\n        writable: true,\n        configurable: true\n      })\n\n      logger.log(\"[drawbridge] Factory data cleared via defineProperty\")\n    } catch (fallbackErr) {\n      logger.error(\"[drawbridge] Could not remove factory (readonly property)\")\n    }\n  }\n}\n\n/**\n * Setup session status updates for progress tracking\n */\nexport type SetupSessionStatus =\n  | { type: \"checking_wallet\"; message: string }\n  | { type: \"deploying_wallet\"; message: string }\n  | { type: \"wallet_deployed\"; message: string }\n  | { type: \"registering_delegation\"; message: string }\n  | { type: \"deploying_session\"; message: string }\n  | { type: \"complete\"; message: string }\n  | { type: \"error\"; message: string; error?: Error }\n\n/**\n * Common parameters for session setup (both EOA and Smart Account)\n */\nexport type SetupSessionBaseParams = {\n  /** Session smart account client with MUD extensions */\n  sessionClient: SessionClient\n  /** MUD World contract address */\n  worldAddress: Hex\n  /** Progress callback for status updates */\n  onStatus?: (status: SetupSessionStatus) => void\n}\n\n/**\n * Deploy session account if not already deployed\n *\n * This function is shared by both EOA and Smart Account setup flows.\n * It deploys the session account (ERC-4337 smart account) by sending\n * an empty user operation.\n *\n * @param sessionClient Session smart account client\n * @param onStatus Optional status callback\n */\nexport async function deploySessionAccount(\n  sessionClient: SessionClient,\n  onStatus?: (status: SetupSessionStatus) => void\n): Promise<void> {\n  const sessionDeployed = await sessionClient.account.isDeployed?.()\n  logger.log(\"[drawbridge] Session account deployed:\", sessionDeployed)\n\n  if (sessionDeployed) {\n    logger.log(\"[drawbridge] Session account already deployed\")\n    return\n  }\n\n  onStatus?.({ type: \"deploying_session\", message: \"Finalizing session setup...\" })\n\n  try {\n    const hash = await getAction(\n      sessionClient,\n      sendUserOperation,\n      \"sendUserOperation\"\n    )({\n      calls: [{ to: zeroAddress }]\n    })\n\n    logger.log(\"[drawbridge] Session deploy tx:\", hash)\n\n    // Add timeout\n    const receiptPromise = getAction(\n      sessionClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n\n    const timeoutPromise = new Promise((_, reject) =>\n      setTimeout(\n        () =>\n          reject(\n            new Error(\n              `Session deployment timeout after ${DEPLOYMENT_TIMEOUTS.SESSION_DEPLOYMENT}ms`\n            )\n          ),\n        DEPLOYMENT_TIMEOUTS.SESSION_DEPLOYMENT\n      )\n    )\n\n    const receipt = (await Promise.race([receiptPromise, timeoutPromise])) as UserOperationReceipt\n\n    if (!receipt.success) {\n      throw new Error(\"Failed to deploy session account\")\n    }\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error)\n    logger.error(\"[drawbridge] Session deployment error:\", errorMsg)\n\n    // Check if timeout but actually deployed\n    if (errorMsg.includes(\"timeout\")) {\n      const nowDeployed = await sessionClient.account.isDeployed?.()\n      if (nowDeployed) {\n        logger.log(\"[drawbridge] Session deployed despite timeout\")\n        onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n        return\n      }\n    }\n\n    // Check if \"already deployed\" error (RPC cache inconsistency)\n    if (isAlreadyDeployedError(errorMsg)) {\n      logger.log(\"[drawbridge] Session account already deployed (bundler confirmed)\")\n      logger.log(\"[drawbridge] Waiting for RPC cache to update...\")\n\n      // Wait for RPC cache to update before re-checking\n      await new Promise(resolve => setTimeout(resolve, DEPLOYMENT_TIMEOUTS.BUNDLER_STATE_SYNC))\n\n      const nowDeployed = await sessionClient.account.isDeployed?.()\n      if (nowDeployed) {\n        logger.log(\"[drawbridge] Session deployment verified after cache update\")\n        onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n        return\n      }\n\n      logger.warn(\"[drawbridge] Cache still stale after delay - treating as deployed anyway\")\n      // Bundler has authoritative view - if it says deployed, trust it\n      onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n      return\n    }\n\n    onStatus?.({ type: \"error\", message: \"Session deployment failed\", error: error as Error })\n    throw error\n  }\n}\n","import { sendUserOperation, waitForUserOperationReceipt } from \"viem/account-abstraction\"\nimport { getAction } from \"viem/utils\"\nimport { unlimitedDelegationControlId, worldAbi, ConnectedClient } from \"../../types\"\nimport {\n  deployWallet,\n  isWalletDeployed,\n  isAlreadyDeployedError\n} from \"../patterns/wallet-deployment\"\nimport {\n  SetupSessionBaseParams,\n  SmartAccountWithFactory,\n  deploySessionAccount,\n  clearFactoryData\n} from \"./shared\"\nimport { logger } from \"../../logger\"\n\nexport type SetupSessionSmartAccountParams = SetupSessionBaseParams & {\n  /** User's connected smart wallet client */\n  userClient: ConnectedClient\n}\n\n/**\n * Setup session for Smart Account wallets\n *\n * Smart Account Flow:\n * 1. Check if user's smart wallet is deployed on-chain\n * 2. Deploy wallet via factory if needed (counterfactual → deployed)\n * 3. Remove factory data from account to prevent deployment conflicts\n * 4. Submit user operation to register delegation in World contract\n * 5. Deploy session account if needed\n *\n * Smart accounts can use ERC-4337 user operations with paymaster sponsorship.\n * However, they may be counterfactual (not yet deployed), requiring deployment first.\n *\n * @param params Setup parameters for smart account\n */\nexport async function setupSessionSmartAccount({\n  userClient,\n  sessionClient,\n  worldAddress,\n  onStatus\n}: SetupSessionSmartAccountParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address\n  const userAddress = userClient.account.address\n\n  logger.log(\"[drawbridge] Smart Account setup:\", { userAddress })\n\n  onStatus?.({ type: \"checking_wallet\", message: \"Checking wallet status...\" })\n\n  // Check and deploy user's wallet if needed\n  const account = userClient.account as SmartAccountWithFactory\n  const factoryArgs = await account.getFactoryArgs()\n  const hasFactoryData = factoryArgs.factory && factoryArgs.factoryData\n\n  logger.log(\"[drawbridge] Smart wallet check:\", { hasFactoryData, userAddress })\n\n  const alreadyDeployed = await isWalletDeployed(sessionClient, userAddress)\n\n  logger.log(\"[drawbridge] Wallet deployed:\", alreadyDeployed)\n\n  if (alreadyDeployed && hasFactoryData) {\n    logger.log(\"[drawbridge] CASE 1: Wallet deployed and has factory data\")\n    // Wallet deployed but has factory data - remove it\n    logger.log(\"[drawbridge] Removing factory data from deployed wallet\")\n    onStatus?.({ type: \"wallet_deployed\", message: \"Wallet ready\" })\n    clearFactoryData(account)\n  } else if (!alreadyDeployed && hasFactoryData) {\n    logger.log(\"[drawbridge] CASE 2: Wallet not deployed and has factory data\")\n    // Wallet not deployed - deploy it\n    logger.log(\"[drawbridge] Deploying user wallet...\")\n    onStatus?.({ type: \"deploying_wallet\", message: \"Deploying wallet (one-time setup)...\" })\n\n    await deployWallet(sessionClient, factoryArgs.factory!, factoryArgs.factoryData!)\n\n    // Verify deployment succeeded\n    const nowDeployed = await isWalletDeployed(sessionClient, userAddress)\n    if (!nowDeployed) {\n      throw new Error(\n        `Wallet deployment appeared to succeed but contract code not found at ${userAddress}`\n      )\n    }\n\n    onStatus?.({ type: \"wallet_deployed\", message: \"Wallet deployed successfully!\" })\n\n    // Remove factory/factoryData after deployment\n    clearFactoryData(account)\n  } else {\n    onStatus?.({ type: \"wallet_deployed\", message: \"Wallet ready\" })\n  }\n\n  // Proceed with delegation registration\n  onStatus?.({ type: \"registering_delegation\", message: \"Setting up session...\" })\n\n  const calls = [\n    {\n      to: worldAddress,\n      abi: worldAbi,\n      functionName: \"registerDelegation\",\n      args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n    }\n  ]\n\n  // Final check: if factory/factoryData still present, try removal again\n  const accountBeforeSend = userClient.account as SmartAccountWithFactory\n  if (accountBeforeSend.factory || accountBeforeSend.factoryData) {\n    logger.warn(\"[drawbridge] Factory still present, attempting removal again...\")\n    clearFactoryData(accountBeforeSend)\n  }\n\n  try {\n    const hash = await getAction(userClient, sendUserOperation, \"sendUserOperation\")({ calls })\n    logger.log(\"[drawbridge] User operation sent:\", hash)\n\n    const receipt = await getAction(\n      userClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n\n    if (!receipt.success) {\n      throw new Error(\"User operation failed during session setup\")\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n    logger.error(\"[drawbridge] User operation error:\", errorMessage)\n\n    if (isAlreadyDeployedError(errorMessage)) {\n      const helpfulError = new Error(\n        \"Smart wallet deployment conflict. Please try again - it should work on the second attempt.\"\n      )\n      onStatus?.({ type: \"error\", message: \"Please try again\", error: helpfulError })\n      throw helpfulError\n    }\n\n    onStatus?.({ type: \"error\", message: \"Session setup failed\", error: error as Error })\n    throw error\n  }\n\n  // Deploy session account if needed\n  await deploySessionAccount(sessionClient, onStatus)\n\n  logger.log(\"[drawbridge] Smart Account setup complete\")\n  onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n}\n","import { Address, Chain, Client, Hex, OneOf, Transport, toHex } from \"viem\"\nimport { signTypedData } from \"viem/actions\"\nimport { callWithSignatureTypes } from \"@latticexyz/world-module-callwithsignature/internal\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport moduleConfig from \"@latticexyz/world-module-callwithsignature/mud.config\"\nimport moduleConfigAlt from \"@dk1a/world-module-callwithsignature-alt/mud.config\"\nimport { hexToResource } from \"@latticexyz/common\"\nimport { getAction } from \"viem/utils\"\nimport { ConnectedClient } from \"../../types\"\nimport { logger } from \"../../logger\"\n\nexport type SignCallOptions<chain extends Chain = Chain> = {\n  userClient: ConnectedClient<chain>\n  worldAddress: Address\n  systemId: Hex\n  callData: Hex\n  altDomain: boolean\n} & OneOf<{ nonce: bigint } | { client: Client<Transport, chain> }>\n\n/**\n * Sign a World system call using EIP-712 (for CallWithSignature pattern)\n *\n * This creates a signature that can be submitted by the session account to execute\n * a call on behalf of the user (EOA).\n *\n * Flow:\n * 1. **Fetch or use nonce** - Each user has a nonce in CallWithSignatureNonces table\n *    Prevents replay attacks\n *\n * 2. **Parse systemId** - MUD system IDs are resource IDs with namespace + name\n *    e.g., \"world:PlayerSystem\" → { namespace: \"world\", name: \"PlayerSystem\" }\n *\n * 3. **Sign EIP-712 message** - User signs typed data with:\n *    - Domain: depends on altDomain\n *    - - if false: verifyingCotract(World contract), salt(chain ID)\n *    - - if true: name(CallWithSignatureAlt), version(1), chainId, verifyingContract(World contract\n *    - Message: signer, system, callData, nonce\n *\n * The resulting signature can be submitted to World.callWithSignature()\n * by the session account, which will validate and execute as the user.\n *\n * **Why this pattern?**\n * - EOAs can't pay gas via paymaster directly (not smart accounts)\n * - User signs message (free, no gas)\n * - Session account submits + pays gas via paymaster\n * - User gets gasless experience!\n *\n * @param options Sign options including user client and call details\n * @returns EIP-712 signature\n */\nexport async function signCall<chain extends Chain = Chain>({\n  userClient,\n  worldAddress,\n  systemId,\n  callData,\n  nonce: initialNonce,\n  client,\n  altDomain\n}: SignCallOptions<chain>) {\n  logger.log(\"[drawbridge] signCall starting:\", {\n    userAddress: userClient.account.address,\n    worldAddress,\n    systemId,\n    callDataLength: callData.length,\n    chainId: userClient.chain.id,\n    accountType: userClient.account.type,\n    transportType: userClient.transport?.type,\n    transportName: userClient.transport?.name\n  })\n\n  // Get nonce for replay protection\n  // Either use provided nonce or fetch from World contract\n  const nonce =\n    initialNonce ??\n    (client\n      ? (\n          await getRecord(client, {\n            address: worldAddress,\n            table: altDomain\n              ? moduleConfigAlt.tables.AltCallWithSignatureNonces\n              : moduleConfig.tables.CallWithSignatureNonces,\n            key: { signer: userClient.account.address },\n            blockTag: \"pending\"\n          })\n        ).nonce\n      : 0n)\n\n  logger.log(\"[drawbridge] signCall nonce fetched:\", { nonce: nonce.toString() })\n\n  // Parse MUD system ID into namespace and name components\n  const { namespace: systemNamespace, name: systemName } = hexToResource(systemId)\n\n  logger.log(\"[drawbridge] signCall system parsed:\", { systemNamespace, systemName })\n\n  // Build domain and message for logging\n  // Note: chainId should be a bigint for proper EIP-712 encoding\n  const domain = altDomain\n    ? {\n        name: \"CallWithSignatureAlt\",\n        version: \"1\",\n        chainId: BigInt(userClient.chain.id),\n        verifyingContract: worldAddress\n      }\n    : {\n        verifyingContract: worldAddress,\n        salt: toHex(userClient.chain.id, { size: 32 })\n      }\n\n  logger.log(\"[drawbridge] domain constructed:\", {\n    altDomain,\n    chainIdType: altDomain ? \"bigint\" : \"N/A\",\n    chainIdValue: altDomain ? userClient.chain.id.toString() : \"N/A (using salt)\"\n  })\n\n  const message = {\n    signer: userClient.account.address,\n    systemNamespace,\n    systemName,\n    callData,\n    nonce\n  }\n\n  logger.log(\"[drawbridge] signTypedData params:\", {\n    account: userClient.account.address,\n    domain,\n    types: callWithSignatureTypes,\n    primaryType: \"Call\",\n    message: {\n      ...message,\n      callData: `${callData.slice(0, 66)}... (${callData.length} chars)`,\n      nonce: nonce.toString()\n    }\n  })\n\n  // Log the raw EIP-712 structure that will be sent to the wallet\n  // This helps debug wallet compatibility issues\n  // Use a replacer function to handle bigint serialization\n  const domainForLog = altDomain ? { ...domain, chainId: userClient.chain.id.toString() } : domain\n  logger.log(\n    \"[drawbridge] EIP-712 raw structure:\",\n    JSON.stringify(\n      {\n        types: {\n          EIP712Domain: altDomain\n            ? [\n                { name: \"name\", type: \"string\" },\n                { name: \"version\", type: \"string\" },\n                { name: \"chainId\", type: \"uint256\" },\n                { name: \"verifyingContract\", type: \"address\" }\n              ]\n            : [\n                { name: \"verifyingContract\", type: \"address\" },\n                { name: \"salt\", type: \"bytes32\" }\n              ],\n          ...callWithSignatureTypes\n        },\n        primaryType: \"Call\",\n        domain: domainForLog,\n        message: {\n          signer: userClient.account.address,\n          systemNamespace,\n          systemName,\n          callData,\n          nonce: nonce.toString()\n        }\n      },\n      null,\n      2\n    )\n  )\n\n  // Sign EIP-712 typed data\n  // User signs this message, session account will submit it\n\n  // Log exact types being passed to viem\n  logger.log(\"[drawbridge] signTypedData exact values:\", {\n    nonceType: typeof nonce,\n    nonceValue: nonce,\n    systemNamespaceLength: systemNamespace.length,\n    systemNamespaceIsEmpty: systemNamespace === \"\",\n    callDataType: typeof callData,\n    callDataIsHex: callData.startsWith(\"0x\")\n  })\n\n  // Log the exact eth_signTypedData_v4 params that viem will send\n  // This matches the JSON-RPC format: eth_signTypedData_v4(address, typedData)\n  const typedDataForRpc = {\n    types: {\n      EIP712Domain: altDomain\n        ? [\n            { name: \"name\", type: \"string\" },\n            { name: \"version\", type: \"string\" },\n            { name: \"chainId\", type: \"uint256\" },\n            { name: \"verifyingContract\", type: \"address\" }\n          ]\n        : [\n            { name: \"verifyingContract\", type: \"address\" },\n            { name: \"salt\", type: \"bytes32\" }\n          ],\n      ...callWithSignatureTypes\n    },\n    primaryType: \"Call\" as const,\n    domain: domainForLog,\n    message: {\n      ...message,\n      // Convert bigint to hex string for JSON-RPC (how viem serializes uint256)\n      nonce: `0x${nonce.toString(16)}`\n    }\n  }\n  logger.log(\"[drawbridge] eth_signTypedData_v4 params (JSON-RPC format):\", {\n    method: \"eth_signTypedData_v4\",\n    params: [userClient.account.address, JSON.stringify(typedDataForRpc)]\n  })\n\n  try {\n    const signature = await getAction(\n      userClient,\n      signTypedData,\n      \"signTypedData\"\n    )({\n      account: userClient.account,\n      // EIP-712 domain bound to World contract and chain\n      domain,\n      // MUD's CallWithSignature type definitions\n      types: callWithSignatureTypes,\n      primaryType: \"Call\",\n      // Message contains all call details + nonce\n      message\n    })\n\n    logger.log(\"[drawbridge] signTypedData success:\", { signatureLength: signature.length })\n    return signature\n  } catch (error) {\n    logger.error(\"[drawbridge] signTypedData failed:\", {\n      error,\n      errorMessage: error instanceof Error ? error.message : String(error),\n      errorDetails: (error as { details?: string })?.details\n    })\n    throw error\n  }\n}\n","import { Chain } from \"viem\"\nimport { writeContract as viem_writeContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { SignCallOptions, signCall } from \"./eip712-signing\"\nimport CallWithSignatureAbi from \"@latticexyz/world-module-callwithsignature/out/CallWithSignatureSystem.sol/CallWithSignatureSystem.abi.json\"\nimport CallWithSignatureAltAbi from \"@dk1a/world-module-callwithsignature-alt/out/CallWithSignatureSystem.sol/CallWithSignatureSystem.abi.json\"\nimport { ConnectedClient } from \"../../types\"\nimport { logger } from \"../../logger\"\n\nexport type CallWithSignatureOptions<chain extends Chain = Chain> = SignCallOptions<chain> & {\n  sessionClient: ConnectedClient\n}\n\n/**\n * Call a World system using signature-based execution (for EOAs)\n *\n * MUD's CallWithSignature pattern allows EOAs to execute gasless transactions:\n *\n * 1. User signs an EIP-712 message (free, off-chain)\n * 2. Session account submits the signature + call to World\n * 3. World's CallWithSignatureSystem validates the signature\n * 4. If valid, executes the call as the user (with user's identity)\n *\n * This enables gasless transactions - the session account pays gas via paymaster,\n * but the call executes with the user's permissions/identity.\n *\n * Flow:\n *   User (EOA) → signs message → Session Account → submits to World\n *   → World validates signature → executes as User\n *\n * @param options Call parameters including user client and session client\n * @returns Transaction hash\n */\nexport async function callWithSignature<chain extends Chain = Chain>({\n  sessionClient,\n  ...opts\n}: CallWithSignatureOptions<chain>) {\n  logger.log(\"[drawbridge] callWithSignature starting:\", {\n    userAddress: opts.userClient.account.address,\n    sessionAddress: sessionClient.account.address,\n    worldAddress: opts.worldAddress,\n    systemId: opts.systemId,\n    altDomain: opts.altDomain\n  })\n\n  logger.log(\"[drawbridge] callWithSignature: requesting user signature...\")\n  const signature = await signCall(opts)\n  logger.log(\"[drawbridge] callWithSignature: user signature obtained\")\n\n  // Submit transaction to World\n  // TypeScript workaround: viem's writeContract has complex type inference that\n  // doesn't perfectly match the CallWithSignatureAbi args structure.\n  // The runtime types are correct - we're calling:\n  // callWithSignature(address signer, bytes32 systemId, bytes callData, bytes signature)\n  // This cast is safe because we're manually constructing the correct args array.\n  logger.log(\"[drawbridge] callWithSignature: submitting transaction via session account...\")\n  const hash = await getAction(\n    sessionClient,\n    viem_writeContract,\n    \"writeContract\"\n  )({\n    address: opts.worldAddress,\n    abi: opts.altDomain ? CallWithSignatureAltAbi : CallWithSignatureAbi,\n    functionName: opts.altDomain ? \"callWithSignatureAlt\" : \"callWithSignature\",\n    args: [opts.userClient.account.address, opts.systemId, opts.callData, signature]\n  } as never)\n\n  logger.log(\"[drawbridge] callWithSignature: transaction submitted:\", { hash })\n  return hash\n}\n","import { encodeFunctionData } from \"viem\"\nimport { waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport IBaseWorldAbi from \"@latticexyz/world/out/IBaseWorld.sol/IBaseWorld.abi.json\"\nimport { systemsConfig as worldSystemsConfig } from \"@latticexyz/world/mud.config\"\nimport { unlimitedDelegationControlId, ConnectedClient, PublicClient } from \"../../types\"\nimport { callWithSignature } from \"../patterns/call-with-signature\"\nimport { SetupSessionBaseParams, deploySessionAccount } from \"./shared\"\nimport { logger } from \"../../logger\"\n\nexport type SetupSessionEOAParams = SetupSessionBaseParams & {\n  /** Public client for reading blockchain state */\n  publicClient: PublicClient\n  /** User's connected EOA wallet client */\n  userClient: ConnectedClient\n}\n\n/**\n * Setup session for EOA wallets\n *\n * EOA Flow (CallWithSignature Pattern):\n * 1. User signs an EIP-712 message off-chain (free, no gas)\n * 2. Session account submits the signature + call to World\n * 3. World.callWithSignature() or World.callWithSignatureAlt() validates the signature\n * 4. If valid, World registers delegation as the user\n * 5. Deploy session account\n *\n * @param params Setup parameters for EOA\n */\nexport async function setupSessionEOA({\n  publicClient,\n  userClient,\n  sessionClient,\n  worldAddress,\n  onStatus\n}: SetupSessionEOAParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address\n  const userAddress = userClient.account.address\n\n  logger.log(\"[drawbridge] EOA setup:\", { userAddress })\n\n  onStatus?.({ type: \"registering_delegation\", message: \"Setting up session...\" })\n\n  const hash = await callWithSignature({\n    client: sessionClient,\n    userClient,\n    sessionClient,\n    worldAddress,\n    systemId: worldSystemsConfig.systems.RegistrationSystem.systemId,\n    callData: encodeFunctionData({\n      abi: IBaseWorldAbi,\n      functionName: \"registerDelegation\",\n      args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n    }),\n    altDomain: true\n  })\n\n  const receipt = await getAction(\n    publicClient,\n    waitForTransactionReceipt,\n    \"waitForTransactionReceipt\"\n  )({ hash })\n\n  if (receipt.status === \"reverted\") {\n    throw new Error(\"Delegation registration transaction reverted\")\n  }\n\n  // Deploy session account if needed\n  await deploySessionAccount(sessionClient, onStatus)\n\n  logger.log(\"[drawbridge] EOA setup complete\")\n  onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n}\n","import { Hex } from \"viem\"\nimport { SessionClient, ConnectedClient, PublicClient } from \"../../types\"\nimport { SetupSessionStatus } from \"./shared\"\nimport { setupSessionSmartAccount } from \"./smart-account\"\nimport { setupSessionEOA } from \"./eoa\"\nimport { checkDelegation } from \"./check\"\nimport { logger } from \"../../logger\"\n\n/**\n * Complete setup session parameters (supports both EOA and Smart Account)\n */\nexport type SetupSessionParams = {\n  /** Public client for reading blockchain state */\n  publicClient: PublicClient\n  /** User's connected wallet client (EOA or Smart Account) */\n  userClient: ConnectedClient\n  /** Session smart account client with MUD extensions */\n  sessionClient: SessionClient\n  /** MUD World contract address */\n  worldAddress: Hex\n  /** Progress callback for status updates */\n  onStatus?: (status: SetupSessionStatus) => void\n}\n\n// Re-export SetupSessionStatus for convenience\nexport type { SetupSessionStatus }\n\n/**\n * Setup session by registering delegation and deploying session account\n *\n * This is the main entry point that automatically routes to the correct implementation\n * based on the user's wallet type.\n *\n * Returns early if session is already fully set up.\n *\n * Flow differs based on wallet type:\n *\n * **Smart Account Wallet:**\n * - Checks and deploys user's wallet if needed\n * - Sends user operation to register delegation\n * - User's smart account submits the operation\n * - Uses bundler + paymaster infrastructure\n *\n * **EOA (Externally Owned Account):**\n * - Uses CallWithSignature pattern (gasless for user)\n * - User signs a message (EIP-712)\n * - Session account submits the signature + call\n * - World validates signature and executes as user\n *\n * @param params Setup parameters\n */\nexport async function setupSession({\n  publicClient,\n  userClient,\n  sessionClient,\n  worldAddress,\n  onStatus\n}: SetupSessionParams): Promise<void> {\n  const userAddress = userClient.account.address\n  const sessionAddress = sessionClient.account.address\n\n  logger.log(\"[drawbridge] Setup session:\", {\n    userAddress,\n    accountType: userClient.account.type\n  })\n\n  // Check if session is already fully set up\n  const hasDelegation = await checkDelegation({\n    client: publicClient,\n    worldAddress,\n    userAddress,\n    sessionAddress\n  })\n\n  const sessionDeployed = await sessionClient.account.isDeployed?.()\n\n  if (hasDelegation && sessionDeployed) {\n    logger.log(\"[drawbridge] Session already fully set up, skipping\")\n    onStatus?.({ type: \"complete\", message: \"Session already set up!\" })\n    return\n  }\n\n  logger.log(\"[drawbridge] Session setup required:\", { hasDelegation, sessionDeployed })\n\n  // Route to appropriate implementation based on wallet type\n  if (userClient.account.type === \"smart\") {\n    return setupSessionSmartAccount({\n      userClient,\n      sessionClient,\n      worldAddress,\n      onStatus\n    })\n  } else {\n    return setupSessionEOA({\n      publicClient,\n      userClient,\n      sessionClient,\n      worldAddress,\n      onStatus\n    })\n  }\n}\n","import { Chain, Transport } from \"viem\"\nimport { createConfig, createStorage, type Config, type CreateConnectorFn } from \"@wagmi/core\"\n\n/**\n * Configuration parameters for creating wagmi config\n */\nexport type WalletConfigParams = {\n  /** Supported chains */\n  chains: readonly [Chain, ...Chain[]]\n  /** Transport configuration per chain */\n  transports: Record<number, Transport>\n  /** Wallet connectors (injected, walletConnect, etc.) */\n  connectors: CreateConnectorFn[]\n  /** Optional polling interval in milliseconds */\n  pollingInterval?: number\n}\n\n/**\n * Create wagmi configuration for wallet connection\n *\n * Configures wagmi with:\n * - Chains and transports for RPC communication\n * - Wallet connectors (MetaMask, WalletConnect, Coinbase, etc.)\n * - localStorage persistence for connection state\n * - Optional polling interval for state updates\n *\n * @param params Configuration parameters\n * @returns Wagmi Config instance\n */\nexport function createWalletConfig({\n  chains,\n  transports,\n  connectors,\n  pollingInterval\n}: WalletConfigParams): Config {\n  return createConfig({\n    chains,\n    transports,\n    connectors,\n    pollingInterval,\n    storage: createStorage({\n      storage: typeof window !== \"undefined\" ? window.localStorage : undefined\n    })\n  })\n}\n","import { watchAccount, type Config } from \"@wagmi/core\"\nimport type { GetAccountReturnType } from \"@wagmi/core\"\nimport { logger } from \"../logger\"\n\n/**\n * Account change handler callback\n *\n * Called whenever the connected wallet account changes (connect, disconnect, switch).\n */\nexport type AccountChangeHandler = (account: GetAccountReturnType) => void | Promise<void>\n\n/**\n * Cleanup function returned by setupAccountWatcher\n *\n * Call this to stop watching for account changes.\n */\nexport type UnwatchAccount = () => void\n\n/**\n * Setup wagmi account watcher\n *\n * Watches for wallet connection state changes and calls the provided handler.\n *\n * Changes detected:\n * - Wallet connected\n * - Wallet disconnected\n * - Account switched\n * - Chain switched\n *\n * @param wagmiConfig Wagmi configuration instance\n * @param onChange Handler called on account changes\n * @returns Cleanup function to stop watching\n *\n * @example\n * ```typescript\n * const unwatch = setupAccountWatcher(wagmiConfig, async (account) => {\n *   if (account.isConnected) {\n *     console.log(\"Connected:\", account.address)\n *     await handleConnection(account)\n *   } else {\n *     console.log(\"Disconnected\")\n *     await handleDisconnection()\n *   }\n * })\n *\n * // Later, stop watching\n * unwatch()\n * ```\n */\nexport function setupAccountWatcher(\n  wagmiConfig: Config,\n  onChange: AccountChangeHandler\n): UnwatchAccount {\n  return watchAccount(wagmiConfig, {\n    onChange: account => {\n      logger.log(\"[wallet] Account change:\", {\n        isConnected: account.isConnected,\n        address: account.address\n      })\n\n      // Call handler (may be async)\n      const result = onChange(account)\n      if (result instanceof Promise) {\n        result.catch(err => {\n          logger.error(\"[wallet] Account change handler failed:\", err)\n        })\n      }\n    }\n  })\n}\n","import { Address } from \"viem\"\nimport { reconnect, connect, disconnect, getConnectors, getAccount, type Config } from \"@wagmi/core\"\nimport { logger } from \"../logger\"\n\n/**\n * Result of reconnection attempt\n */\nexport type ReconnectResult = {\n  /** Whether reconnection was successful */\n  reconnected: boolean\n  /** Connected account address if reconnected */\n  address?: Address\n}\n\n/**\n * Attempt to reconnect to previously connected wallet\n *\n * Checks localStorage for previous connection state and attempts to restore it.\n * This should be called during initialization.\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Reconnection result\n *\n * @example\n * ```typescript\n * const result = await attemptReconnect(wagmiConfig)\n * if (result.reconnected) {\n *   console.log(\"Reconnected to:\", result.address)\n *   // Handle reconnected state\n * } else {\n *   console.log(\"No previous connection\")\n *   // Start in disconnected state\n * }\n * ```\n */\nexport async function attemptReconnect(wagmiConfig: Config): Promise<ReconnectResult> {\n  try {\n    await reconnect(wagmiConfig)\n\n    const account = getAccount(wagmiConfig)\n    if (account.isConnected && account.address) {\n      logger.log(\"[wallet] Reconnection successful:\", account.address)\n      return {\n        reconnected: true,\n        address: account.address\n      }\n    }\n\n    logger.log(\"[wallet] Reconnected but no account\")\n    return { reconnected: false }\n  } catch (err) {\n    logger.log(\"[wallet] No previous connection to restore\")\n    return { reconnected: false }\n  }\n}\n\n/**\n * Connect to a wallet by connector ID\n *\n * @param wagmiConfig Wagmi configuration instance\n * @param connectorId Connector ID to connect to\n * @param chainId Optional chain ID to connect on\n * @throws If connector not found or connection fails\n *\n * @example\n * ```typescript\n * try {\n *   await connectWallet(wagmiConfig, \"injected\", 8453)\n *   console.log(\"Connected successfully\")\n * } catch (err) {\n *   if (err.name === \"ConnectorAlreadyConnectedError\") {\n *     console.log(\"Already connected\")\n *   } else {\n *     console.error(\"Connection failed:\", err)\n *   }\n * }\n * ```\n */\nexport async function connectWallet(\n  wagmiConfig: Config,\n  connectorId: string,\n  chainId?: number\n): Promise<void> {\n  const connectors = getConnectors(wagmiConfig)\n  const connector = connectors.find(c => c.id === connectorId)\n\n  if (!connector) {\n    throw new Error(`Connector not found: ${connectorId}`)\n  }\n\n  logger.log(\"[wallet] Connecting to wallet:\", connectorId)\n\n  await connect(wagmiConfig, {\n    connector,\n    chainId\n  })\n\n  logger.log(\"[wallet] Connection initiated\")\n}\n\n/**\n * Disconnect the currently connected wallet\n *\n * Clears wagmi connection state and localStorage.\n *\n * @param wagmiConfig Wagmi configuration instance\n *\n * @example\n * ```typescript\n * await disconnectWallet(wagmiConfig)\n * console.log(\"Disconnected\")\n * ```\n */\nexport async function disconnectWallet(wagmiConfig: Config): Promise<void> {\n  logger.log(\"[wallet] Disconnecting...\")\n\n  try {\n    await disconnect(wagmiConfig)\n    logger.log(\"[wallet] Disconnected successfully\")\n  } catch (err) {\n    logger.error(\"[wallet] Disconnect error:\", err)\n    throw err\n  }\n}\n\n/**\n * Get current account information\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Current account state\n *\n * @example\n * ```typescript\n * const account = getCurrentAccount(wagmiConfig)\n * if (account.isConnected) {\n *   console.log(\"Connected:\", account.address)\n * }\n * ```\n */\nexport function getCurrentAccount(wagmiConfig: Config) {\n  return getAccount(wagmiConfig)\n}\n\n/**\n * Get list of available wallet connectors\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Array of available connectors\n *\n * @example\n * ```typescript\n * const connectors = getAvailableConnectors(wagmiConfig)\n * console.log(\"Available wallets:\", connectors.map(c => c.name))\n * ```\n */\nexport function getAvailableConnectors(wagmiConfig: Config) {\n  return getConnectors(wagmiConfig)\n}\n","import { Address, Chain, Client, Transport, createPublicClient } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { SessionClient, DrawbridgeStatus, PublicClient } from \"./types\"\nimport { getSessionSigner } from \"./session/core/signer\"\nimport { getSessionAccount } from \"./session/core/account\"\nimport { getSessionClient } from \"./session/core/client\"\nimport { checkDelegation } from \"./session/delegation/check\"\nimport { setupSession, type SetupSessionStatus } from \"./session/delegation/setup\"\nimport { sessionStorage } from \"./session/core/storage\"\nimport { getConnectorClient, type Config, type CreateConnectorFn } from \"@wagmi/core\"\nimport {\n  createWalletConfig,\n  setupAccountWatcher,\n  attemptReconnect,\n  connectWallet as walletConnect,\n  disconnectWallet as walletDisconnect,\n  getAvailableConnectors as walletGetAvailableConnectors\n} from \"./wallet\"\nimport { logger, setLoggingEnabled } from \"./logger\"\n\n/**\n * Configuration for Drawbridge instance\n */\nexport type DrawbridgeConfig = {\n  /** Public client */\n  publicClient: PublicClient\n  /** Transport for wallet client */\n  transport: Transport\n  /** Wallet connectors (injected, walletConnect, etc.) */\n  connectors: CreateConnectorFn[]\n  /** MUD World contract address (optional if skipSessionSetup is true) */\n  worldAddress?: Address\n  /** Optional paymaster client for sponsored transactions */\n  paymasterClient?: PaymasterClient\n  /** Optional polling interval for wagmi (in ms) */\n  pollingInterval?: number\n  /** Optional app name for wallet connectors */\n  appName?: string\n  /**\n   * Current ETH price in USD for gas cost calculations\n   * Used with $500 margin in fee cap: (ethPriceUSD + 500)\n   * If not provided, defaults to $3,000\n   */\n  ethPriceUSD?: number\n  /**\n   * Skip session setup entirely - wallet connection only mode\n   * Use this for apps that don't need MUD delegation/session accounts.\n   * When true:\n   * - No session account created\n   * - No delegation registration\n   * - Only provides connected wallet client via wagmi\n   * - worldAddress is optional\n   * @default false\n   */\n  skipSessionSetup?: boolean\n  /**\n   * Enable console logging for debugging\n   * When false, all console.log and console.warn calls are suppressed.\n   * Errors are always logged regardless of this setting.\n   * @default false\n   */\n  logging?: boolean\n}\n\n/**\n * Current state of the Drawbridge instance\n * Updated reactively and broadcast to subscribers\n */\nexport type DrawbridgeState = {\n  /** Current status of Drawbridge - single source of truth */\n  status: DrawbridgeStatus\n  /** Session client with MUD World extensions, null if not connected */\n  sessionClient: SessionClient | null\n  /** Original user's wallet address, null if not connected */\n  userAddress: Address | null\n  /** Session smart account address, null if not connected */\n  sessionAddress: Address | null\n  /** Whether session has delegation registered and is ready to use */\n  isReady: boolean\n  /** Error that occurred during connection or session setup, null if no error */\n  error: Error | null\n}\n\n/**\n * Result of checking session prerequisites\n */\nexport type PrerequisiteStatus = {\n  /** Whether delegation is registered in World contract */\n  hasDelegation: boolean\n  /** Whether session is fully ready (same as hasDelegation) */\n  isReady: boolean\n}\n\ntype StateListener = (state: DrawbridgeState) => void\ntype Unsubscribe = () => void\n\n/**\n * Connector info for UI display\n */\nexport type ConnectorInfo = {\n  id: string\n  name: string\n  type: string\n}\n\n/**\n * Drawbridge - Headless wallet connection and session management\n *\n * Based on @latticexyz/drawbridge - a stripped down, headless version.\n *\n * Provides complete wallet connection and session management:\n * - Wagmi integration (connectors, account watching, reconnection)\n * - ERC-4337 session account creation\n * - MUD World delegation registration\n * - Reactive state management (framework-agnostic)\n * - Gasless transaction support via paymaster\n *\n * Usage:\n * ```typescript\n * const drawbridge = new Drawbridge({\n *   chainId: 8453,\n *   chains: [baseChain],\n *   transports: { 8453: http() },\n *   connectors: [injected()],\n *   worldAddress: \"0x...\"\n * });\n *\n * // Initialize (await reconnection, setup watchers)\n * await drawbridge.initialize();\n *\n * // Get available wallets\n * const wallets = drawbridge.getAvailableConnectors();\n *\n * // Connect to wallet\n * await drawbridge.connectWallet(wallets[0].id);\n *\n * // Setup delegation if needed\n * if (!drawbridge.isReady) {\n *   await drawbridge.setupSession();\n * }\n *\n * // Disconnect\n * await drawbridge.disconnectWallet();\n * ```\n */\nexport class Drawbridge {\n  private config: DrawbridgeConfig\n  private state: DrawbridgeState\n  private listeners = new Set<StateListener>()\n  private wagmiConfig: Config\n  private _publicClient: PublicClient\n  private accountWatcherCleanup: (() => void) | null = null\n  private isConnecting = false\n  private isDisconnecting = false\n\n  constructor(config: DrawbridgeConfig) {\n    // Validate configuration\n    this.validateConfig(config)\n\n    // Set logging state before any other operations\n    setLoggingEnabled(config.logging ?? false)\n\n    this.config = config\n    this.state = {\n      status: DrawbridgeStatus.UNINITIALIZED,\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false,\n      error: null\n    }\n\n    // Get the chain from public client\n    const chain = config.publicClient.chain\n\n    // Set the public client from config\n    this._publicClient = config.publicClient\n\n    logger.log(\"[drawbridge] Public client created for chain:\", chain.name)\n\n    // Create wagmi config for wallet connections\n    this.wagmiConfig = createWalletConfig({\n      chains: [chain],\n      transports: { [chain.id]: config.transport },\n      connectors: config.connectors,\n      pollingInterval: config.pollingInterval\n    })\n  }\n\n  /**\n   * Validate configuration parameters\n   *\n   * Throws errors for invalid configuration to help developers catch issues early.\n   * @private\n   */\n  private validateConfig(config: DrawbridgeConfig): void {\n    // Warn if worldAddress missing with session setup enabled\n    if (!config.skipSessionSetup && !config.worldAddress) {\n      logger.warn(\n        \"[drawbridge] Configuration warning: worldAddress not provided but session setup is enabled. \" +\n          \"Session creation will work, but delegation checks will fail. \" +\n          \"Did you forget to pass worldAddress, or did you mean to set skipSessionSetup: true?\"\n      )\n    }\n\n    // Validate worldAddress if session setup is enabled\n    if (!config.skipSessionSetup && config.worldAddress) {\n      // Check that worldAddress is a valid hex address\n      if (!/^0x[a-fA-F0-9]{40}$/.test(config.worldAddress)) {\n        throw new Error(\n          `Drawbridge configuration error: worldAddress \"${config.worldAddress}\" is not a valid Ethereum address. ` +\n            `Expected format: 0x followed by 40 hexadecimal characters.`\n        )\n      }\n    }\n  }\n\n  /**\n   * Initialize Drawbridge (await reconnection and setup account watcher)\n   *\n   * This should be called once after construction and awaited.\n   * It will attempt to reconnect to a previously connected wallet.\n   */\n  async initialize(): Promise<void> {\n    logger.log(\"[drawbridge] Initializing...\")\n\n    // Attempt to reconnect to previously connected wallet\n    const result = await attemptReconnect(this.wagmiConfig)\n\n    if (!result.reconnected) {\n      // No reconnection - set status to DISCONNECTED\n      this.updateState({ status: DrawbridgeStatus.DISCONNECTED })\n    }\n\n    // Setup account watcher for future changes\n    this.setupAccountWatcher()\n\n    // If reconnection succeeded, manually handle the initial connection\n    // (the watcher won't fire for connections that happened before it was set up)\n    if (result.reconnected && result.address) {\n      logger.log(\"[drawbridge] Processing reconnected wallet:\", result.address)\n      await this.handleWalletConnection()\n    }\n\n    logger.log(\"[drawbridge] Initialization complete\")\n  }\n\n  // ===== Reactive State Management =====\n\n  /**\n   * Subscribe to state changes\n   *\n   * The listener will be called immediately with the current state,\n   * and again whenever the state changes.\n   *\n   * @param listener Function to call on state changes\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = drawbridge.subscribe((state) => {\n   *   if (state.sessionClient) {\n   *     console.log(\"Session ready:\", state.sessionClient.account.address);\n   *   }\n   * });\n   *\n   * // Later, stop listening\n   * unsubscribe();\n   * ```\n   */\n  subscribe(listener: StateListener): Unsubscribe {\n    this.listeners.add(listener)\n    listener(this.state) // Immediate callback with current state\n    return () => this.listeners.delete(listener)\n  }\n\n  /**\n   * Get current state (non-reactive snapshot)\n   *\n   * For reactive updates, use subscribe() instead.\n   */\n  getState(): DrawbridgeState {\n    return { ...this.state }\n  }\n\n  private updateState(updates: Partial<DrawbridgeState>): void {\n    this.state = { ...this.state, ...updates }\n    this.notify()\n  }\n\n  private notify(): void {\n    this.listeners.forEach(listener => listener(this.state))\n  }\n\n  /**\n   * Setup wagmi account watcher to handle connection/disconnection\n   * Called automatically by initialize()\n   */\n  private setupAccountWatcher(): void {\n    const unwatch = setupAccountWatcher(this.wagmiConfig, async account => {\n      // Handle disconnection\n      if (!account.isConnected) {\n        logger.log(\"[drawbridge] Wallet disconnected\")\n        this.updateState({\n          status: DrawbridgeStatus.DISCONNECTED,\n          sessionClient: null,\n          userAddress: null,\n          sessionAddress: null,\n          isReady: false,\n          error: null\n        })\n        this.isConnecting = false\n        return\n      }\n\n      // Ignore connection attempts while disconnecting to prevent deadlock\n      if (this.isDisconnecting) {\n        logger.log(\"[drawbridge] Ignoring connection attempt during disconnect\")\n        return\n      }\n\n      // Handle connection\n      if (this.isConnecting) {\n        logger.log(\"[drawbridge] Already processing connection\")\n        return\n      }\n\n      if (!account.connector || !account.address) {\n        return\n      }\n\n      try {\n        this.isConnecting = true\n        await this.handleWalletConnection()\n      } catch (err) {\n        logger.error(\"[drawbridge] Connection handler failed:\", {\n          error: err,\n          errorMessage: err instanceof Error ? err.message : String(err),\n          errorName: err instanceof Error ? err.name : \"Unknown\",\n          errorStack: err instanceof Error ? err.stack : undefined,\n          timestamp: new Date().toISOString()\n        })\n        // Propagate error through state so UI can handle it\n        this.updateState({\n          status: DrawbridgeStatus.ERROR,\n          error: err instanceof Error ? err : new Error(String(err))\n        })\n      } finally {\n        this.isConnecting = false\n      }\n    })\n\n    this.accountWatcherCleanup = unwatch\n  }\n\n  /**\n   * Internal handler for wallet connection\n   * Called when wagmi detects a connected account\n   */\n  private async handleWalletConnection(): Promise<void> {\n    // Get wallet client from wagmi\n    let userClient: Client\n    try {\n      userClient = await getConnectorClient(this.wagmiConfig)\n    } catch (err) {\n      logger.log(\"[drawbridge] Could not get connector client\")\n      return\n    }\n\n    if (!userClient.account || !userClient.chain) {\n      logger.log(\"[drawbridge] Wallet client missing account or chain\")\n      return\n    }\n\n    const userAddress = userClient.account.address\n    logger.log(\"[drawbridge] Wallet connected:\", userAddress)\n\n    // Validate wallet is on the correct chain\n    const expectedChainId = this.config.publicClient.chain.id\n    if (userClient.chain.id !== expectedChainId) {\n      const error = new Error(\n        `Chain mismatch: wallet on chain ${userClient.chain.id}, expected ${expectedChainId}`\n      )\n      logger.error(\"[drawbridge]\", error.message)\n      throw error\n    }\n\n    // If skipSessionSetup is true, just store the user address and mark as READY\n    // No session account, no delegation - just wallet connection\n    if (this.config.skipSessionSetup) {\n      logger.log(\"[drawbridge] Skipping session setup (wallet-only mode)\")\n      this.updateState({\n        status: DrawbridgeStatus.READY,\n        sessionClient: null,\n        userAddress,\n        sessionAddress: null,\n        isReady: true,\n        error: null\n      })\n      return\n    }\n\n    // Full session setup flow (MUD delegation)\n    logger.log(\"[drawbridge] Setting up session for address:\", userAddress)\n\n    // Get or create persistent session signer from localStorage\n    const signer = getSessionSigner(userAddress)\n\n    // DEBUG: Log details before creating session account\n    logger.log(\"[drawbridge] About to create session account with publicClient:\", {\n      chainId: this._publicClient.chain?.id,\n      chainName: this._publicClient.chain?.name,\n      userAddress,\n      timestamp: new Date().toISOString()\n    })\n\n    // Create ERC-4337 SimpleAccount smart wallet\n    // Uses the dedicated publicClient for all chain reads\n    const { account } = await getSessionAccount({\n      publicClient: this._publicClient,\n      userAddress\n    })\n\n    // Create session client with MUD World callFrom/sendUserOperationFrom extensions\n    // Uses the dedicated publicClient for MUD extension reads\n    const sessionClient = await getSessionClient({\n      publicClient: this._publicClient,\n      userAddress,\n      sessionAccount: account,\n      sessionSigner: signer,\n      worldAddress: this.config.worldAddress!,\n      paymasterOverride: this.config.paymasterClient,\n      ethPriceUSD: this.config.ethPriceUSD\n    })\n\n    // Check if delegation already exists BEFORE notifying listeners\n    // This prevents UI flash where sessionClient exists but isReady is unknown\n    let hasDelegation = false\n    try {\n      hasDelegation = await checkDelegation({\n        client: this._publicClient,\n        worldAddress: this.config.worldAddress!,\n        userAddress,\n        sessionAddress: account.address\n      })\n    } catch (err) {\n      logger.error(\"[drawbridge] Failed to check delegation:\", err)\n      throw new Error(\n        `Failed to check delegation: ${err instanceof Error ? err.message : String(err)}`\n      )\n    }\n\n    // Update state once with complete information\n    // Set status to READY if delegation exists, CONNECTED if not\n    // Clear any previous errors on successful connection\n    this.updateState({\n      status: hasDelegation ? DrawbridgeStatus.READY : DrawbridgeStatus.CONNECTED,\n      sessionClient,\n      userAddress,\n      sessionAddress: account.address,\n      isReady: hasDelegation,\n      error: null\n    })\n\n    logger.log(\"[drawbridge] Session connection complete, isReady:\", hasDelegation)\n  }\n\n  // ===== Public API =====\n\n  /**\n   * Get available wallet connectors for UI display\n   *\n   * @returns Array of connector info (id, name, type)\n   */\n  getAvailableConnectors(): ConnectorInfo[] {\n    const connectors = walletGetAvailableConnectors(this.wagmiConfig)\n    return connectors.map(c => ({\n      id: c.id,\n      name: c.name,\n      type: c.type\n    }))\n  }\n\n  /**\n   * Connect to a wallet by connector ID\n   *\n   * This will:\n   * 1. Connect via wagmi\n   * 2. Account watcher will automatically handle drawbridge session creation\n   *\n   * @param connectorId Connector ID (from getAvailableConnectors())\n   * @throws If connector not found or connection fails\n   */\n  async connectWallet(connectorId: string): Promise<void> {\n    logger.log(\"[drawbridge] Connecting to wallet:\", connectorId)\n\n    // Set status to CONNECTING\n    this.updateState({ status: DrawbridgeStatus.CONNECTING })\n\n    try {\n      await walletConnect(this.wagmiConfig, connectorId, this._publicClient.chain.id)\n    } catch (err) {\n      // If already connected, that's fine\n      if (err instanceof Error && err.name === \"ConnectorAlreadyConnectedError\") {\n        logger.log(\"[drawbridge] Already connected\")\n        return\n      }\n      // Reset to DISCONNECTED on error\n      this.updateState({ status: DrawbridgeStatus.DISCONNECTED })\n      throw err\n    }\n\n    // Account watcher will handle the rest and set appropriate status\n  }\n\n  /**\n   * Disconnect wallet and clear session\n   *\n   * This will:\n   * 1. Disconnect via wagmi\n   * 2. Account watcher will automatically clear drawbridge state\n   */\n  async disconnectWallet(): Promise<void> {\n    logger.log(\"[drawbridge] disconnectWallet() called\")\n    logger.log(\"[drawbridge] Current state:\", this.state)\n    logger.log(\"[drawbridge] Calling wagmi disconnect()...\")\n\n    try {\n      this.isDisconnecting = true\n      await walletDisconnect(this.wagmiConfig)\n      logger.log(\"[drawbridge] Wallet disconnected\")\n    } catch (err) {\n      logger.error(\"[drawbridge] Disconnect error:\", err)\n      throw err\n    } finally {\n      this.isDisconnecting = false\n    }\n\n    logger.log(\"[drawbridge] Disconnect complete\")\n  }\n\n  /**\n   * Check if session is ready to use\n   *\n   * Queries the MUD World contract to check if delegation is registered\n   * between the user's account and the session account.\n   *\n   * @returns Delegation status\n   */\n  async checkPrerequisites(): Promise<PrerequisiteStatus> {\n    if (!this.state.sessionClient) {\n      return { hasDelegation: false, isReady: false }\n    }\n\n    const hasDelegation = await checkDelegation({\n      client: this._publicClient,\n      worldAddress: this.config.worldAddress!,\n      userAddress: this.state.userAddress!,\n      sessionAddress: this.state.sessionAddress!\n    })\n\n    this.updateState({ isReady: hasDelegation })\n\n    return { hasDelegation, isReady: hasDelegation }\n  }\n\n  /**\n   * Setup session by registering delegation and deploying account\n   *\n   * This will:\n   * 1. Get current wallet client from wagmi\n   * 2. Register delegation in MUD World contract (user delegates to session)\n   * 3. Deploy session smart account if not already deployed\n   *\n   * User will need to sign a transaction (EOA) or user operation (smart account).\n   *\n   * @throws If not connected (call connectWallet() first)\n   */\n  async setupSession(onStatus?: (status: SetupSessionStatus) => void): Promise<void> {\n    if (this.config.skipSessionSetup) {\n      throw new Error(\n        \"Cannot setup session when skipSessionSetup is true. This drawbridge instance is in wallet-only mode.\"\n      )\n    }\n\n    if (!this.state.sessionClient) {\n      throw new Error(\"Not connected. Call connectWallet() first.\")\n    }\n\n    logger.log(\"[drawbridge] Setting up session (registering delegation)...\")\n\n    // Set status to SETTING_UP_SESSION\n    this.updateState({ status: DrawbridgeStatus.SETTING_UP_SESSION })\n\n    // Get current wallet client from wagmi\n    const userClient = await getConnectorClient(this.wagmiConfig)\n\n    try {\n      await setupSession({\n        publicClient: this._publicClient,\n        userClient,\n        sessionClient: this.state.sessionClient,\n        worldAddress: this.config.worldAddress!,\n        onStatus\n      })\n\n      // Session setup complete - set status to READY and clear any errors\n      this.updateState({ status: DrawbridgeStatus.READY, isReady: true, error: null })\n\n      logger.log(\"[drawbridge] Session setup complete\")\n    } catch (err) {\n      // Reset to CONNECTED on error\n      this.updateState({ status: DrawbridgeStatus.CONNECTED })\n      throw err\n    }\n  }\n\n  /**\n   * Cleanup and destroy drawbridge instance\n   *\n   * This will:\n   * 1. Unwatch account changes\n   * 2. Clear session state (but NOT localStorage keys)\n   *\n   * Call this when unmounting your app.\n   */\n  destroy(): void {\n    logger.log(\"[drawbridge] Destroying instance\")\n\n    // Cleanup account watcher\n    if (this.accountWatcherCleanup) {\n      this.accountWatcherCleanup()\n      this.accountWatcherCleanup = null\n    }\n\n    // Clear state\n    this.updateState({\n      status: DrawbridgeStatus.DISCONNECTED,\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false,\n      error: null\n    })\n  }\n\n  /**\n   * Clear stored session keys from localStorage\n   *\n   * This permanently removes the session private key for the current user.\n   * Next time connect() is called, a new session account will be created.\n   */\n  clearStorage(): void {\n    if (this.state.userAddress) {\n      sessionStorage.removeSigner(this.state.userAddress)\n    }\n  }\n\n  // ===== Convenience Getters =====\n\n  /** Get current session client (null if not connected) */\n  get sessionClient(): SessionClient | null {\n    return this.state.sessionClient\n  }\n\n  /** Get current user address (null if not connected) */\n  get userAddress(): Address | null {\n    return this.state.userAddress\n  }\n\n  /** Get current session account address (null if not connected) */\n  get sessionAddress(): Address | null {\n    return this.state.sessionAddress\n  }\n\n  /** Check if session is ready (has delegation) */\n  get isReady(): boolean {\n    return this.state.isReady\n  }\n\n  /** Get wagmi config (for advanced use cases like wallet transactions) */\n  getWagmiConfig(): Config {\n    return this.wagmiConfig\n  }\n\n  /**\n   * Get the public client for read operations.\n   *\n   * This is the single source of truth for all chain reads.\n   * Use this client for:\n   * - Reading contract state\n   * - Checking balances\n   * - Waiting for transaction receipts\n   * - Any other read-only operations\n   *\n   * The client is created once in the constructor with the configured\n   * transport (WebSocket + HTTP fallback) and polling interval.\n   */\n  getPublicClient(): PublicClient {\n    return this._publicClient\n  }\n}\n"]}