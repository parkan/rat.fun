{"version":3,"sources":["../src/types/state.ts","../src/types/mud.ts","../src/session/core/storage.ts","../src/session/core/signer.ts","../src/session/core/account.ts","../src/bundler/paymaster.ts","../src/bundler/client.ts","../src/bundler/transport.ts","../src/session/core/client.ts","../src/session/delegation/check.ts","../src/session/patterns/eip712-signing.ts","../src/session/patterns/wallet-deployment.ts","../src/session/patterns/call-with-signature.ts","../src/session/delegation/setup.ts","../src/wallet/config.ts","../src/wallet/watcher.ts","../src/wallet/connection.ts","../src/EntryKit.ts"],"names":["EntryKitStatus","viem_createBundlerClient","getRecord","getAction","viem_writeContract","worldSystemsConfig","waitForTransactionReceipt"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * EntryKit connection and setup status\n *\n * Provides a single source of truth for the current state of EntryKit.\n * Transitions follow this flow:\n *\n * UNINITIALIZED → initialize() → DISCONNECTED\n *                                      ↓\n *                      connectWallet() ↓\n *                                      ↓\n *                                 CONNECTED\n *                                      ↓\n *                      setupSession()  ↓\n *                                      ↓\n *                             SETTING_UP_SESSION\n *                                      ↓\n *                                   READY\n *\n * Note: READY state can be reached directly from DISCONNECTED if reconnection succeeds.\n */\nexport enum EntryKitStatus {\n  /** EntryKit not yet initialized - call initializeEntryKit() */\n  UNINITIALIZED = \"uninitialized\",\n\n  /** EntryKit initialized but no wallet connected */\n  DISCONNECTED = \"disconnected\",\n\n  /** Wallet connection in progress */\n  CONNECTING = \"connecting\",\n\n  /** Wallet connected, but session setup needed (delegation not registered) */\n  CONNECTED = \"connected\",\n\n  /** Session setup in progress (registering delegation) */\n  SETTING_UP_SESSION = \"setting_up_session\",\n\n  /** Fully ready - session client available and delegation registered */\n  READY = \"ready\",\n\n  /** An error occurred */\n  ERROR = \"error\"\n}\n","import { resourceToHex } from \"@latticexyz/common\"\nimport { parseAbi, ClientConfig } from \"viem\"\nimport worldConfig from \"@latticexyz/world/mud.config\"\n\n/**\n * Default viem client configuration\n * Polling interval for watching blockchain state\n */\nexport const defaultClientConfig = {\n  pollingInterval: 250\n} as const satisfies Pick<ClientConfig, \"pollingInterval\">\n\n/**\n * MUD delegation control ID for \"unlimited\" delegation\n *\n * This is a resource ID that identifies the unlimited delegation control system.\n * When a user delegates to a session account with this ID, the session account\n * can call any system in the World on behalf of the user.\n *\n * Format: system resource with namespace=\"\" and name=\"unlimited\"\n */\nexport const unlimitedDelegationControlId = resourceToHex({\n  type: \"system\",\n  namespace: \"\",\n  name: \"unlimited\"\n})\n\n/**\n * MUD World table definitions from world config\n * Used to query World state (e.g., UserDelegationControl table)\n */\nexport const worldTables = worldConfig.namespaces.world.tables\n\n/**\n * Minimal World ABI for delegation registration\n * Full ABI is large, we only need this one function\n */\nexport const worldAbi = parseAbi([\n  \"function registerDelegation(address delegatee, bytes32 delegationControlId, bytes initCallData)\"\n])\n","import { Address, Hex } from \"viem\"\n\ntype SessionStore = {\n  signers: Record<string, string> // lowercase address → private key\n}\n\n/**\n * Session key storage using localStorage\n *\n * Manages persistent session private keys for each user address.\n * Keys are stored in localStorage and survive page refreshes.\n *\n * Storage format: { signers: { \"0xabc...\": \"0x123...\" } }\n * Storage key: \"entrykit:session-signers\"\n */\nexport class SessionStorage {\n  private cache: SessionStore\n  private readonly STORAGE_KEY = \"entrykit:session-signers\"\n\n  constructor() {\n    this.cache = this.load()\n  }\n\n  /**\n   * Load session store from localStorage\n   */\n  private load(): SessionStore {\n    if (typeof localStorage === \"undefined\") {\n      return { signers: {} }\n    }\n\n    const stored = localStorage.getItem(this.STORAGE_KEY)\n    if (!stored) {\n      return { signers: {} }\n    }\n\n    try {\n      return JSON.parse(stored)\n    } catch {\n      return { signers: {} }\n    }\n  }\n\n  /**\n   * Save session store to localStorage\n   */\n  private save(): void {\n    if (typeof localStorage === \"undefined\") return\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.cache))\n  }\n\n  /**\n   * Get session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @returns Private key if exists, undefined otherwise\n   */\n  getSigner(address: Address): Hex | undefined {\n    const key = address.toLowerCase()\n    return this.cache.signers[key] as Hex | undefined\n  }\n\n  /**\n   * Store session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @param privateKey Session private key to store\n   */\n  setSigner(address: Address, privateKey: Hex): void {\n    const key = address.toLowerCase()\n    this.cache.signers[key] = privateKey\n    this.save()\n  }\n\n  /**\n   * Remove session signer for a user address\n   *\n   * @param address User's wallet address\n   */\n  removeSigner(address: Address): void {\n    const key = address.toLowerCase()\n    delete this.cache.signers[key]\n    this.save()\n  }\n\n  /**\n   * Clear all session signers\n   */\n  clear(): void {\n    this.cache = { signers: {} }\n    this.save()\n  }\n}\n\n/**\n * Singleton session storage instance\n */\nexport const sessionStorage = new SessionStorage()\n","import { Address, Hex, isHex } from \"viem\"\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\"\nimport { sessionStorage } from \"./storage\"\n\n/**\n * Get or create session signer for a user address\n *\n * Session signers are persistent private keys stored in localStorage.\n * They're used as the owner of the session smart account.\n *\n * If no signer exists for this user:\n * - Attempts to migrate from old MUD AccountKit storage format\n * - Otherwise generates a fresh random private key\n * - Stores the key for future use\n *\n * @param userAddress User's wallet address\n * @returns LocalAccount (viem account from private key)\n */\nexport function getSessionSigner(userAddress: Address) {\n  let privateKey = sessionStorage.getSigner(userAddress)\n\n  if (!privateKey) {\n    // Attempt to migrate from legacy MUD AccountKit storage format\n    // This allows existing users to keep their session accounts\n    const deprecatedKey =\n      typeof localStorage !== \"undefined\"\n        ? localStorage\n            .getItem(`mud:appSigner:privateKey:${userAddress.toLowerCase()}`)\n            ?.replace(/^\"(.*)\"$/, \"$1\") // Remove JSON quotes if present\n        : null\n\n    // Use migrated key if valid, otherwise generate new random key\n    privateKey = (isHex(deprecatedKey) ? deprecatedKey : generatePrivateKey()) as Hex\n    sessionStorage.setSigner(userAddress, privateKey)\n  }\n\n  return privateKeyToAccount(privateKey)\n}\n","import { Address, Chain, Client, LocalAccount, Transport } from \"viem\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { toSimpleSmartAccount } from \"permissionless/accounts\"\nimport { getSessionSigner } from \"./signer\"\n\nexport type GetSessionAccountReturnType = {\n  readonly account: SmartAccount\n  readonly signer: LocalAccount\n}\n\nexport async function getSessionAccount<chain extends Chain>({\n  client,\n  userAddress\n}: {\n  client: Client<Transport, chain>\n  userAddress: Address\n}): Promise<GetSessionAccountReturnType> {\n  const signer = getSessionSigner(userAddress)\n  const account = await toSimpleSmartAccount({ client, owner: signer })\n  return { account, signer }\n}\n","import { Chain, Hex } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\n\n/**\n * Paymaster configuration\n *\n * Paymasters sponsor gas for user operations (ERC-4337).\n * Two types supported:\n *\n * - **simple**: Basic paymaster with just an address\n *   Returns paymaster address with empty data\n *\n * - **custom**: Advanced paymaster with client\n *   Uses provided PaymasterClient for dynamic sponsorship logic\n *   (e.g., Coinbase Paymaster, Pimlico, etc.)\n */\nexport type Paymaster =\n  | {\n      readonly type: \"simple\"\n      readonly address: Hex\n    }\n  | {\n      readonly type: \"custom\"\n      readonly address?: Hex\n      readonly paymasterClient: PaymasterClient\n    }\n\n/**\n * Get paymaster configuration for a chain\n *\n * Priority:\n * 1. Use paymasterOverride if provided (custom paymaster client)\n * 2. Check chain.contracts.paymaster for simple paymaster address\n * 3. Return undefined if no paymaster configured (user pays own gas)\n *\n * @param chain Chain configuration\n * @param paymasterOverride Optional custom paymaster client\n * @returns Paymaster config or undefined\n */\nexport function getPaymaster(\n  chain: Chain,\n  paymasterOverride?: PaymasterClient\n): Paymaster | undefined {\n  const contracts = chain.contracts ?? {}\n\n  // Use custom paymaster if provided (e.g., Coinbase Paymaster)\n  if (paymasterOverride) {\n    return {\n      type: \"custom\",\n      paymasterClient: paymasterOverride\n    }\n  }\n\n  // Check for simple paymaster in chain config\n  if (\"paymaster\" in contracts && contracts.paymaster != null) {\n    if (\"address\" in contracts.paymaster) {\n      return {\n        type: \"simple\",\n        address: contracts.paymaster.address\n      }\n    }\n  }\n\n  // No paymaster configured - user pays own gas\n  return undefined\n}\n","import { Transport, Chain, Client, RpcSchema, EstimateFeesPerGasReturnType } from \"viem\"\nimport {\n  BundlerClient,\n  BundlerClientConfig,\n  SmartAccount,\n  PaymasterClient,\n  createBundlerClient as viem_createBundlerClient\n} from \"viem/account-abstraction\"\nimport { defaultClientConfig } from \"../types\"\nimport { getPaymaster } from \"./paymaster\"\n\n/**\n * Create a bundler client for submitting ERC-4337 user operations\n *\n * A bundler client is a specialized viem client that:\n * - Submits user operations to the bundler RPC\n * - Handles gas estimation for user operations\n * - Integrates paymaster for gas sponsorship\n * - Manages smart account interactions\n *\n * This function wraps viem's createBundlerClient with:\n * - Automatic paymaster configuration from chain or override\n * - Custom fee estimation for Anvil (local dev)\n * - Default polling interval\n *\n * @param config Bundler client configuration\n * @returns Configured bundler client\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain = Chain,\n  account extends SmartAccount = SmartAccount,\n  client extends Client = Client,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  config: BundlerClientConfig<transport, chain, account, client, rpcSchema>\n): BundlerClient<transport, chain, account, client, rpcSchema> {\n  const client = config.client\n  if (!client) throw new Error(\"No `client` provided to `createBundlerClient`.\")\n\n  const chain = config.chain ?? client.chain\n  const paymaster = chain\n    ? getPaymaster(chain, config.paymaster as PaymasterClient | undefined)\n    : undefined\n\n  return viem_createBundlerClient({\n    ...defaultClientConfig,\n    // Configure paymaster for gas sponsorship\n    paymaster: paymaster\n      ? paymaster.type === \"custom\"\n        ? paymaster.paymasterClient // Use custom paymaster client (e.g., Coinbase)\n        : {\n            // Simple paymaster - just return address with empty data\n            getPaymasterData: async () => ({\n              paymaster: paymaster.address,\n              paymasterData: \"0x\"\n            })\n          }\n      : undefined,\n    // Custom fee estimation for certain chains\n    userOperation: {\n      estimateFeesPerGas: createFeeEstimator(client)\n    },\n    ...config\n  })\n}\n\n/**\n * Create custom fee estimator for specific chains\n *\n * Some chains need special handling for fee estimation:\n *\n * - **Anvil (31337)**: Hardcoded fees because Anvil's eth_maxPriorityFeePerGas\n *   returns a fixed value that doesn't match real chains\n *\n * - **Other chains**: Use viem's default fee estimation (works well)\n *\n * @param client Viem client\n * @returns Fee estimator function or undefined for default behavior\n */\nfunction createFeeEstimator(\n  client: Client\n): undefined | (() => Promise<EstimateFeesPerGasReturnType<\"eip1559\">>) {\n  if (!client.chain) return\n\n  // Anvil (local development) - use fixed fees\n  // See: https://github.com/foundry-rs/foundry/pull/8081#issuecomment-2402002485\n  if (client.chain.id === 31337) {\n    return async () => ({ maxFeePerGas: 100_000n, maxPriorityFeePerGas: 0n })\n  }\n\n  // All other chains - use viem's default fee estimation\n  return undefined\n}\n","import { Chain, http } from \"viem\"\n\n/**\n * Get bundler RPC transport for a chain\n *\n * Bundlers are special RPC endpoints that handle ERC-4337 user operations.\n * They submit user operations to the EntryPoint contract and handle gas sponsorship.\n *\n * The bundler URL must be configured in the chain's rpcUrls.bundler.http array.\n *\n * @param chain Chain configuration with bundler RPC URL\n * @returns HTTP transport for the bundler\n * @throws If chain doesn't have a bundler RPC URL configured\n */\nexport function getBundlerTransport(chain: Chain) {\n  const bundlerHttpUrl = chain.rpcUrls.bundler?.http[0]\n\n  if (bundlerHttpUrl) {\n    return http(bundlerHttpUrl)\n  }\n\n  throw new Error(`Chain ${chain.id} config did not include a bundler RPC URL.`)\n}\n","import { Account, Address, Chain, Client, LocalAccount, RpcSchema, Transport } from \"viem\"\nimport { smartAccountActions } from \"permissionless\"\nimport { callFrom, sendUserOperationFrom } from \"@latticexyz/world/internal\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { createBundlerClient } from \"../../bundler/client\"\nimport { SessionClient } from \"../../types\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { getBundlerTransport } from \"../../bundler/transport\"\n\n/**\n * Create session client with MUD World extensions\n *\n * Takes a standard ERC-4337 smart account and extends it with MUD-specific functionality:\n *\n * 1. **smartAccountActions** - Standard AA operations (sendUserOperation, etc.)\n * 2. **callFrom** - Routes writeContract calls through World.callFrom()\n *    - Automatically adds delegator context\n *    - World validates delegation before executing\n * 3. **sendUserOperationFrom** - Routes user operations through World\n * 4. **Context properties** - Adds userAddress, worldAddress, internal_signer\n *\n * The resulting SessionClient can call World systems on behalf of the user,\n * as long as delegation is registered.\n *\n * @param params Session client parameters\n * @returns SessionClient with MUD World extensions\n */\nexport async function getSessionClient({\n  userAddress,\n  sessionAccount,\n  sessionSigner,\n  worldAddress,\n  paymasterOverride\n}: {\n  userAddress: Address\n  sessionAccount: SmartAccount\n  sessionSigner: LocalAccount\n  worldAddress: Address\n  paymasterOverride?: PaymasterClient\n}): Promise<SessionClient> {\n  const client = sessionAccount.client\n  if (!clientHasChain(client)) {\n    throw new Error(\"Session account client had no associated chain.\")\n  }\n\n  // Create bundler client for submitting user operations\n  const bundlerClient = createBundlerClient({\n    transport: getBundlerTransport(client.chain),\n    client,\n    account: sessionAccount,\n    paymaster: paymasterOverride\n  })\n\n  // Extend with standard ERC-4337 smart account actions\n  const sessionClient = bundlerClient\n    .extend(smartAccountActions)\n    // Extend with MUD World delegation routing\n    // This intercepts writeContract calls and routes them through World.callFrom()\n    .extend(\n      callFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    // Extend with MUD World user operation routing\n    .extend(\n      sendUserOperationFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    // Add context properties for reference\n    .extend(() => ({ userAddress, worldAddress, internal_signer: sessionSigner }))\n\n  return sessionClient\n}\n\n/**\n * Type guard to ensure client has a chain\n */\nfunction clientHasChain<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  client: Client<transport, chain, account, rpcSchema>\n): client is Client<transport, Exclude<chain, undefined>, account, rpcSchema> {\n  return client.chain != null\n}\n","import { Address, Client } from \"viem\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport { unlimitedDelegationControlId, worldTables } from \"../../types\"\n\nexport type CheckDelegationParams = {\n  client: Client\n  worldAddress: Address\n  userAddress: Address\n  sessionAddress: Address\n  blockTag?: \"pending\" | \"latest\"\n}\n\n/**\n * Check if delegation exists in MUD World contract\n *\n * MUD World stores delegations in the UserDelegationControl table.\n * A delegation allows the session account (delegatee) to call World systems\n * on behalf of the user account (delegator).\n *\n * This function queries that table and checks if \"unlimited\" delegation exists,\n * which grants the session account full access to all systems.\n *\n * @param params Delegation check parameters\n * @returns true if unlimited delegation is registered, false otherwise\n */\nexport async function checkDelegation({\n  client,\n  worldAddress,\n  userAddress,\n  sessionAddress,\n  blockTag = \"pending\"\n}: CheckDelegationParams): Promise<boolean> {\n  // Query MUD Store table: UserDelegationControl[delegator][delegatee]\n  const record = await getRecord(client, {\n    address: worldAddress,\n    table: worldTables.UserDelegationControl,\n    key: { delegator: userAddress, delegatee: sessionAddress },\n    blockTag\n  })\n\n  // Check if the delegation type is \"unlimited\" (full system access)\n  return record.delegationControlId === unlimitedDelegationControlId\n}\n","import { Address, Chain, Client, Hex, OneOf, Transport, toHex } from \"viem\"\nimport { signTypedData } from \"viem/actions\"\nimport { callWithSignatureTypes } from \"@latticexyz/world-module-callwithsignature/internal\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport moduleConfig from \"@latticexyz/world-module-callwithsignature/mud.config\"\nimport { hexToResource } from \"@latticexyz/common\"\nimport { getAction } from \"viem/utils\"\nimport { ConnectedClient } from \"../../types\"\n\nexport type SignCallOptions<chain extends Chain = Chain> = {\n  userClient: ConnectedClient<chain>\n  worldAddress: Address\n  systemId: Hex\n  callData: Hex\n} & OneOf<{ nonce: bigint } | { client: Client<Transport, chain> }>\n\n/**\n * Sign a World system call using EIP-712 (for CallWithSignature pattern)\n *\n * This creates a signature that can be submitted by the session account to execute\n * a call on behalf of the user (EOA).\n *\n * Flow:\n * 1. **Fetch or use nonce** - Each user has a nonce in CallWithSignatureNonces table\n *    Prevents replay attacks\n *\n * 2. **Parse systemId** - MUD system IDs are resource IDs with namespace + name\n *    e.g., \"world:PlayerSystem\" → { namespace: \"world\", name: \"PlayerSystem\" }\n *\n * 3. **Sign EIP-712 message** - User signs typed data with:\n *    - Domain: World contract + chain ID\n *    - Message: signer, system, callData, nonce\n *\n * The resulting signature can be submitted to World.callWithSignature()\n * by the session account, which will validate and execute as the user.\n *\n * **Why this pattern?**\n * - EOAs can't pay gas via paymaster directly (not smart accounts)\n * - User signs message (free, no gas)\n * - Session account submits + pays gas via paymaster\n * - User gets gasless experience!\n *\n * @param options Sign options including user client and call details\n * @returns EIP-712 signature\n */\nexport async function signCall<chain extends Chain = Chain>({\n  userClient,\n  worldAddress,\n  systemId,\n  callData,\n  nonce: initialNonce,\n  client\n}: SignCallOptions<chain>) {\n  // Get nonce for replay protection\n  // Either use provided nonce or fetch from World contract\n  const nonce =\n    initialNonce ??\n    (client\n      ? (\n          await getRecord(client, {\n            address: worldAddress,\n            table: moduleConfig.tables.CallWithSignatureNonces,\n            key: { signer: userClient.account.address },\n            blockTag: \"pending\"\n          })\n        ).nonce\n      : 0n)\n\n  // Parse MUD system ID into namespace and name components\n  const { namespace: systemNamespace, name: systemName } = hexToResource(systemId)\n\n  // Sign EIP-712 typed data\n  // User signs this message, session account will submit it\n  return await getAction(\n    userClient,\n    signTypedData,\n    \"signTypedData\"\n  )({\n    account: userClient.account,\n    // EIP-712 domain bound to World contract and chain\n    domain: {\n      verifyingContract: worldAddress,\n      salt: toHex(userClient.chain.id, { size: 32 })\n    },\n    // MUD's CallWithSignature type definitions\n    types: callWithSignatureTypes,\n    primaryType: \"Call\",\n    // Message contains all call details + nonce\n    message: {\n      signer: userClient.account.address,\n      systemNamespace,\n      systemName,\n      callData,\n      nonce\n    }\n  })\n}\n","import { Address, Client } from \"viem\"\nimport { getCode, sendTransaction, waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\n\n/**\n * Smart wallet deployment utilities\n *\n * Handles counterfactual smart wallets (e.g., Coinbase Smart Wallet) that use\n * CREATE2 and exist at a deterministic address before deployment.\n */\n\n/**\n * Check if a smart wallet is deployed on-chain\n *\n * @param client Client to use for checking\n * @param address Wallet address to check\n * @returns True if deployed, false otherwise\n */\nexport async function isWalletDeployed(client: Client, address: Address): Promise<boolean> {\n  const code = await getAction(\n    client,\n    getCode,\n    \"getCode\"\n  )({\n    address\n  })\n\n  return code !== undefined && code !== \"0x\"\n}\n\n/**\n * Deploy a smart wallet using a factory contract\n *\n * This handles the deployment of counterfactual smart wallets. The wallet address\n * already exists (can receive funds) but needs on-chain deployment before it can\n * validate signatures or execute transactions.\n *\n * @param client Client to use for deployment transaction (usually session client with paymaster)\n * @param userAddress User's wallet address to deploy\n * @param factoryAddress Factory contract address that can deploy the wallet\n * @param factoryCalldata Deployment calldata for the factory\n */\nexport async function deployWallet(\n  client: Client,\n  userAddress: Address,\n  factoryAddress: Address,\n  factoryCalldata: Address\n): Promise<void> {\n  try {\n    const txHash = await getAction(\n      client,\n      sendTransaction,\n      \"sendTransaction\"\n    )({\n      account: client.account,\n      chain: client.chain,\n      to: factoryAddress,\n      data: factoryCalldata\n    })\n\n    // Wait for deployment confirmation\n    await getAction(\n      client,\n      waitForTransactionReceipt,\n      \"waitForTransactionReceipt\"\n    )({\n      hash: txHash\n    })\n\n    // Add delay for bundler/paymaster state to update\n    // After deployment, bundlers cache account state and need time to refresh\n    await new Promise(resolve => setTimeout(resolve, 2000))\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n\n    // If already deployed, that's fine\n    if (\n      errorMessage.includes(\"AA10\") ||\n      errorMessage.includes(\"already constructed\") ||\n      errorMessage.includes(\"already deployed\")\n    ) {\n      return\n    }\n\n    throw new Error(`Failed to deploy smart wallet: ${errorMessage}`)\n  }\n}\n\n/**\n * Deploy a smart wallet if it's not already deployed\n *\n * @param client Client to use for deployment\n * @param userAddress User's wallet address\n * @param factoryAddress Factory contract address\n * @param factoryCalldata Deployment calldata\n * @returns True if deployment was needed and completed, false if already deployed\n */\nexport async function deployWalletIfNeeded(\n  client: Client,\n  userAddress: Address,\n  factoryAddress: Address,\n  factoryCalldata: Address\n): Promise<boolean> {\n  const deployed = await isWalletDeployed(client, userAddress)\n\n  if (deployed) {\n    return false\n  }\n\n  await deployWallet(client, userAddress, factoryAddress, factoryCalldata)\n\n  // Verify deployment succeeded\n  const nowDeployed = await isWalletDeployed(client, userAddress)\n  if (!nowDeployed) {\n    throw new Error(\n      `Wallet deployment appeared to succeed but contract code not found at ${userAddress}`\n    )\n  }\n\n  return true\n}\n","import { Chain, parseErc6492Signature } from \"viem\"\nimport { writeContract as viem_writeContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { SignCallOptions, signCall } from \"./eip712-signing\"\nimport CallWithSignatureAbi from \"@latticexyz/world-module-callwithsignature/out/CallWithSignatureSystem.sol/CallWithSignatureSystem.abi.json\"\nimport { ConnectedClient } from \"../../types\"\nimport { deployWalletIfNeeded } from \"./wallet-deployment\"\n\nexport type CallWithSignatureOptions<chain extends Chain = Chain> = SignCallOptions<chain> & {\n  sessionClient: ConnectedClient\n}\n\n/**\n * Call a World system using signature-based execution (for EOAs and smart wallets)\n *\n * MUD's CallWithSignature pattern allows EOAs and smart wallets to execute gasless transactions:\n *\n * 1. User signs an EIP-712 message (free, off-chain)\n * 2. Session account submits the signature + call to World\n * 3. World's CallWithSignatureSystem validates the signature\n * 4. If valid, executes the call as the user (with user's identity)\n *\n * This enables gasless transactions - the session account pays gas via paymaster,\n * but the call executes with the user's permissions/identity.\n *\n * For undeployed smart wallets (e.g., new Coinbase Smart Wallet), this function\n * automatically detects ERC-6492 wrapped signatures and deploys the wallet using\n * the session account before submitting the call.\n *\n * Flow:\n *   User → signs message → Session Account → (deploys wallet if needed) → submits to World\n *   → World validates signature → executes as User\n *\n * @param options Call parameters including user client and session client\n * @returns Transaction hash\n */\nexport async function callWithSignature<chain extends Chain = Chain>({\n  sessionClient,\n  ...opts\n}: CallWithSignatureOptions<chain>) {\n  const rawSignature = await signCall(opts)\n\n  // Check for ERC-6492 wrapped signatures\n  const {\n    address: factoryAddress,\n    data: factoryCalldata,\n    signature\n  } = parseErc6492Signature(rawSignature)\n\n  let finalSignature = signature ?? rawSignature\n\n  if (factoryAddress != null) {\n    // ERC-6492 signature detected - deploy wallet if needed\n    console.log(\"[callWithSignature] ERC-6492 signature detected\")\n\n    await deployWalletIfNeeded(\n      sessionClient,\n      opts.userClient.account.address,\n      factoryAddress,\n      factoryCalldata\n    )\n\n    finalSignature = signature\n  }\n\n  // Submit transaction to World\n  try {\n    return await getAction(\n      sessionClient,\n      viem_writeContract,\n      \"writeContract\"\n    )({\n      address: opts.worldAddress,\n      abi: CallWithSignatureAbi,\n      functionName: \"callWithSignature\",\n      args: [opts.userClient.account.address, opts.systemId, opts.callData, finalSignature]\n    } as never)\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n\n    if (errorMessage.includes(\"AA10\") || errorMessage.includes(\"already constructed\")) {\n      throw new Error(\"Smart wallet was just deployed. Please try again.\")\n    }\n\n    throw error\n  }\n}\n","import { Hex, encodeFunctionData, zeroAddress, Client, Address } from \"viem\"\nimport {\n  sendUserOperation,\n  waitForUserOperationReceipt,\n  SmartAccount,\n  UserOperationReceipt\n} from \"viem/account-abstraction\"\nimport { waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport IBaseWorldAbi from \"@latticexyz/world/out/IBaseWorld.sol/IBaseWorld.abi.json\"\nimport { systemsConfig as worldSystemsConfig } from \"@latticexyz/world/mud.config\"\nimport { unlimitedDelegationControlId, worldAbi, SessionClient, ConnectedClient } from \"../../types\"\nimport { callWithSignature } from \"../patterns/call-with-signature\"\nimport { deployWalletIfNeeded, isWalletDeployed } from \"../patterns/wallet-deployment\"\n\n/**\n * Smart account with optional factory properties (internal use only)\n * Some smart account implementations add these properties dynamically\n */\ntype SmartAccountWithFactory = SmartAccount & {\n  factory?: Address\n  factoryData?: Hex\n}\n\nexport type SetupSessionStatus =\n  | { type: \"checking_wallet\"; message: string }\n  | { type: \"deploying_wallet\"; message: string }\n  | { type: \"wallet_deployed\"; message: string }\n  | { type: \"registering_delegation\"; message: string }\n  | { type: \"deploying_session\"; message: string }\n  | { type: \"complete\"; message: string }\n  | { type: \"error\"; message: string; error?: Error }\n\nexport type SetupSessionParams = {\n  /** Public client for reading blockchain state */\n  client: Client\n  /** User's connected wallet client (EOA or Smart Account) */\n  userClient: ConnectedClient\n  /** Session smart account client with MUD extensions */\n  sessionClient: SessionClient\n  /** MUD World contract address */\n  worldAddress: Hex\n  /** Whether to register delegation (default: true) */\n  registerDelegation?: boolean\n  /** Progress callback for status updates */\n  onStatus?: (status: SetupSessionStatus) => void\n}\n\n/**\n * Setup session by registering delegation and deploying session account\n *\n * Flow differs based on wallet type:\n *\n * **Smart Account Wallet:**\n * - Sends user operation to register delegation\n * - User's smart account submits the operation\n *\n * **EOA (Externally Owned Account):**\n * - Uses CallWithSignature pattern (gasless for user)\n * - User signs a message (EIP-712)\n * - Session account submits the signature + call\n * - World validates signature and executes as user\n *\n * **Finally:**\n * - Deploys session account if not yet deployed (via empty user operation)\n *\n * @param params Setup parameters\n */\nexport async function setupSession({\n  client,\n  userClient,\n  sessionClient,\n  worldAddress,\n  registerDelegation = true,\n  onStatus\n}: SetupSessionParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address\n  const userAddress = userClient.account.address\n\n  console.log(\"[entrykit-drawbridge] Setup session:\", {\n    userAddress,\n    accountType: userClient.account.type\n  })\n\n  if (userClient.account.type === \"smart\") {\n    // ===== Smart Account Flow =====\n    onStatus?.({ type: \"checking_wallet\", message: \"Checking wallet status...\" })\n\n    // CHECK AND DEPLOY USER'S WALLET IF NEEDED\n    const account = userClient.account as SmartAccountWithFactory\n    const factoryArgs = await account.getFactoryArgs()\n    const hasFactoryData = factoryArgs.factory && factoryArgs.factoryData\n\n    console.log(\"[entrykit-drawbridge] Smart wallet check:\", { hasFactoryData, userAddress })\n\n    const alreadyDeployed = await isWalletDeployed(sessionClient, userAddress)\n\n    if (alreadyDeployed && hasFactoryData) {\n      // Wallet deployed but has factory data - remove it\n      console.log(\"[entrykit-drawbridge] Removing factory data from deployed wallet\")\n      onStatus?.({ type: \"wallet_deployed\", message: \"Wallet ready\" })\n\n      delete account.factory\n      delete account.factoryData\n      account.factory = undefined\n      account.factoryData = undefined\n\n      console.log(\"[entrykit-drawbridge] Factory removed:\", { stillHasFactory: !!account.factory })\n    } else if (!alreadyDeployed && hasFactoryData) {\n      // Wallet not deployed - deploy it\n      console.log(\"[entrykit-drawbridge] Deploying user wallet...\")\n      onStatus?.({ type: \"deploying_wallet\", message: \"Deploying wallet (one-time setup)...\" })\n\n      await deployWalletIfNeeded(\n        sessionClient,\n        userAddress,\n        factoryArgs.factory!,\n        factoryArgs.factoryData!\n      )\n\n      onStatus?.({ type: \"wallet_deployed\", message: \"Wallet deployed successfully!\" })\n\n      // Remove factory/factoryData after deployment\n      delete account.factory\n      delete account.factoryData\n      account.factory = undefined\n      account.factoryData = undefined\n\n      console.log(\"[entrykit-drawbridge] Wallet deployed, factory removed\")\n    } else {\n      onStatus?.({ type: \"wallet_deployed\", message: \"Wallet ready\" })\n    }\n\n    // Proceed with delegation registration\n    const calls = []\n\n    if (registerDelegation) {\n      calls.push({\n        to: worldAddress,\n        abi: worldAbi,\n        functionName: \"registerDelegation\",\n        args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n      })\n    }\n\n    if (!calls.length) return\n\n    onStatus?.({ type: \"registering_delegation\", message: \"Setting up session...\" })\n\n    // Final check: if factory/factoryData still present, try aggressive removal\n    const accountBeforeSend = userClient.account as SmartAccountWithFactory\n    console.log(\"[entrykit-drawbridge] Before sendUserOperation:\", {\n      hasFactory: !!accountBeforeSend.factory,\n      hasFactoryData: !!accountBeforeSend.factoryData\n    })\n\n    if (accountBeforeSend.factory || accountBeforeSend.factoryData) {\n      console.warn(\"[entrykit-drawbridge] Factory still present, attempting aggressive removal...\")\n\n      try {\n        Object.defineProperty(accountBeforeSend, \"factory\", {\n          value: undefined,\n          writable: true,\n          configurable: true\n        })\n        Object.defineProperty(accountBeforeSend, \"factoryData\", {\n          value: undefined,\n          writable: true,\n          configurable: true\n        })\n      } catch (err) {\n        console.error(\"[entrykit-drawbridge] Could not remove factory (readonly property)\")\n      }\n    }\n\n    try {\n      const hash = await getAction(userClient, sendUserOperation, \"sendUserOperation\")({ calls })\n      console.log(\"[entrykit-drawbridge] User operation sent:\", hash)\n\n      const receipt = await getAction(\n        userClient,\n        waitForUserOperationReceipt,\n        \"waitForUserOperationReceipt\"\n      )({ hash })\n\n      if (!receipt.success) {\n        throw new Error(\"User operation failed during session setup\")\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error)\n      console.error(\"[entrykit-drawbridge] User operation error:\", errorMessage)\n\n      if (errorMessage.includes(\"AA10\") || errorMessage.includes(\"already constructed\")) {\n        const helpfulError = new Error(\n          \"Smart wallet deployment conflict. Please try again - it should work on the second attempt.\"\n        )\n        onStatus?.({ type: \"error\", message: \"Please try again\", error: helpfulError })\n        throw helpfulError\n      }\n\n      onStatus?.({ type: \"error\", message: \"Session setup failed\", error: error as Error })\n      throw error\n    }\n  } else {\n    // ===== EOA Flow (CallWithSignature) =====\n    const txs: Hex[] = []\n\n    if (registerDelegation) {\n      const tx = await callWithSignature({\n        client: sessionClient,\n        userClient,\n        sessionClient,\n        worldAddress,\n        systemId: worldSystemsConfig.systems.RegistrationSystem.systemId,\n        callData: encodeFunctionData({\n          abi: IBaseWorldAbi,\n          functionName: \"registerDelegation\",\n          args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n        })\n      })\n      txs.push(tx)\n    }\n\n    if (!txs.length) return\n\n    for (const hash of txs) {\n      const receipt = await getAction(\n        client,\n        waitForTransactionReceipt,\n        \"waitForTransactionReceipt\"\n      )({ hash })\n\n      if (receipt.status === \"reverted\") {\n        throw new Error(\"Delegation registration transaction reverted\")\n      }\n    }\n  }\n\n  // ===== Deploy Session Account =====\n  const sessionDeployed = await sessionClient.account.isDeployed?.()\n  console.log(\"[entrykit-drawbridge] Session account deployed:\", sessionDeployed)\n\n  if (!sessionDeployed) {\n    onStatus?.({ type: \"deploying_session\", message: \"Finalizing session setup...\" })\n\n    try {\n      const hash = await getAction(\n        sessionClient,\n        sendUserOperation,\n        \"sendUserOperation\"\n      )({\n        calls: [{ to: zeroAddress }]\n      })\n\n      console.log(\"[entrykit-drawbridge] Session deploy tx:\", hash)\n\n      // Add timeout\n      const receiptPromise = getAction(\n        sessionClient,\n        waitForUserOperationReceipt,\n        \"waitForUserOperationReceipt\"\n      )({ hash })\n\n      const timeoutPromise = new Promise((_, reject) =>\n        setTimeout(() => reject(new Error(\"Session deployment timeout after 30s\")), 30000)\n      )\n\n      const receipt = (await Promise.race([receiptPromise, timeoutPromise])) as UserOperationReceipt\n\n      if (!receipt.success) {\n        throw new Error(\"Failed to deploy session account\")\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error)\n      console.error(\"[entrykit-drawbridge] Session deployment error:\", errorMsg)\n\n      // Check if timeout but actually deployed\n      if (errorMsg.includes(\"timeout\")) {\n        const nowDeployed = await sessionClient.account.isDeployed?.()\n        if (nowDeployed) {\n          console.log(\"[entrykit-drawbridge] Session deployed despite timeout\")\n          onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n          return\n        }\n      }\n\n      onStatus?.({ type: \"error\", message: \"Session deployment failed\", error: error as Error })\n      throw error\n    }\n  }\n\n  console.log(\"[entrykit-drawbridge] Setup session complete\")\n  onStatus?.({ type: \"complete\", message: \"Session setup complete!\" })\n}\n","import { Chain, Transport } from \"viem\"\nimport { createConfig, createStorage, type Config, type CreateConnectorFn } from \"@wagmi/core\"\n\n/**\n * Configuration parameters for creating wagmi config\n */\nexport type WalletConfigParams = {\n  /** Supported chains */\n  chains: readonly [Chain, ...Chain[]]\n  /** Transport configuration per chain */\n  transports: Record<number, Transport>\n  /** Wallet connectors (injected, walletConnect, etc.) */\n  connectors: CreateConnectorFn[]\n  /** Optional polling interval in milliseconds */\n  pollingInterval?: number\n}\n\n/**\n * Create wagmi configuration for wallet connection\n *\n * Configures wagmi with:\n * - Chains and transports for RPC communication\n * - Wallet connectors (MetaMask, WalletConnect, Coinbase, etc.)\n * - localStorage persistence for connection state\n * - Optional polling interval for state updates\n *\n * @param params Configuration parameters\n * @returns Wagmi Config instance\n */\nexport function createWalletConfig({\n  chains,\n  transports,\n  connectors,\n  pollingInterval\n}: WalletConfigParams): Config {\n  return createConfig({\n    chains,\n    transports,\n    connectors,\n    pollingInterval,\n    storage: createStorage({\n      storage: typeof window !== \"undefined\" ? window.localStorage : undefined\n    })\n  })\n}\n","import { watchAccount, type Config } from \"@wagmi/core\"\nimport type { GetAccountReturnType } from \"@wagmi/core\"\n\n/**\n * Account change handler callback\n *\n * Called whenever the connected wallet account changes (connect, disconnect, switch).\n */\nexport type AccountChangeHandler = (account: GetAccountReturnType) => void | Promise<void>\n\n/**\n * Cleanup function returned by setupAccountWatcher\n *\n * Call this to stop watching for account changes.\n */\nexport type UnwatchAccount = () => void\n\n/**\n * Setup wagmi account watcher\n *\n * Watches for wallet connection state changes and calls the provided handler.\n *\n * Changes detected:\n * - Wallet connected\n * - Wallet disconnected\n * - Account switched\n * - Chain switched\n *\n * @param wagmiConfig Wagmi configuration instance\n * @param onChange Handler called on account changes\n * @returns Cleanup function to stop watching\n *\n * @example\n * ```typescript\n * const unwatch = setupAccountWatcher(wagmiConfig, async (account) => {\n *   if (account.isConnected) {\n *     console.log(\"Connected:\", account.address)\n *     await handleConnection(account)\n *   } else {\n *     console.log(\"Disconnected\")\n *     await handleDisconnection()\n *   }\n * })\n *\n * // Later, stop watching\n * unwatch()\n * ```\n */\nexport function setupAccountWatcher(\n  wagmiConfig: Config,\n  onChange: AccountChangeHandler\n): UnwatchAccount {\n  return watchAccount(wagmiConfig, {\n    onChange: account => {\n      console.log(\"[wallet] Account change:\", {\n        isConnected: account.isConnected,\n        address: account.address\n      })\n\n      // Call handler (may be async)\n      const result = onChange(account)\n      if (result instanceof Promise) {\n        result.catch(err => {\n          console.error(\"[wallet] Account change handler failed:\", err)\n        })\n      }\n    }\n  })\n}\n","import { reconnect, connect, disconnect, getConnectors, getAccount, type Config } from \"@wagmi/core\"\n\n/**\n * Result of reconnection attempt\n */\nexport type ReconnectResult = {\n  /** Whether reconnection was successful */\n  reconnected: boolean\n  /** Connected account address if reconnected */\n  address?: `0x${string}`\n}\n\n/**\n * Attempt to reconnect to previously connected wallet\n *\n * Checks localStorage for previous connection state and attempts to restore it.\n * This should be called during initialization.\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Reconnection result\n *\n * @example\n * ```typescript\n * const result = await attemptReconnect(wagmiConfig)\n * if (result.reconnected) {\n *   console.log(\"Reconnected to:\", result.address)\n *   // Handle reconnected state\n * } else {\n *   console.log(\"No previous connection\")\n *   // Start in disconnected state\n * }\n * ```\n */\nexport async function attemptReconnect(wagmiConfig: Config): Promise<ReconnectResult> {\n  try {\n    await reconnect(wagmiConfig)\n\n    const account = getAccount(wagmiConfig)\n    if (account.isConnected && account.address) {\n      console.log(\"[wallet] Reconnection successful:\", account.address)\n      return {\n        reconnected: true,\n        address: account.address\n      }\n    }\n\n    console.log(\"[wallet] Reconnected but no account\")\n    return { reconnected: false }\n  } catch (err) {\n    console.log(\"[wallet] No previous connection to restore\")\n    return { reconnected: false }\n  }\n}\n\n/**\n * Connect to a wallet by connector ID\n *\n * @param wagmiConfig Wagmi configuration instance\n * @param connectorId Connector ID to connect to\n * @param chainId Optional chain ID to connect on\n * @throws If connector not found or connection fails\n *\n * @example\n * ```typescript\n * try {\n *   await connectWallet(wagmiConfig, \"injected\", 8453)\n *   console.log(\"Connected successfully\")\n * } catch (err) {\n *   if (err.name === \"ConnectorAlreadyConnectedError\") {\n *     console.log(\"Already connected\")\n *   } else {\n *     console.error(\"Connection failed:\", err)\n *   }\n * }\n * ```\n */\nexport async function connectWallet(\n  wagmiConfig: Config,\n  connectorId: string,\n  chainId?: number\n): Promise<void> {\n  const connectors = getConnectors(wagmiConfig)\n  const connector = connectors.find(c => c.id === connectorId)\n\n  if (!connector) {\n    throw new Error(`Connector not found: ${connectorId}`)\n  }\n\n  console.log(\"[wallet] Connecting to wallet:\", connectorId)\n\n  await connect(wagmiConfig, {\n    connector,\n    chainId\n  })\n\n  console.log(\"[wallet] Connection initiated\")\n}\n\n/**\n * Disconnect the currently connected wallet\n *\n * Clears wagmi connection state and localStorage.\n *\n * @param wagmiConfig Wagmi configuration instance\n *\n * @example\n * ```typescript\n * await disconnectWallet(wagmiConfig)\n * console.log(\"Disconnected\")\n * ```\n */\nexport async function disconnectWallet(wagmiConfig: Config): Promise<void> {\n  console.log(\"[wallet] Disconnecting...\")\n\n  try {\n    await disconnect(wagmiConfig)\n    console.log(\"[wallet] Disconnected successfully\")\n  } catch (err) {\n    console.error(\"[wallet] Disconnect error:\", err)\n    throw err\n  }\n}\n\n/**\n * Get current account information\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Current account state\n *\n * @example\n * ```typescript\n * const account = getCurrentAccount(wagmiConfig)\n * if (account.isConnected) {\n *   console.log(\"Connected:\", account.address)\n * }\n * ```\n */\nexport function getCurrentAccount(wagmiConfig: Config) {\n  return getAccount(wagmiConfig)\n}\n\n/**\n * Get list of available wallet connectors\n *\n * @param wagmiConfig Wagmi configuration instance\n * @returns Array of available connectors\n *\n * @example\n * ```typescript\n * const connectors = getAvailableConnectors(wagmiConfig)\n * console.log(\"Available wallets:\", connectors.map(c => c.name))\n * ```\n */\nexport function getAvailableConnectors(wagmiConfig: Config) {\n  return getConnectors(wagmiConfig)\n}\n","import { Address, Chain, Client, Transport, Account } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { SessionClient, EntryKitStatus } from \"./types\"\nimport { getSessionSigner } from \"./session/core/signer\"\nimport { getSessionAccount } from \"./session/core/account\"\nimport { getSessionClient } from \"./session/core/client\"\nimport { checkDelegation } from \"./session/delegation/check\"\nimport { setupSession, type SetupSessionStatus } from \"./session/delegation/setup\"\nimport { sessionStorage } from \"./session/core/storage\"\nimport { getConnectorClient, type Config, type CreateConnectorFn } from \"@wagmi/core\"\nimport {\n  createWalletConfig,\n  setupAccountWatcher,\n  attemptReconnect,\n  connectWallet as walletConnect,\n  disconnectWallet as walletDisconnect,\n  getAvailableConnectors as walletGetAvailableConnectors\n} from \"./wallet\"\n\n/**\n * Configuration for EntryKit instance\n */\nexport type EntryKitConfig = {\n  /** Chain ID to operate on */\n  chainId: number\n  /** Supported chains */\n  chains: readonly [Chain, ...Chain[]]\n  /** Transport configuration per chain */\n  transports: Record<number, Transport>\n  /** Wallet connectors (injected, walletConnect, etc.) */\n  connectors: CreateConnectorFn[]\n  /** MUD World contract address (optional if skipSessionSetup is true) */\n  worldAddress?: Address\n  /** Optional paymaster client for sponsored transactions */\n  paymasterClient?: PaymasterClient\n  /** Optional polling interval for wagmi (in ms) */\n  pollingInterval?: number\n  /** Optional app name for wallet connectors */\n  appName?: string\n  /**\n   * Skip session setup entirely - wallet connection only mode\n   * Use this for apps that don't need MUD delegation/session accounts.\n   * When true:\n   * - No session account created\n   * - No delegation registration\n   * - Only provides connected wallet client via wagmi\n   * - worldAddress is optional\n   * @default false\n   */\n  skipSessionSetup?: boolean\n}\n\n/**\n * Current state of the EntryKit instance\n * Updated reactively and broadcast to subscribers\n */\nexport type EntryKitState = {\n  /** Current status of EntryKit - single source of truth */\n  status: EntryKitStatus\n  /** Session client with MUD World extensions, null if not connected */\n  sessionClient: SessionClient | null\n  /** Original user's wallet address, null if not connected */\n  userAddress: Address | null\n  /** Session smart account address, null if not connected */\n  sessionAddress: Address | null\n  /** Whether session has delegation registered and is ready to use */\n  isReady: boolean\n}\n\n/**\n * Result of checking session prerequisites\n */\nexport type PrerequisiteStatus = {\n  /** Whether delegation is registered in World contract */\n  hasDelegation: boolean\n  /** Whether session is fully ready (same as hasDelegation) */\n  isReady: boolean\n}\n\ntype StateListener = (state: EntryKitState) => void\ntype Unsubscribe = () => void\n\n/**\n * Connector info for UI display\n */\nexport type ConnectorInfo = {\n  id: string\n  name: string\n  type: string\n}\n\n/**\n * entrykit-drawbridge - Stripped down headless version of @latticexyz/entrykit\n *\n * Provides complete wallet connection and session management:\n * - Wagmi integration (connectors, account watching, reconnection)\n * - ERC-4337 session account creation\n * - MUD World delegation registration\n * - Reactive state management (framework-agnostic)\n * - Gasless transaction support via paymaster\n *\n * Usage:\n * ```typescript\n * const entrykit = new EntryKit({\n *   chainId: 8453,\n *   chains: [baseChain],\n *   transports: { 8453: http() },\n *   connectors: [injected()],\n *   worldAddress: \"0x...\"\n * });\n *\n * // Initialize (await reconnection, setup watchers)\n * await entrykit.initialize();\n *\n * // Get available wallets\n * const wallets = entrykit.getAvailableConnectors();\n *\n * // Connect to wallet\n * await entrykit.connectWallet(wallets[0].id);\n *\n * // Setup delegation if needed\n * if (!entrykit.isReady) {\n *   await entrykit.setupSession();\n * }\n *\n * // Disconnect\n * await entrykit.disconnectWallet();\n * ```\n */\nexport class EntryKit {\n  private config: EntryKitConfig\n  private state: EntryKitState\n  private listeners = new Set<StateListener>()\n  private wagmiConfig: Config\n  private accountWatcherCleanup: (() => void) | null = null\n  private isConnecting = false\n  private isDisconnecting = false\n\n  constructor(config: EntryKitConfig) {\n    this.config = config\n    this.state = {\n      status: EntryKitStatus.UNINITIALIZED,\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false\n    }\n\n    // Create wagmi config\n    this.wagmiConfig = createWalletConfig({\n      chains: config.chains,\n      transports: config.transports,\n      connectors: config.connectors,\n      pollingInterval: config.pollingInterval\n    })\n  }\n\n  /**\n   * Initialize EntryKit (await reconnection and setup account watcher)\n   *\n   * This should be called once after construction and awaited.\n   * It will attempt to reconnect to a previously connected wallet.\n   */\n  async initialize(): Promise<void> {\n    console.log(\"[entrykit-drawbridge] Initializing...\")\n\n    // Attempt to reconnect to previously connected wallet\n    const result = await attemptReconnect(this.wagmiConfig)\n\n    if (!result.reconnected) {\n      // No reconnection - set status to DISCONNECTED\n      this.updateState({ status: EntryKitStatus.DISCONNECTED })\n    }\n\n    // Setup account watcher for future changes\n    this.setupAccountWatcher()\n\n    // If reconnection succeeded, manually handle the initial connection\n    // (the watcher won't fire for connections that happened before it was set up)\n    if (result.reconnected && result.address) {\n      console.log(\"[entrykit-drawbridge] Processing reconnected wallet:\", result.address)\n      await this.handleWalletConnection()\n    }\n\n    console.log(\"[entrykit-drawbridge] Initialization complete\")\n  }\n\n  // ===== Reactive State Management =====\n\n  /**\n   * Subscribe to state changes\n   *\n   * The listener will be called immediately with the current state,\n   * and again whenever the state changes.\n   *\n   * @param listener Function to call on state changes\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = entrykit.subscribe((state) => {\n   *   if (state.sessionClient) {\n   *     console.log(\"Session ready:\", state.sessionClient.account.address);\n   *   }\n   * });\n   *\n   * // Later, stop listening\n   * unsubscribe();\n   * ```\n   */\n  subscribe(listener: StateListener): Unsubscribe {\n    this.listeners.add(listener)\n    listener(this.state) // Immediate callback with current state\n    return () => this.listeners.delete(listener)\n  }\n\n  /**\n   * Get current state (non-reactive snapshot)\n   *\n   * For reactive updates, use subscribe() instead.\n   */\n  getState(): EntryKitState {\n    return { ...this.state }\n  }\n\n  private updateState(updates: Partial<EntryKitState>): void {\n    this.state = { ...this.state, ...updates }\n    this.notify()\n  }\n\n  private notify(): void {\n    this.listeners.forEach(listener => listener(this.state))\n  }\n\n  /**\n   * Setup wagmi account watcher to handle connection/disconnection\n   * Called automatically by initialize()\n   */\n  private setupAccountWatcher(): void {\n    const unwatch = setupAccountWatcher(this.wagmiConfig, async account => {\n      // Handle disconnection\n      if (!account.isConnected) {\n        console.log(\"[entrykit-drawbridge] Wallet disconnected\")\n        this.updateState({\n          status: EntryKitStatus.DISCONNECTED,\n          sessionClient: null,\n          userAddress: null,\n          sessionAddress: null,\n          isReady: false\n        })\n        this.isConnecting = false\n        return\n      }\n\n      // Ignore connection attempts while disconnecting to prevent deadlock\n      if (this.isDisconnecting) {\n        console.log(\"[entrykit-drawbridge] Ignoring connection attempt during disconnect\")\n        return\n      }\n\n      // Handle connection\n      if (this.isConnecting) {\n        console.log(\"[entrykit-drawbridge] Already processing connection\")\n        return\n      }\n\n      if (!account.connector || !account.address) {\n        return\n      }\n\n      try {\n        this.isConnecting = true\n        await this.handleWalletConnection()\n      } catch (err) {\n        console.error(\"[entrykit-drawbridge] Connection handler failed:\", err)\n      } finally {\n        this.isConnecting = false\n      }\n    })\n\n    this.accountWatcherCleanup = unwatch\n  }\n\n  /**\n   * Internal handler for wallet connection\n   * Called when wagmi detects a connected account\n   */\n  private async handleWalletConnection(): Promise<void> {\n    // Get wallet client from wagmi\n    let userClient: Client\n    try {\n      userClient = await getConnectorClient(this.wagmiConfig)\n    } catch (err) {\n      console.log(\"[entrykit-drawbridge] Could not get connector client\")\n      return\n    }\n\n    if (!userClient.account || !userClient.chain) {\n      console.log(\"[entrykit-drawbridge] Wallet client missing account or chain\")\n      return\n    }\n\n    const userAddress = userClient.account.address\n    console.log(\"[entrykit-drawbridge] Wallet connected:\", userAddress)\n\n    // If skipSessionSetup is true, just store the user address and mark as READY\n    // No session account, no delegation - just wallet connection\n    if (this.config.skipSessionSetup) {\n      console.log(\"[entrykit-drawbridge] Skipping session setup (wallet-only mode)\")\n      this.updateState({\n        status: EntryKitStatus.READY,\n        sessionClient: null,\n        userAddress,\n        sessionAddress: null,\n        isReady: true\n      })\n      return\n    }\n\n    // Full session setup flow (MUD delegation)\n    console.log(\"[entrykit-drawbridge] Setting up session for address:\", userAddress)\n\n    // Get or create persistent session signer from localStorage\n    const signer = getSessionSigner(userAddress)\n\n    // Create ERC-4337 SimpleAccount smart wallet\n    // TypeScript: We've already checked chain exists on line 298, so cast is safe\n    const { account } = await getSessionAccount({\n      client: userClient as Client<Transport, Chain, Account>,\n      userAddress\n    })\n\n    // Create session client with MUD World callFrom/sendUserOperationFrom extensions\n    const sessionClient = await getSessionClient({\n      userAddress,\n      sessionAccount: account,\n      sessionSigner: signer,\n      worldAddress: this.config.worldAddress!,\n      paymasterOverride: this.config.paymasterClient\n    })\n\n    // Check if delegation already exists BEFORE notifying listeners\n    // This prevents UI flash where sessionClient exists but isReady is unknown\n    const hasDelegation = await checkDelegation({\n      client: sessionClient,\n      worldAddress: this.config.worldAddress!,\n      userAddress,\n      sessionAddress: account.address\n    })\n\n    // Update state once with complete information\n    // Set status to READY if delegation exists, CONNECTED if not\n    this.updateState({\n      status: hasDelegation ? EntryKitStatus.READY : EntryKitStatus.CONNECTED,\n      sessionClient,\n      userAddress,\n      sessionAddress: account.address,\n      isReady: hasDelegation\n    })\n\n    console.log(\"[entrykit-drawbridge] Session connection complete, isReady:\", hasDelegation)\n  }\n\n  // ===== Public API =====\n\n  /**\n   * Get available wallet connectors for UI display\n   *\n   * @returns Array of connector info (id, name, type)\n   */\n  getAvailableConnectors(): ConnectorInfo[] {\n    const connectors = walletGetAvailableConnectors(this.wagmiConfig)\n    return connectors.map(c => ({\n      id: c.id,\n      name: c.name,\n      type: c.type\n    }))\n  }\n\n  /**\n   * Connect to a wallet by connector ID\n   *\n   * This will:\n   * 1. Connect via wagmi\n   * 2. Account watcher will automatically handle EntryKit session creation\n   *\n   * @param connectorId Connector ID (from getAvailableConnectors())\n   * @throws If connector not found or connection fails\n   */\n  async connectWallet(connectorId: string): Promise<void> {\n    console.log(\"[entrykit-drawbridge] Connecting to wallet:\", connectorId)\n\n    // Set status to CONNECTING\n    this.updateState({ status: EntryKitStatus.CONNECTING })\n\n    try {\n      await walletConnect(this.wagmiConfig, connectorId, this.config.chainId)\n    } catch (err) {\n      // If already connected, that's fine\n      if (err instanceof Error && err.name === \"ConnectorAlreadyConnectedError\") {\n        console.log(\"[entrykit-drawbridge] Already connected\")\n        return\n      }\n      // Reset to DISCONNECTED on error\n      this.updateState({ status: EntryKitStatus.DISCONNECTED })\n      throw err\n    }\n\n    // Account watcher will handle the rest and set appropriate status\n  }\n\n  /**\n   * Disconnect wallet and clear session\n   *\n   * This will:\n   * 1. Disconnect via wagmi\n   * 2. Account watcher will automatically clear EntryKit state\n   */\n  async disconnectWallet(): Promise<void> {\n    console.log(\"[entrykit-drawbridge] disconnectWallet() called\")\n    console.log(\"[entrykit-drawbridge] Current state:\", this.state)\n    console.log(\"[entrykit-drawbridge] Calling wagmi disconnect()...\")\n\n    try {\n      this.isDisconnecting = true\n      await walletDisconnect(this.wagmiConfig)\n      console.log(\"[entrykit-drawbridge] Wallet disconnected\")\n    } catch (err) {\n      console.error(\"[entrykit-drawbridge] Disconnect error:\", err)\n      throw err\n    } finally {\n      this.isDisconnecting = false\n    }\n\n    console.log(\"[entrykit-drawbridge] Disconnect complete\")\n  }\n\n  /**\n   * Check if session is ready to use\n   *\n   * Queries the MUD World contract to check if delegation is registered\n   * between the user's account and the session account.\n   *\n   * @returns Delegation status\n   */\n  async checkPrerequisites(): Promise<PrerequisiteStatus> {\n    if (!this.state.sessionClient) {\n      return { hasDelegation: false, isReady: false }\n    }\n\n    const hasDelegation = await checkDelegation({\n      client: this.state.sessionClient,\n      worldAddress: this.config.worldAddress!,\n      userAddress: this.state.userAddress!,\n      sessionAddress: this.state.sessionAddress!\n    })\n\n    this.updateState({ isReady: hasDelegation })\n\n    return { hasDelegation, isReady: hasDelegation }\n  }\n\n  /**\n   * Setup session by registering delegation and deploying account\n   *\n   * This will:\n   * 1. Get current wallet client from wagmi\n   * 2. Register delegation in MUD World contract (user delegates to session)\n   * 3. Deploy session smart account if not already deployed\n   *\n   * User will need to sign a transaction (EOA) or user operation (smart account).\n   *\n   * @throws If not connected (call connectWallet() first)\n   */\n  async setupSession(onStatus?: (status: SetupSessionStatus) => void): Promise<void> {\n    if (this.config.skipSessionSetup) {\n      throw new Error(\n        \"Cannot setup session when skipSessionSetup is true. This EntryKit instance is in wallet-only mode.\"\n      )\n    }\n\n    if (!this.state.sessionClient) {\n      throw new Error(\"Not connected. Call connectWallet() first.\")\n    }\n\n    console.log(\"[entrykit-drawbridge] Setting up session (registering delegation)...\")\n\n    // Set status to SETTING_UP_SESSION\n    this.updateState({ status: EntryKitStatus.SETTING_UP_SESSION })\n\n    // Get current wallet client from wagmi\n    const userClient = await getConnectorClient(this.wagmiConfig)\n\n    try {\n      await setupSession({\n        client: userClient,\n        userClient,\n        sessionClient: this.state.sessionClient,\n        worldAddress: this.config.worldAddress!,\n        onStatus\n      })\n\n      // Session setup complete - set status to READY\n      this.updateState({ status: EntryKitStatus.READY, isReady: true })\n\n      console.log(\"[entrykit-drawbridge] Session setup complete\")\n    } catch (err) {\n      // Reset to CONNECTED on error\n      this.updateState({ status: EntryKitStatus.CONNECTED })\n      throw err\n    }\n  }\n\n  /**\n   * Cleanup and destroy EntryKit instance\n   *\n   * This will:\n   * 1. Unwatch account changes\n   * 2. Clear session state (but NOT localStorage keys)\n   *\n   * Call this when unmounting your app.\n   */\n  destroy(): void {\n    console.log(\"[entrykit-drawbridge] Destroying instance\")\n\n    // Cleanup account watcher\n    if (this.accountWatcherCleanup) {\n      this.accountWatcherCleanup()\n      this.accountWatcherCleanup = null\n    }\n\n    // Clear state\n    this.updateState({\n      status: EntryKitStatus.DISCONNECTED,\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false\n    })\n  }\n\n  /**\n   * Clear stored session keys from localStorage\n   *\n   * This permanently removes the session private key for the current user.\n   * Next time connect() is called, a new session account will be created.\n   */\n  clearStorage(): void {\n    if (this.state.userAddress) {\n      sessionStorage.removeSigner(this.state.userAddress)\n    }\n  }\n\n  // ===== Convenience Getters =====\n\n  /** Get current session client (null if not connected) */\n  get sessionClient(): SessionClient | null {\n    return this.state.sessionClient\n  }\n\n  /** Get current user address (null if not connected) */\n  get userAddress(): Address | null {\n    return this.state.userAddress\n  }\n\n  /** Get current session account address (null if not connected) */\n  get sessionAddress(): Address | null {\n    return this.state.sessionAddress\n  }\n\n  /** Check if session is ready (has delegation) */\n  get isReady(): boolean {\n    return this.state.isReady\n  }\n\n  /** Get wagmi config (for advanced use cases like transactions) */\n  getWagmiConfig(): Config {\n    return this.wagmiConfig\n  }\n}\n"]}