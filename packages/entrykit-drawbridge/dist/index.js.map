{"version":3,"sources":["../src/session/storage.ts","../src/session/getSessionSigner.ts","../src/session/getSessionAccount.ts","../src/core/types.ts","../src/bundler/getPaymaster.ts","../src/bundler/createBundlerClient.ts","../src/bundler/getBundlerTransport.ts","../src/session/getSessionClient.ts","../src/delegation/checkDelegation.ts","../src/utils/signCall.ts","../src/utils/callWithSignature.ts","../src/utils/defineCall.ts","../src/delegation/setupSession.ts","../src/EntryKit.ts"],"names":["viem_createBundlerClient","getRecord","getAction","viem_writeContract","worldSystemsConfig"],"mappings":"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","file":"index.js","sourcesContent":["import { Address, Hex } from \"viem\"\n\ntype SessionStore = {\n  signers: Record<string, string> // lowercase address → private key\n}\n\n/**\n * Session key storage using localStorage\n *\n * Manages persistent session private keys for each user address.\n * Keys are stored in localStorage and survive page refreshes.\n *\n * Storage format: { signers: { \"0xabc...\": \"0x123...\" } }\n * Storage key: \"entrykit:session-signers\"\n */\nexport class SessionStorage {\n  private cache: SessionStore\n  private readonly STORAGE_KEY = \"entrykit:session-signers\"\n\n  constructor() {\n    this.cache = this.load()\n  }\n\n  /**\n   * Load session store from localStorage\n   */\n  private load(): SessionStore {\n    if (typeof localStorage === \"undefined\") {\n      return { signers: {} }\n    }\n\n    const stored = localStorage.getItem(this.STORAGE_KEY)\n    if (!stored) {\n      return { signers: {} }\n    }\n\n    try {\n      return JSON.parse(stored)\n    } catch {\n      return { signers: {} }\n    }\n  }\n\n  /**\n   * Save session store to localStorage\n   */\n  private save(): void {\n    if (typeof localStorage === \"undefined\") return\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.cache))\n  }\n\n  /**\n   * Get session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @returns Private key if exists, undefined otherwise\n   */\n  getSigner(address: Address): Hex | undefined {\n    const key = address.toLowerCase()\n    return this.cache.signers[key] as Hex | undefined\n  }\n\n  /**\n   * Store session signer private key for a user address\n   *\n   * @param address User's wallet address\n   * @param privateKey Session private key to store\n   */\n  setSigner(address: Address, privateKey: Hex): void {\n    const key = address.toLowerCase()\n    this.cache.signers[key] = privateKey\n    this.save()\n  }\n\n  /**\n   * Remove session signer for a user address\n   *\n   * @param address User's wallet address\n   */\n  removeSigner(address: Address): void {\n    const key = address.toLowerCase()\n    delete this.cache.signers[key]\n    this.save()\n  }\n\n  /**\n   * Clear all session signers\n   */\n  clear(): void {\n    this.cache = { signers: {} }\n    this.save()\n  }\n}\n\n/**\n * Singleton session storage instance\n */\nexport const sessionStorage = new SessionStorage()\n","import { Address, Hex, isHex } from \"viem\"\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\"\nimport { sessionStorage } from \"./storage\"\n\n/**\n * Get or create session signer for a user address\n *\n * Session signers are persistent private keys stored in localStorage.\n * They're used as the owner of the session smart account.\n *\n * If no signer exists for this user:\n * - Attempts to migrate from old MUD AccountKit storage format\n * - Otherwise generates a fresh random private key\n * - Stores the key for future use\n *\n * @param userAddress User's wallet address\n * @returns LocalAccount (viem account from private key)\n */\nexport function getSessionSigner(userAddress: Address) {\n  let privateKey = sessionStorage.getSigner(userAddress)\n\n  if (!privateKey) {\n    // Attempt to migrate from legacy MUD AccountKit storage format\n    // This allows existing users to keep their session accounts\n    const deprecatedKey =\n      typeof localStorage !== \"undefined\"\n        ? localStorage\n            .getItem(`mud:appSigner:privateKey:${userAddress.toLowerCase()}`)\n            ?.replace(/^\"(.*)\"$/, \"$1\") // Remove JSON quotes if present\n        : null\n\n    // Use migrated key if valid, otherwise generate new random key\n    privateKey = (isHex(deprecatedKey) ? deprecatedKey : generatePrivateKey()) as Hex\n    sessionStorage.setSigner(userAddress, privateKey)\n  }\n\n  return privateKeyToAccount(privateKey)\n}\n","import { Address, Chain, Client, LocalAccount, Transport } from \"viem\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { toSimpleSmartAccount } from \"permissionless/accounts\"\nimport { getSessionSigner } from \"./getSessionSigner\"\n\nexport type GetSessionAccountReturnType = {\n  readonly account: SmartAccount\n  readonly signer: LocalAccount\n}\n\nexport async function getSessionAccount<chain extends Chain>({\n  client,\n  userAddress\n}: {\n  client: Client<Transport, chain>\n  userAddress: Address\n}): Promise<GetSessionAccountReturnType> {\n  const signer = getSessionSigner(userAddress)\n  const account = await toSimpleSmartAccount({ client, owner: signer })\n  return { account, signer }\n}\n","import { resourceToHex } from \"@latticexyz/common\"\nimport {\n  Client,\n  Chain,\n  Transport,\n  Account,\n  parseAbi,\n  ClientConfig,\n  Address,\n  LocalAccount\n} from \"viem\"\nimport worldConfig from \"@latticexyz/world/mud.config\"\nimport { SmartAccount } from \"viem/account-abstraction\"\n\n/**\n * A viem client with an account (connected wallet)\n */\nexport type ConnectedClient<chain extends Chain = Chain> = Client<Transport, chain, Account>\n\n/**\n * Session client - ERC-4337 smart account extended with MUD World functionality\n *\n * This is a standard viem client with:\n * - SmartAccount (ERC-4337 account abstraction)\n * - MUD World extensions (callFrom, sendUserOperationFrom)\n * - Context properties (userAddress, worldAddress, internal_signer)\n *\n * Use this to call World systems on behalf of the user via delegation.\n */\nexport type SessionClient<chain extends Chain = Chain> = Client<Transport, chain, SmartAccount> & {\n  /** Original user's wallet address (the delegator) */\n  readonly userAddress: Address\n  /** MUD World contract address - all calls are routed through this */\n  readonly worldAddress: Address\n  /** Session private key - used for signing messages on behalf of session account */\n  readonly internal_signer: LocalAccount\n}\n\n/**\n * Default viem client configuration\n * Polling interval for watching blockchain state\n */\nexport const defaultClientConfig = {\n  pollingInterval: 250\n} as const satisfies Pick<ClientConfig, \"pollingInterval\">\n\n/**\n * MUD delegation control ID for \"unlimited\" delegation\n *\n * This is a resource ID that identifies the unlimited delegation control system.\n * When a user delegates to a session account with this ID, the session account\n * can call any system in the World on behalf of the user.\n *\n * Format: system resource with namespace=\"\" and name=\"unlimited\"\n */\nexport const unlimitedDelegationControlId = resourceToHex({\n  type: \"system\",\n  namespace: \"\",\n  name: \"unlimited\"\n})\n\n/**\n * MUD World table definitions from world config\n * Used to query World state (e.g., UserDelegationControl table)\n */\nexport const worldTables = worldConfig.namespaces.world.tables\n\n/**\n * Minimal World ABI for delegation registration\n * Full ABI is large, we only need this one function\n */\nexport const worldAbi = parseAbi([\n  \"function registerDelegation(address delegatee, bytes32 delegationControlId, bytes initCallData)\"\n])\n","import { Chain, Hex } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\n\n/**\n * Paymaster configuration\n *\n * Paymasters sponsor gas for user operations (ERC-4337).\n * Two types supported:\n *\n * - **simple**: Basic paymaster with just an address\n *   Returns paymaster address with empty data\n *\n * - **custom**: Advanced paymaster with client\n *   Uses provided PaymasterClient for dynamic sponsorship logic\n *   (e.g., Coinbase Paymaster, Pimlico, etc.)\n */\nexport type Paymaster =\n  | {\n      readonly type: \"simple\"\n      readonly address: Hex\n    }\n  | {\n      readonly type: \"custom\"\n      readonly address?: Hex\n      readonly paymasterClient: PaymasterClient\n    }\n\n/**\n * Get paymaster configuration for a chain\n *\n * Priority:\n * 1. Use paymasterOverride if provided (custom paymaster client)\n * 2. Check chain.contracts.paymaster for simple paymaster address\n * 3. Return undefined if no paymaster configured (user pays own gas)\n *\n * @param chain Chain configuration\n * @param paymasterOverride Optional custom paymaster client\n * @returns Paymaster config or undefined\n */\nexport function getPaymaster(\n  chain: Chain,\n  paymasterOverride?: PaymasterClient\n): Paymaster | undefined {\n  const contracts = chain.contracts ?? {}\n\n  // Use custom paymaster if provided (e.g., Coinbase Paymaster)\n  if (paymasterOverride) {\n    return {\n      type: \"custom\",\n      paymasterClient: paymasterOverride\n    }\n  }\n\n  // Check for simple paymaster in chain config\n  if (\"paymaster\" in contracts && contracts.paymaster != null) {\n    if (\"address\" in contracts.paymaster) {\n      return {\n        type: \"simple\",\n        address: contracts.paymaster.address\n      }\n    }\n  }\n\n  // No paymaster configured - user pays own gas\n  return undefined\n}\n","import { Transport, Chain, Client, RpcSchema, EstimateFeesPerGasReturnType } from \"viem\"\nimport {\n  BundlerClient,\n  BundlerClientConfig,\n  SmartAccount,\n  PaymasterClient,\n  createBundlerClient as viem_createBundlerClient\n} from \"viem/account-abstraction\"\nimport { defaultClientConfig } from \"../core/types\"\nimport { getPaymaster } from \"./getPaymaster\"\n\n/**\n * Create a bundler client for submitting ERC-4337 user operations\n *\n * A bundler client is a specialized viem client that:\n * - Submits user operations to the bundler RPC\n * - Handles gas estimation for user operations\n * - Integrates paymaster for gas sponsorship\n * - Manages smart account interactions\n *\n * This function wraps viem's createBundlerClient with:\n * - Automatic paymaster configuration from chain or override\n * - Custom fee estimation for Anvil (local dev)\n * - Default polling interval\n *\n * @param config Bundler client configuration\n * @returns Configured bundler client\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain = Chain,\n  account extends SmartAccount = SmartAccount,\n  client extends Client = Client,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  config: BundlerClientConfig<transport, chain, account, client, rpcSchema>\n): BundlerClient<transport, chain, account, client, rpcSchema> {\n  const client = config.client\n  if (!client) throw new Error(\"No `client` provided to `createBundlerClient`.\")\n\n  const chain = config.chain ?? client.chain\n  const paymaster = chain\n    ? getPaymaster(chain, config.paymaster as PaymasterClient | undefined)\n    : undefined\n\n  return viem_createBundlerClient({\n    ...defaultClientConfig,\n    // Configure paymaster for gas sponsorship\n    paymaster: paymaster\n      ? paymaster.type === \"custom\"\n        ? paymaster.paymasterClient // Use custom paymaster client (e.g., Coinbase)\n        : {\n            // Simple paymaster - just return address with empty data\n            getPaymasterData: async () => ({\n              paymaster: paymaster.address,\n              paymasterData: \"0x\"\n            })\n          }\n      : undefined,\n    // Custom fee estimation for certain chains\n    userOperation: {\n      estimateFeesPerGas: createFeeEstimator(client)\n    },\n    ...config\n  })\n}\n\n/**\n * Create custom fee estimator for specific chains\n *\n * Some chains need special handling for fee estimation:\n *\n * - **Anvil (31337)**: Hardcoded fees because Anvil's eth_maxPriorityFeePerGas\n *   returns a fixed value that doesn't match real chains\n *\n * - **Other chains**: Use viem's default fee estimation (works well)\n *\n * @param client Viem client\n * @returns Fee estimator function or undefined for default behavior\n */\nfunction createFeeEstimator(\n  client: Client\n): undefined | (() => Promise<EstimateFeesPerGasReturnType<\"eip1559\">>) {\n  if (!client.chain) return\n\n  // Anvil (local development) - use fixed fees\n  // See: https://github.com/foundry-rs/foundry/pull/8081#issuecomment-2402002485\n  if (client.chain.id === 31337) {\n    return async () => ({ maxFeePerGas: 100_000n, maxPriorityFeePerGas: 0n })\n  }\n\n  // All other chains - use viem's default fee estimation\n  return undefined\n}\n","import { Chain, http } from \"viem\"\n\n/**\n * Get bundler RPC transport for a chain\n *\n * Bundlers are special RPC endpoints that handle ERC-4337 user operations.\n * They submit user operations to the EntryPoint contract and handle gas sponsorship.\n *\n * The bundler URL must be configured in the chain's rpcUrls.bundler.http array.\n *\n * @param chain Chain configuration with bundler RPC URL\n * @returns HTTP transport for the bundler\n * @throws If chain doesn't have a bundler RPC URL configured\n */\nexport function getBundlerTransport(chain: Chain) {\n  const bundlerHttpUrl = chain.rpcUrls.bundler?.http[0]\n\n  if (bundlerHttpUrl) {\n    return http(bundlerHttpUrl)\n  }\n\n  throw new Error(`Chain ${chain.id} config did not include a bundler RPC URL.`)\n}\n","import { Account, Address, Chain, Client, LocalAccount, RpcSchema, Transport } from \"viem\"\nimport { smartAccountActions } from \"permissionless\"\nimport { callFrom, sendUserOperationFrom } from \"@latticexyz/world/internal\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { createBundlerClient } from \"../bundler/createBundlerClient\"\nimport { SessionClient } from \"../core/types\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { getBundlerTransport } from \"../bundler/getBundlerTransport\"\n\n/**\n * Create session client with MUD World extensions\n *\n * Takes a standard ERC-4337 smart account and extends it with MUD-specific functionality:\n *\n * 1. **smartAccountActions** - Standard AA operations (sendUserOperation, etc.)\n * 2. **callFrom** - Routes writeContract calls through World.callFrom()\n *    - Automatically adds delegator context\n *    - World validates delegation before executing\n * 3. **sendUserOperationFrom** - Routes user operations through World\n * 4. **Context properties** - Adds userAddress, worldAddress, internal_signer\n *\n * The resulting SessionClient can call World systems on behalf of the user,\n * as long as delegation is registered.\n *\n * @param params Session client parameters\n * @returns SessionClient with MUD World extensions\n */\nexport async function getSessionClient({\n  userAddress,\n  sessionAccount,\n  sessionSigner,\n  worldAddress,\n  paymasterOverride\n}: {\n  userAddress: Address\n  sessionAccount: SmartAccount\n  sessionSigner: LocalAccount\n  worldAddress: Address\n  paymasterOverride?: PaymasterClient\n}): Promise<SessionClient> {\n  const client = sessionAccount.client\n  if (!clientHasChain(client)) {\n    throw new Error(\"Session account client had no associated chain.\")\n  }\n\n  // Create bundler client for submitting user operations\n  const bundlerClient = createBundlerClient({\n    transport: getBundlerTransport(client.chain),\n    client,\n    account: sessionAccount,\n    paymaster: paymasterOverride\n  })\n\n  // Extend with standard ERC-4337 smart account actions\n  const sessionClient = bundlerClient\n    .extend(smartAccountActions)\n    // Extend with MUD World delegation routing\n    // This intercepts writeContract calls and routes them through World.callFrom()\n    .extend(\n      callFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    // Extend with MUD World user operation routing\n    .extend(\n      sendUserOperationFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    // Add context properties for reference\n    .extend(() => ({ userAddress, worldAddress, internal_signer: sessionSigner }))\n\n  return sessionClient\n}\n\n/**\n * Type guard to ensure client has a chain\n */\nfunction clientHasChain<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  client: Client<transport, chain, account, rpcSchema>\n): client is Client<transport, Exclude<chain, undefined>, account, rpcSchema> {\n  return client.chain != null\n}\n","import { Address, Client } from \"viem\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport { unlimitedDelegationControlId, worldTables } from \"../core/types\"\n\nexport type CheckDelegationParams = {\n  client: Client\n  worldAddress: Address\n  userAddress: Address\n  sessionAddress: Address\n  blockTag?: \"pending\" | \"latest\"\n}\n\n/**\n * Check if delegation exists in MUD World contract\n *\n * MUD World stores delegations in the UserDelegationControl table.\n * A delegation allows the session account (delegatee) to call World systems\n * on behalf of the user account (delegator).\n *\n * This function queries that table and checks if \"unlimited\" delegation exists,\n * which grants the session account full access to all systems.\n *\n * @param params Delegation check parameters\n * @returns true if unlimited delegation is registered, false otherwise\n */\nexport async function checkDelegation({\n  client,\n  worldAddress,\n  userAddress,\n  sessionAddress,\n  blockTag = \"pending\"\n}: CheckDelegationParams): Promise<boolean> {\n  // Query MUD Store table: UserDelegationControl[delegator][delegatee]\n  const record = await getRecord(client, {\n    address: worldAddress,\n    table: worldTables.UserDelegationControl,\n    key: { delegator: userAddress, delegatee: sessionAddress },\n    blockTag\n  })\n\n  // Check if the delegation type is \"unlimited\" (full system access)\n  return record.delegationControlId === unlimitedDelegationControlId\n}\n","import { Address, Chain, Client, Hex, OneOf, Transport, toHex } from \"viem\"\nimport { signTypedData } from \"viem/actions\"\nimport { callWithSignatureTypes } from \"@latticexyz/world-module-callwithsignature/internal\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport moduleConfig from \"@latticexyz/world-module-callwithsignature/mud.config\"\nimport { hexToResource } from \"@latticexyz/common\"\nimport { getAction } from \"viem/utils\"\nimport { ConnectedClient } from \"../core/types\"\n\nexport type SignCallOptions<chain extends Chain = Chain> = {\n  userClient: ConnectedClient<chain>\n  worldAddress: Address\n  systemId: Hex\n  callData: Hex\n} & OneOf<{ nonce: bigint } | { client: Client<Transport, chain> }>\n\n/**\n * Sign a World system call using EIP-712 (for CallWithSignature pattern)\n *\n * This creates a signature that can be submitted by the session account to execute\n * a call on behalf of the user (EOA).\n *\n * Flow:\n * 1. **Fetch or use nonce** - Each user has a nonce in CallWithSignatureNonces table\n *    Prevents replay attacks\n *\n * 2. **Parse systemId** - MUD system IDs are resource IDs with namespace + name\n *    e.g., \"world:PlayerSystem\" → { namespace: \"world\", name: \"PlayerSystem\" }\n *\n * 3. **Sign EIP-712 message** - User signs typed data with:\n *    - Domain: World contract + chain ID\n *    - Message: signer, system, callData, nonce\n *\n * The resulting signature can be submitted to World.callWithSignature()\n * by the session account, which will validate and execute as the user.\n *\n * **Why this pattern?**\n * - EOAs can't pay gas via paymaster directly (not smart accounts)\n * - User signs message (free, no gas)\n * - Session account submits + pays gas via paymaster\n * - User gets gasless experience!\n *\n * @param options Sign options including user client and call details\n * @returns EIP-712 signature\n */\nexport async function signCall<chain extends Chain = Chain>({\n  userClient,\n  worldAddress,\n  systemId,\n  callData,\n  nonce: initialNonce,\n  client\n}: SignCallOptions<chain>) {\n  // Get nonce for replay protection\n  // Either use provided nonce or fetch from World contract\n  const nonce =\n    initialNonce ??\n    (client\n      ? (\n          await getRecord(client, {\n            address: worldAddress,\n            table: moduleConfig.tables.CallWithSignatureNonces,\n            key: { signer: userClient.account.address },\n            blockTag: \"pending\"\n          })\n        ).nonce\n      : 0n)\n\n  // Parse MUD system ID into namespace and name components\n  const { namespace: systemNamespace, name: systemName } = hexToResource(systemId)\n\n  // Sign EIP-712 typed data\n  // User signs this message, session account will submit it\n  return await getAction(\n    userClient,\n    signTypedData,\n    \"signTypedData\"\n  )({\n    account: userClient.account,\n    // EIP-712 domain bound to World contract and chain\n    domain: {\n      verifyingContract: worldAddress,\n      salt: toHex(userClient.chain.id, { size: 32 })\n    },\n    // MUD's CallWithSignature type definitions\n    types: callWithSignatureTypes,\n    primaryType: \"Call\",\n    // Message contains all call details + nonce\n    message: {\n      signer: userClient.account.address,\n      systemNamespace,\n      systemName,\n      callData,\n      nonce\n    }\n  })\n}\n","import { Chain, parseErc6492Signature } from \"viem\"\nimport { writeContract as viem_writeContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { SignCallOptions, signCall } from \"./signCall\"\nimport CallWithSignatureAbi from \"@latticexyz/world-module-callwithsignature/out/CallWithSignatureSystem.sol/CallWithSignatureSystem.abi.json\"\nimport { ConnectedClient } from \"../core/types\"\n\nexport type CallWithSignatureOptions<chain extends Chain = Chain> = SignCallOptions<chain> & {\n  sessionClient: ConnectedClient\n}\n\n/**\n * Call a World system using signature-based execution (for EOAs)\n *\n * MUD's CallWithSignature pattern allows EOAs to execute gasless transactions:\n *\n * 1. User signs an EIP-712 message (free, off-chain)\n * 2. Session account submits the signature + call to World\n * 3. World's CallWithSignatureSystem validates the signature\n * 4. If valid, executes the call as the user (with user's identity)\n *\n * This enables gasless transactions for EOAs - the session account pays gas\n * via paymaster, but the call executes with the user's permissions/identity.\n *\n * Flow:\n *   User (EOA) → signs message → Session Account → submits to World\n *   → World validates signature → executes as User\n *\n * @param options Call parameters including user client and session client\n * @returns Transaction hash\n * @throws If ERC-6492 signature detected (not yet supported)\n */\nexport async function callWithSignature<chain extends Chain = Chain>({\n  sessionClient,\n  ...opts\n}: CallWithSignatureOptions<chain>) {\n  // Get user's signature on the call\n  const rawSignature = await signCall(opts)\n\n  // Check for ERC-6492 wrapped signatures (e.g., from Coinbase Smart Wallet)\n  // These aren't yet supported by CallWithSignature module\n  const { address, signature } = parseErc6492Signature(rawSignature)\n  if (address != null) {\n    throw new Error(\n      \"ERC-6492 signatures, like from Coinbase Smart Wallet, are not yet supported. Try using a different wallet?\"\n    )\n  }\n\n  // Session account submits the signature + call to World\n  return getAction(\n    sessionClient,\n    viem_writeContract,\n    \"writeContract\"\n  )({\n    address: opts.worldAddress,\n    abi: CallWithSignatureAbi,\n    functionName: \"callWithSignature\",\n    args: [opts.userClient.account.address, opts.systemId, opts.callData, signature]\n  } as never)\n}\n","import { Address, ContractFunctionParameters, Abi } from \"viem\"\n\nexport function defineCall<abi extends Abi | readonly unknown[]>(\n  call: Omit<ContractFunctionParameters<abi>, \"address\"> & {\n    to: Address\n    value?: bigint | undefined\n  }\n) {\n  return call\n}\n","import { Hex, encodeFunctionData, zeroAddress } from \"viem\"\nimport { sendUserOperation, waitForUserOperationReceipt } from \"viem/account-abstraction\"\nimport { waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport IBaseWorldAbi from \"@latticexyz/world/out/IBaseWorld.sol/IBaseWorld.abi.json\"\nimport { systemsConfig as worldSystemsConfig } from \"@latticexyz/world/mud.config\"\nimport { unlimitedDelegationControlId, worldAbi, SessionClient } from \"../core/types\"\nimport { callWithSignature } from \"../utils/callWithSignature\"\nimport { defineCall } from \"../utils/defineCall\"\n\nexport type SetupSessionParams = {\n  client: any\n  userClient: any\n  sessionClient: SessionClient\n  worldAddress: Hex\n  registerDelegation?: boolean\n}\n\n/**\n * Setup session by registering delegation and deploying session account\n *\n * Flow differs based on wallet type:\n *\n * **Smart Account Wallet:**\n * - Sends user operation to register delegation\n * - User's smart account submits the operation\n *\n * **EOA (Externally Owned Account):**\n * - Uses CallWithSignature pattern (gasless for user)\n * - User signs a message (EIP-712)\n * - Session account submits the signature + call\n * - World validates signature and executes as user\n *\n * **Finally:**\n * - Deploys session account if not yet deployed (via empty user operation)\n *\n * @param params Setup parameters\n */\nexport async function setupSession({\n  client,\n  userClient,\n  sessionClient,\n  worldAddress,\n  registerDelegation = true\n}: SetupSessionParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address\n\n  console.log(\"[entrykit-drawbridge] setting up session\", userClient)\n\n  if (userClient.account.type === \"smart\") {\n    // ===== Smart Account Flow =====\n    // User's wallet is already a smart account (e.g., Safe, Biconomy)\n    // Can submit user operations directly\n\n    const calls = []\n\n    if (registerDelegation) {\n      console.log(\"[entrykit-drawbridge] registering delegation\")\n      calls.push(\n        defineCall({\n          to: worldAddress,\n          abi: worldAbi,\n          functionName: \"registerDelegation\",\n          args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n        })\n      )\n    }\n\n    if (!calls.length) return\n\n    console.log(\"[entrykit-drawbridge] setting up account with\", calls, userClient)\n    const hash = await getAction(userClient, sendUserOperation, \"sendUserOperation\")({ calls })\n    console.log(\"[entrykit-drawbridge] got user op hash\", hash)\n\n    const receipt = await getAction(\n      userClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n    console.log(\"[entrykit-drawbridge] got user op receipt\", receipt)\n\n    if (!receipt.success) {\n      console.error(\"[entrykit-drawbridge] not successful?\", receipt)\n    }\n  } else {\n    // ===== EOA Flow (CallWithSignature) =====\n    // User's wallet is a regular EOA (MetaMask, etc.)\n    // Uses MUD's CallWithSignature pattern for gasless execution:\n    //   1. User signs message (free, no gas)\n    //   2. Session account submits signature + call (pays gas via paymaster)\n    //   3. World validates signature and executes as user\n\n    const txs: Hex[] = []\n\n    if (registerDelegation) {\n      console.log(\"[entrykit-drawbridge] registering delegation\")\n      const tx = await callWithSignature({\n        client,\n        userClient,\n        sessionClient,\n        worldAddress,\n        systemId: worldSystemsConfig.systems.RegistrationSystem.systemId,\n        callData: encodeFunctionData({\n          abi: IBaseWorldAbi,\n          functionName: \"registerDelegation\",\n          args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n        })\n      })\n      console.log(\"[entrykit-drawbridge] got delegation tx\", tx)\n      txs.push(tx)\n    }\n\n    if (!txs.length) return\n\n    console.log(\"[entrykit-drawbridge] waiting for\", txs.length, \"receipts\")\n    for (const hash of txs) {\n      const receipt = await getAction(\n        client,\n        waitForTransactionReceipt,\n        \"waitForTransactionReceipt\"\n      )({ hash })\n      console.log(\"[entrykit-drawbridge] got tx receipt\", receipt)\n      if (receipt.status === \"reverted\") {\n        console.error(\"[entrykit-drawbridge] tx reverted?\", receipt)\n      }\n    }\n  }\n\n  // ===== Deploy Session Account =====\n  // Session account needs to be deployed before it can be used.\n  // We deploy it eagerly here (rather than lazily on first use) so downstream\n  // code can assume the account exists and has a deterministic address.\n\n  if (!(await sessionClient.account.isDeployed?.())) {\n    console.log(\"[entrykit-drawbridge] creating session account by sending empty user op\")\n\n    // Send empty user operation to trigger account deployment\n    // The bundler/EntryPoint will deploy the account as part of executing this operation\n    const hash = await getAction(\n      sessionClient,\n      sendUserOperation,\n      \"sendUserOperation\"\n    )({\n      calls: [{ to: zeroAddress }]\n    })\n\n    const receipt = await getAction(\n      sessionClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n    console.log(\"[entrykit-drawbridge] got user op receipt\", receipt)\n  }\n}\n","import { Address, Chain, Client, Transport } from \"viem\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { SessionClient } from \"./core/types\"\nimport { getSessionSigner } from \"./session/getSessionSigner\"\nimport { getSessionAccount } from \"./session/getSessionAccount\"\nimport { getSessionClient } from \"./session/getSessionClient\"\nimport { checkDelegation } from \"./delegation/checkDelegation\"\nimport { setupSession } from \"./delegation/setupSession\"\nimport { sessionStorage } from \"./session/storage\"\nimport {\n  createConfig,\n  createStorage,\n  reconnect,\n  watchAccount,\n  connect,\n  disconnect,\n  getConnectorClient,\n  getConnectors,\n  getAccount,\n  type Config,\n  type CreateConnectorFn\n} from \"@wagmi/core\"\n\n/**\n * Configuration for EntryKit instance\n */\nexport type EntryKitConfig = {\n  /** Chain ID to operate on */\n  chainId: number\n  /** Supported chains */\n  chains: readonly [Chain, ...Chain[]]\n  /** Transport configuration per chain */\n  transports: Record<number, Transport>\n  /** Wallet connectors (injected, walletConnect, etc.) */\n  connectors: CreateConnectorFn[]\n  /** MUD World contract address */\n  worldAddress: Address\n  /** Optional paymaster client for sponsored transactions */\n  paymasterClient?: PaymasterClient\n  /** Optional polling interval for wagmi (in ms) */\n  pollingInterval?: number\n}\n\n/**\n * Current state of the EntryKit instance\n * Updated reactively and broadcast to subscribers\n */\nexport type EntryKitState = {\n  /** Session client with MUD World extensions, null if not connected */\n  sessionClient: SessionClient | null\n  /** Original user's wallet address, null if not connected */\n  userAddress: Address | null\n  /** Session smart account address, null if not connected */\n  sessionAddress: Address | null\n  /** Whether session has delegation registered and is ready to use */\n  isReady: boolean\n}\n\n/**\n * Result of checking session prerequisites\n */\nexport type PrerequisiteStatus = {\n  /** Whether delegation is registered in World contract */\n  hasDelegation: boolean\n  /** Whether session is fully ready (same as hasDelegation) */\n  isReady: boolean\n}\n\ntype StateListener = (state: EntryKitState) => void\ntype Unsubscribe = () => void\n\n/**\n * Connector info for UI display\n */\nexport type ConnectorInfo = {\n  id: string\n  name: string\n  type: string\n}\n\n/**\n * entrykit-drawbridge - Stripped down headless version of @latticexyz/entrykit\n *\n * Provides complete wallet connection and session management:\n * - Wagmi integration (connectors, account watching, reconnection)\n * - ERC-4337 session account creation\n * - MUD World delegation registration\n * - Reactive state management (framework-agnostic)\n * - Gasless transaction support via paymaster\n *\n * Usage:\n * ```typescript\n * const entrykit = new EntryKit({\n *   chainId: 8453,\n *   chains: [baseChain],\n *   transports: { 8453: http() },\n *   connectors: [injected()],\n *   worldAddress: \"0x...\"\n * });\n *\n * // Initialize (await reconnection, setup watchers)\n * await entrykit.initialize();\n *\n * // Get available wallets\n * const wallets = entrykit.getAvailableConnectors();\n *\n * // Connect to wallet\n * await entrykit.connectWallet(wallets[0].id);\n *\n * // Setup delegation if needed\n * if (!entrykit.isReady) {\n *   await entrykit.setupSession();\n * }\n *\n * // Disconnect\n * await entrykit.disconnectWallet();\n * ```\n */\nexport class EntryKit {\n  private config: EntryKitConfig\n  private state: EntryKitState\n  private listeners = new Set<StateListener>()\n  private wagmiConfig: Config\n  private accountWatcherCleanup: (() => void) | null = null\n  private isConnecting = false\n  private isDisconnecting = false\n\n  constructor(config: EntryKitConfig) {\n    this.config = config\n    this.state = {\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false\n    }\n\n    // Create wagmi config\n    this.wagmiConfig = createConfig({\n      chains: config.chains,\n      transports: config.transports,\n      connectors: config.connectors,\n      pollingInterval: config.pollingInterval,\n      storage: createStorage({\n        storage: typeof window !== \"undefined\" ? window.localStorage : undefined\n      })\n    })\n  }\n\n  /**\n   * Initialize EntryKit (await reconnection and setup account watcher)\n   *\n   * This should be called once after construction and awaited.\n   * It will attempt to reconnect to a previously connected wallet.\n   */\n  async initialize(): Promise<void> {\n    console.log(\"[entrykit-drawbridge] Initializing...\")\n\n    // Attempt to reconnect to previously connected wallet\n    let reconnected = false\n    try {\n      await reconnect(this.wagmiConfig)\n      reconnected = true\n      console.log(\"[entrykit-drawbridge] Reconnection successful\")\n    } catch (err) {\n      console.log(\"[entrykit-drawbridge] No previous connection to restore\")\n    }\n\n    // Setup account watcher for future changes\n    this.setupAccountWatcher()\n\n    // If reconnection succeeded, manually handle the initial connection\n    // (the watcher won't fire for connections that happened before it was set up)\n    if (reconnected) {\n      const account = getAccount(this.wagmiConfig)\n      if (account.isConnected && account.address) {\n        console.log(\"[entrykit-drawbridge] Processing reconnected wallet:\", account.address)\n        await this.handleWalletConnection()\n      }\n    }\n\n    console.log(\"[entrykit-drawbridge] Initialization complete\")\n  }\n\n  // ===== Reactive State Management =====\n\n  /**\n   * Subscribe to state changes\n   *\n   * The listener will be called immediately with the current state,\n   * and again whenever the state changes.\n   *\n   * @param listener Function to call on state changes\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = entrykit.subscribe((state) => {\n   *   if (state.sessionClient) {\n   *     console.log(\"Session ready:\", state.sessionClient.account.address);\n   *   }\n   * });\n   *\n   * // Later, stop listening\n   * unsubscribe();\n   * ```\n   */\n  subscribe(listener: StateListener): Unsubscribe {\n    this.listeners.add(listener)\n    listener(this.state) // Immediate callback with current state\n    return () => this.listeners.delete(listener)\n  }\n\n  /**\n   * Get current state (non-reactive snapshot)\n   *\n   * For reactive updates, use subscribe() instead.\n   */\n  getState(): EntryKitState {\n    return { ...this.state }\n  }\n\n  private updateState(updates: Partial<EntryKitState>): void {\n    this.state = { ...this.state, ...updates }\n    this.notify()\n  }\n\n  private notify(): void {\n    this.listeners.forEach(listener => listener(this.state))\n  }\n\n  /**\n   * Setup wagmi account watcher to handle connection/disconnection\n   * Called automatically by initialize()\n   */\n  private setupAccountWatcher(): void {\n    const unwatch = watchAccount(this.wagmiConfig, {\n      onChange: async account => {\n        console.log(\"[entrykit-drawbridge] Account change:\", {\n          isConnected: account.isConnected,\n          address: account.address\n        })\n\n        // Handle disconnection\n        if (!account.isConnected) {\n          console.log(\"[entrykit-drawbridge] Wallet disconnected\")\n          this.updateState({\n            sessionClient: null,\n            userAddress: null,\n            sessionAddress: null,\n            isReady: false\n          })\n          this.isConnecting = false\n          return\n        }\n\n        // Ignore connection attempts while disconnecting to prevent deadlock\n        if (this.isDisconnecting) {\n          console.log(\"[entrykit-drawbridge] Ignoring connection attempt during disconnect\")\n          return\n        }\n\n        // Handle connection\n        if (this.isConnecting) {\n          console.log(\"[entrykit-drawbridge] Already processing connection\")\n          return\n        }\n\n        if (!account.connector || !account.address) {\n          return\n        }\n\n        try {\n          this.isConnecting = true\n          await this.handleWalletConnection()\n        } catch (err) {\n          console.error(\"[entrykit-drawbridge] Connection handler failed:\", err)\n        } finally {\n          this.isConnecting = false\n        }\n      }\n    })\n\n    this.accountWatcherCleanup = unwatch\n  }\n\n  /**\n   * Internal handler for wallet connection\n   * Called when wagmi detects a connected account\n   */\n  private async handleWalletConnection(): Promise<void> {\n    // Get wallet client from wagmi\n    let userClient: Client\n    try {\n      userClient = await getConnectorClient(this.wagmiConfig)\n    } catch (err) {\n      console.log(\"[entrykit-drawbridge] Could not get connector client\")\n      return\n    }\n\n    if (!userClient.account || !userClient.chain) {\n      console.log(\"[entrykit-drawbridge] Wallet client missing account or chain\")\n      return\n    }\n\n    const userAddress = userClient.account.address\n    console.log(\"[entrykit-drawbridge] Connecting session for address:\", userAddress)\n\n    // Get or create persistent session signer from localStorage\n    const signer = getSessionSigner(userAddress)\n\n    // Create ERC-4337 SimpleAccount smart wallet\n    const { account } = await getSessionAccount({\n      client: userClient as any,\n      userAddress\n    })\n\n    // Create session client with MUD World callFrom/sendUserOperationFrom extensions\n    const sessionClient = await getSessionClient({\n      userAddress,\n      sessionAccount: account,\n      sessionSigner: signer,\n      worldAddress: this.config.worldAddress,\n      paymasterOverride: this.config.paymasterClient\n    })\n\n    // Check if delegation already exists BEFORE notifying listeners\n    // This prevents UI flash where sessionClient exists but isReady is unknown\n    const hasDelegation = await checkDelegation({\n      client: sessionClient,\n      worldAddress: this.config.worldAddress,\n      userAddress,\n      sessionAddress: account.address\n    })\n\n    // Update state once with complete information\n    this.updateState({\n      sessionClient,\n      userAddress,\n      sessionAddress: account.address,\n      isReady: hasDelegation\n    })\n\n    console.log(\"[entrykit-drawbridge] Session connection complete, isReady:\", hasDelegation)\n  }\n\n  // ===== Public API =====\n\n  /**\n   * Get available wallet connectors for UI display\n   *\n   * @returns Array of connector info (id, name, type)\n   */\n  getAvailableConnectors(): ConnectorInfo[] {\n    const connectors = getConnectors(this.wagmiConfig)\n    return connectors.map(c => ({\n      id: c.id,\n      name: c.name,\n      type: c.type\n    }))\n  }\n\n  /**\n   * Connect to a wallet by connector ID\n   *\n   * This will:\n   * 1. Connect via wagmi\n   * 2. Account watcher will automatically handle EntryKit session creation\n   *\n   * @param connectorId Connector ID (from getAvailableConnectors())\n   * @throws If connector not found or connection fails\n   */\n  async connectWallet(connectorId: string): Promise<void> {\n    const connectors = getConnectors(this.wagmiConfig)\n    const connector = connectors.find(c => c.id === connectorId)\n\n    if (!connector) {\n      throw new Error(`Connector not found: ${connectorId}`)\n    }\n\n    console.log(\"[entrykit-drawbridge] Connecting to wallet:\", connectorId)\n\n    try {\n      await connect(this.wagmiConfig, {\n        connector,\n        chainId: this.config.chainId\n      })\n    } catch (err) {\n      // If already connected, that's fine\n      if (err instanceof Error && err.name === \"ConnectorAlreadyConnectedError\") {\n        console.log(\"[entrykit-drawbridge] Already connected\")\n        return\n      }\n      throw err\n    }\n\n    // Account watcher will handle the rest\n  }\n\n  /**\n   * Disconnect wallet and clear session\n   *\n   * This will:\n   * 1. Disconnect via wagmi\n   * 2. Account watcher will automatically clear EntryKit state\n   */\n  async disconnectWallet(): Promise<void> {\n    console.log(\"[entrykit-drawbridge] disconnectWallet() called\")\n    console.log(\"[entrykit-drawbridge] Current state:\", this.state)\n    console.log(\"[entrykit-drawbridge] Calling wagmi disconnect()...\")\n\n    try {\n      this.isDisconnecting = true\n      await disconnect(this.wagmiConfig)\n      console.log(\"[entrykit-drawbridge] wagmi disconnect() returned\")\n    } catch (err) {\n      console.error(\"[entrykit-drawbridge] wagmi disconnect() threw error:\", err)\n      throw err\n    } finally {\n      this.isDisconnecting = false\n    }\n\n    console.log(\"[entrykit-drawbridge] Disconnect complete\")\n  }\n\n  /**\n   * Check if session is ready to use\n   *\n   * Queries the MUD World contract to check if delegation is registered\n   * between the user's account and the session account.\n   *\n   * @returns Delegation status\n   */\n  async checkPrerequisites(): Promise<PrerequisiteStatus> {\n    if (!this.state.sessionClient) {\n      return { hasDelegation: false, isReady: false }\n    }\n\n    const hasDelegation = await checkDelegation({\n      client: this.state.sessionClient,\n      worldAddress: this.config.worldAddress,\n      userAddress: this.state.userAddress!,\n      sessionAddress: this.state.sessionAddress!\n    })\n\n    this.updateState({ isReady: hasDelegation })\n\n    return { hasDelegation, isReady: hasDelegation }\n  }\n\n  /**\n   * Setup session by registering delegation and deploying account\n   *\n   * This will:\n   * 1. Get current wallet client from wagmi\n   * 2. Register delegation in MUD World contract (user delegates to session)\n   * 3. Deploy session smart account if not already deployed\n   *\n   * User will need to sign a transaction (EOA) or user operation (smart account).\n   *\n   * @throws If not connected (call connectWallet() first)\n   */\n  async setupSession(): Promise<void> {\n    if (!this.state.sessionClient) {\n      throw new Error(\"Not connected. Call connectWallet() first.\")\n    }\n\n    console.log(\"[entrykit-drawbridge] Setting up session (registering delegation)...\")\n\n    // Get current wallet client from wagmi\n    const userClient = await getConnectorClient(this.wagmiConfig)\n\n    await setupSession({\n      client: userClient,\n      userClient,\n      sessionClient: this.state.sessionClient,\n      worldAddress: this.config.worldAddress\n    })\n\n    this.updateState({ isReady: true })\n\n    console.log(\"[entrykit-drawbridge] Session setup complete\")\n  }\n\n  /**\n   * Cleanup and destroy EntryKit instance\n   *\n   * This will:\n   * 1. Unwatch account changes\n   * 2. Clear session state (but NOT localStorage keys)\n   *\n   * Call this when unmounting your app.\n   */\n  destroy(): void {\n    console.log(\"[entrykit-drawbridge] Destroying instance\")\n\n    // Cleanup account watcher\n    if (this.accountWatcherCleanup) {\n      this.accountWatcherCleanup()\n      this.accountWatcherCleanup = null\n    }\n\n    // Clear state\n    this.updateState({\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false\n    })\n  }\n\n  /**\n   * Clear stored session keys from localStorage\n   *\n   * This permanently removes the session private key for the current user.\n   * Next time connect() is called, a new session account will be created.\n   */\n  clearStorage(): void {\n    if (this.state.userAddress) {\n      sessionStorage.removeSigner(this.state.userAddress)\n    }\n  }\n\n  // ===== Convenience Getters =====\n\n  /** Get current session client (null if not connected) */\n  get sessionClient(): SessionClient | null {\n    return this.state.sessionClient\n  }\n\n  /** Get current user address (null if not connected) */\n  get userAddress(): Address | null {\n    return this.state.userAddress\n  }\n\n  /** Get current session account address (null if not connected) */\n  get sessionAddress(): Address | null {\n    return this.state.sessionAddress\n  }\n\n  /** Check if session is ready (has delegation) */\n  get isReady(): boolean {\n    return this.state.isReady\n  }\n\n  /** Get wagmi config (for advanced use cases like transactions) */\n  getWagmiConfig(): Config {\n    return this.wagmiConfig\n  }\n}\n"]}